너는 ‘객관적 검증자(Independent Reviewer)’다.
질문자의 의도/선호/유도에 맞추려 하지 말고, 오직 제공된 사실과 합리적 추론만으로 답해라.

++++++++++++++++++++++++++++++++++++++++++++++++++

일관성, 정합성, 오류, 타입 안정성, 입력 스펙 일관성, 설계 패턴, 비즈니스 로직 정확성, 성능, 경계 계산, 타입 혼용, 유지보수성, 참조 안정성, 구조적 설계, 운영환경 고려, 타입시스템 신뢰 관점

P0, P1, P2 이슈 검증 후 GPT에 코드 전체 붙여 넣기 > 품질 및 수준 검증 > 커서 지시문으로 수령 후 > 코드 재수정

++++++++++++++++++++++++++++++++++++++++++++++++++

공통화 요소들을 모두 내가 기억할 수는 없다. 시스템이 기억할 수 있도록 시스템화해야 한다.
공통화 요소는 크게 UI 와 기능으로 구분할 수 있다.
공공통 모듈, 콤포넌트 생성 시 > shared-catalog에 등록이 필요하다. 이후 공통 모듈, 콤포넌트 사용 시 > shared-catalog에 등록된 모듈, 콤포넌트를 사용하도록 정리한다.
공통 콤포넌트/모듈 분류 규칙
UI Core Component: 시각/레이아웃/인터랙션 프리미티브. 비즈니스 규칙 없음. API 호출 없음.
Shared Feature: 여러 페이지에서 재사용되는 사용자 플로우/기능. 상태/정책/에러/로딩 포함 가능.
Shared Hook: Feature를 UI에서 쓰기 위한 React Query/상태 캡슐화. UI 렌더링 금지.
Service: 도메인 로직/데이터 접근. UI/Router 의존 금지.
Cross-cutting(공통 유틸): 로깅/정책/권한/추적/에러처리처럼 전 영역에 적용.

++++++++++++++++++++++++++++++++++++++++++++++++++

린트, 타입, 빌드 오류 체크 통합 작업:
CI Full: eslint → typecheck → test → build: 순차 실행 > Ctrl+Shift+9번 키로 실행 가능

++++++++++++++++++++++++++++++++++++++++++++++++++

지금은 수정하지 말고, "수정해야 할 모든 위치 목록"만 프롬프트에 바로 만들어줘.
- 파일 경로 + 라인 + 수정 요지
- 총 개수 N
- "전수조사 후 반복 재검증, 최종 재검증" 후 "잔여 0개 확인"하고 종료.
- md, txt 파일 생성 금지

++++++++++++++++++++++++++++++++++++++++++++++++++

방금 만든 목록의 N개를 전부 업데이트하자
- 목록에 없는 곳은 임의로 바꾸지 말고, 발견되면 "추가 항목"으로 목록에 먼저 추가한 뒤 함께 처리해줘.
- 수정 후 "전수검증 후 반복 재검증, 최종 재검증" 후 "잔여 0개 확인"하고 종료.
- md, txt 파일 생성 금지

++++++++++++++++++++++++++++++++++++++++++++++++++

문서에서 확인된 하드코딩 금지 범위
1. CSS 변수 사용 필수 범위 (컴포넌트 디자인.md, 스키마엔진.txt)
금지 항목:
하드코딩된 px/rem/em 단위 값 (예: 16px, 1rem → var(--spacing-md) 사용)
하드코딩된 opacity 값 (예: opacity: 0.5 → var(--opacity-disabled) 사용)
하드코딩된 border 값 (예: 1px solid → var(--border-width-thin) solid 사용)
하드코딩된 아이콘 크기 (예: size={16} → useIconSize() 훅 사용)
하드코딩된 색상 값 (예: #3b82f6 → var(--color-primary) 사용)
허용 예외:
레이아웃용 특수 값 (width: 0, minWidth: 0)
CSS 속성 값 (display: 'flex', flex: 1)
2. 비즈니스 로직/계산식 하드코딩 (전체 기술문서.txt, 디어쌤 아키텍처.md)
Automation Config First 원칙:
자동화 기능의 기본 임계값/조건은 하드코딩 금지
Policy/Threshold/Toggle로 관리
단, 이는 자동화 기능에 한정
3. 더미 데이터 규칙 (rules.md)
금지:
운영 코드(apps/*, services/*, hooks/*)에서 랜덤 더미 데이터 생성
허용:
테스트 전용 더미 데이터는 dev/test/seed 영역에만 생성
Mock Data 생성 함수는 허용 (SchemaPreview.tsx의 generateMockData)

++++++++++++++++++++++++++++++++++++++++++++++++++

전수조사 지시문

전수조사는 rg(또는 IDE 검색)로 전체 리포지토리 범위를 대상으로 실행하고,
수정 전/후 결과(매치 개수)를 숫자로 비교해줘

++++++++++++++++++++++++++++++++++++++++++++++++++

너는 객관적 검증자(Reviewer)다. “최근 수정분”이 올바른지 재검증하라.
목표: (1) 컴파일/타입/런타임 오류 가능성 (2) 문서-코드 SSOT 불일치 (3) 네이밍/경로/스키마 참조 깨짐 (4) 회귀를 찾아내고, 수정 제안은 “필요할 때만” 최소로 제시한다.

[범위/원칙]
- 수정 작업을 추가로 진행하지 말고, 먼저 “검증 결과 리포트”를 작성하라. (필요한 경우에만 최소 수정안을 별도 섹션으로)
- repo 전체 기준으로 보되, 우선순위는 “최근 변경된 파일(git diff)”이다.
- md/txt 새 파일 생성 금지. (리포트는 채팅 출력으로만)
- 결과는 반드시: 파일 경로 + 라인(또는 코드 스니펫 주변) + 왜 문제인지 + 영향 + 재현/검증 방법(가능하면) 포함.

[1단계: 변경분 식별]
1) git diff로 “최근 변경된 파일 목록”과 변경 요약을 먼저 뽑아라.
   - 변경 파일별로: 추가/삭제된 핵심 심볼(함수/타입/테이블/엔드포인트/라우트)을 한 줄로 요약.

[2단계: 컴파일/타입/린트 회귀 점검]
2) 모노레포/패키지 구조에 맞게 가능한 검증을 수행하라.
   - package manager가 pnpm이면: pnpm -r typecheck / pnpm -r lint / pnpm -r test (존재하는 스크립트만)
   - 없으면: tsconfig 기반으로 tsc -b 또는 각 패키지 typecheck 대체 경로를 찾아 실행 가능 여부를 판단.
   - 실행이 불가(스크립트 없음/환경 없음)하면, “정적 검증(코드 기준)”으로 대체하고 어떤 검증을 못했는지 명시.

[3단계: SSOT/네이밍/경로 변경의 연쇄 깨짐 검증]
3) 다음 변경이 있었다고 가정하고(또는 실제 diff에서 확인하고) 연쇄 참조가 깨졌는지 전수 점검하라.
   A) student_task_cards -> task_cards (정본)
   B) StudentTaskCard -> TaskCard (정본)
   C) student_id -> entity_id + entity_type (일반화)
   D) /student_task_cards/{id}/approve-and-execute -> /task_cards/{id}/approve-and-execute (정본)
   E) automation_actions.task_id FK가 task_cards(id)를 참조해야 함
   점검 방식:
   - “문자열 검색”만 하지 말고 실제 import/타입/라우트/SDK/쿼리/SQL FK/문서 예시까지 연결해서 확인.
   - 남아있는 레거시 키워드가 “의도된 예외”인지 “미수정 누락”인지 판정해라.

[4단계: 구체 체크리스트(깨지기 쉬운 포인트)]
4) 아래 항목을 각각 체크하고, 발견 시 위치를 모두 기록하라.
   - 프론트: 컴포넌트/타입명 변경으로 인한 import 깨짐, props 타입 불일치, API 응답 필드명 불일치
   - 라우트/URL: action_url에 cardId 쿼리스트링 추가 로직이 중복/누락/오작동(?,& 처리) 없는지
   - api-sdk: endpoint path 변경이 SDK/edge/function/route handler 전부에 반영됐는지
   - DB/SQL: FK/테이블/컬럼명 변경이 마이그레이션/뷰/트리거/정책(RLS)에서 일관적인지
   - 문서: SSOT 문서에서 “정본 명칭”과 코드가 불일치하는 문장/예시/스키마 설명이 남았는지
   - 테스트/빌드: 존재한다면 수정된 부분과 연관된 테스트가 깨졌는지(또는 테스트 부재 리스크를 명시)

[5단계: 결과 출력 포맷(필수)]
5) 아래 포맷으로만 출력하라.
   1) 요약: P0/P1/P2 건수 (P0=즉시 오류/빌드 실패/런타임 크래시 가능)
   2) 변경 파일 목록(최근 변경분 기준)
   3) 이슈 리스트(중요도별):
      - [P0] 파일:경로, 라인/근거, 설명, 영향, 재현/검증 방법
      - [P1] ...
      - [P2] ...
   4) “추가로 놓치기 쉬운 검색 키워드/조건” 제안(예: legacy 심볼/엔드포인트/컬럼명/문서 예시)
   5) (선택) 최소 수정안: P0만, 가능한 경우에만 구체 패치 위치 제시(바로 수정 실행은 하지 말 것)

지금 바로 위 절차대로 repo를 열어 전수 재검증을 시작하라.

++++++++++++++++++++++++++++++++++++++++++++++++++

(바로 복붙용) Cursor 지시문 템플릿

아래를 그대로 Cursor에 던지면 “공통 로직 만들고 기억시키기”를 한 번에 시킬 수 있어요.


새 공통 로직(예: Hook/Feature/Adapter) 추가 또는 변경 시, 시스템이 기억하도록 다음을 함께 적용해라.

⚠️ 중요: 이 지시문은 "반자동 등록 처리"를 수행합니다.
- ✅ 자동화 가능: Hook 패키지 스캔, 기본 엔트리 구조 생성, 직접 구현 패턴 탐지
- ⚠️ 수동 검토 필요: useWhen 설명, doNot 목록, examples 코드, related 연결
- 📋 실행 전: scripts/check-shared-catalog.ts로 누락 항목 확인 권장

[선행 조건]
- packages/shared-catalog.ts 파일 존재 확인
  - 없으면: 다음 구조로 파일 생성
    * CatalogItem, SharedCatalog 인터페이스 정의
    * sharedCatalog 객체 초기화 (hooks/features/adapters)
    * searchCatalog 함수 (선택)
- scripts/check-shared-catalog.ts 실행하여 누락 항목 확인 (선택, 권장)

[필수 규칙]
1. packages/shared-catalog.ts가 없으면 생성, 있으면 확장
2. 새 공통 로직 추가 시 반드시 카탈로그 엔트리 추가
3. 카탈로그 엔트리 없이 새 공통 요소 사용 금지 (레거시 예외는 주석)
4. 기본 엔트리 생성 후 수동 검토 필수 (useWhen, doNot, examples 품질 확인)

[실행 단계]

1) packages/shared-catalog.ts에 엔트리 추가/갱신
   - key: 고정 (예: 'use-task-cards')
   - path: '@hooks/use-task-card' (자동 생성 가능)
   - import: 'import { useTaskCards } from "@hooks/use-task-card"' (자동 생성 가능)
   - useWhen: 'TaskCard 조회가 필요한 모든 페이지' (⚠️ 수동 입력 또는 Hook의 JSDoc에서 추출 시도)
   - doNot: ['직접 useQuery로 task_cards 조회', 'apiClient.get("task_cards") 직접 호출'] (⚠️ 수동 입력 또는 Hook의 JSDoc에서 추출 시도)
   - examples: 복붙 가능한 코드 2개 이상 (import 문 포함) (⚠️ 수동 입력 또는 Hook 파일 내 예시에서 추출 시도)
   - related: { feature: 'task-card-item', adapter: 'industryAdapter.taskCards' } (선택, ⚠️ 수동 입력)

   📋 템플릿 참고: templates/catalog-entry-template.ts

2) 직접 구현 패턴이 재발 가능한 경우
   - 모든 apps/*/.eslintrc.cjs에 no-restricted-syntax 규칙 추가/확장
   - selector는 객체명(apiClient 등)을 명시하고, message에 정확한 import 문장을 포함
   - 예: selector: "CallExpression[callee.object.name='apiClient'][callee.property.name='get'][arguments.0.value='task_cards']"
   - 예: message: 'task_cards 직접 조회 금지. @hooks/use-task-card의 useTaskCards()를 사용하세요. (import { useTaskCards } from "@hooks/use-task-card")'

   📋 템플릿 참고: templates/eslint-rule-template.cjs

3) 대표 사용처 1곳 이상을 공통 로직으로 치환
   - 중복 로직 패턴 검색 (예: apiClient.get('task_cards'))
   - 사용 빈도가 높은 화면 1개 선택 (또는 명시적으로 지정)
   - 직접 구현 코드를 공통 Hook/Feature로 교체
   - 중복 로직이 남지 않도록 확인

[결과물 출력 형식]
1. 수정/생성 파일 목록
   - 파일 경로 (신규/수정)
   - 변경 유형 (생성/추가/수정/삭제)

2. 핵심 변경 스니펫
   - 파일별 라인 번호 또는 코드 스니펫
   - 변경 내용 요약

3. shared-catalog에 추가된 엔트리 코드 블록
   - 추가된 항목의 key
   - 전체 엔트리 코드 블록

4. eslint selector/message 코드 블록
   - 추가된 규칙의 selector
   - 전체 규칙 코드 블록

++++++++++++++++++++++++++++++++++++++++++++++++++

문서에서 확인된 하드코딩 금지 범위
1. CSS 변수 사용 필수 범위 (컴포넌트 디자인.md, 스키마엔진.txt)
금지 항목:
하드코딩된 px/rem/em 단위 값 (예: 16px, 1rem → var(--spacing-md) 사용)
하드코딩된 opacity 값 (예: opacity: 0.5 → var(--opacity-disabled) 사용)
하드코딩된 border 값 (예: 1px solid → var(--border-width-thin) solid 사용)
하드코딩된 아이콘 크기 (예: size={16} → useIconSize() 훅 사용)
하드코딩된 색상 값 (예: #3b82f6 → var(--color-primary) 사용)
허용 예외:
레이아웃용 특수 값 (width: 0, minWidth: 0)
CSS 속성 값 (display: 'flex', flex: 1)
2. 비즈니스 로직/계산식 하드코딩 (전체 기술문서.txt, 디어쌤 아키텍처.md)
Automation Config First 원칙:
자동화 기능의 기본 임계값/조건은 하드코딩 금지
Policy/Threshold/Toggle로 관리
단, 이는 자동화 기능에 한정
3. 더미 데이터 규칙 (rules.md)
금지:
운영 코드(apps/*, services/*, hooks/*)에서 랜덤 더미 데이터 생성
허용:
테스트 전용 더미 데이터는 dev/test/seed 영역에만 생성
Mock Data 생성 함수는 허용 (SchemaPreview.tsx의 generateMockData)
