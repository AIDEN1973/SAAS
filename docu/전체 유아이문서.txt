📘 디어쌤 Multi-Tenant SaaS UI/UX Technical Architecture v6.0

Enterprise Edition — Zero-Trust · Schema-Driven · Multi-Tenant · Backoffice-Ready · Performance-Gated · Version-Safe

## ⚠️ Automation Config First (불변 원칙)

**본 시스템에서 어떠한 자동화도 하드코딩된 조건으로 실행되지 않는다.**
**모든 자동화는 사용자 설정값(Policy / Threshold / Toggle)을 통해 활성·비활성 및 강도가 결정되며,**
**실행 여부는 서버/Edge Function이 해당 설정을 해석하여 판단한다.**

⚠️ 표현·단어·순서 변경 금지

### 기본값(Default)의 정본 정의

**기본값(Default)이란 코드 상수가 아니라 Default Policy이다.**
**모든 자동화 기능은 기본 정책(Default Policy)을 가지며,**
**이 기본 정책은 테넌트 생성 시 설정값으로 저장된다.**
**코드에 하드코딩된 기본 임계값이나 조건은 존재하지 않는다.**

**금지 패턴:**
- ❌ "값이 없으면 기본값 사용"
- ❌ "undefined면 3으로 처리"
- ❌ 코드 내부 상수 기반 조건

**정본 패턴:**
- ✅ 설정이 존재 → 사용
- ✅ 설정이 없음 → 실행하지 않음 (Fail Closed)

### 자동화의 정본 구조

자동화는 반드시 아래 3요소 조합으로만 설명한다:

1. **Trigger**: 상황 신호 또는 이벤트
2. **Policy**: 사용자 설정값 (ON/OFF, 임계값, 승인 레벨)
3. **Executor**: Server / Edge Function (정책 해석 + 실행)

❌ 프론트엔드는 판단·실행 주체가 아니다.

---

**⚠️ 중요: 실제 패키지 경로는 R1.1(rules.md)만 정본**

본 문서에서 언급하는 개념적 레이어 표기(예: `/core-platform`, `/ui-core`, `/industry-*`)는 개념적 설명이며,
실제 Monorepo 디렉터리 구조와 네이밍 규칙은 **R1.1(rules.md)을 정본으로 따릅니다**.

구현 시에는 아키텍처 문서의 매핑 규칙을 참조하세요:
- `/core-platform` (개념) → `packages/core/*` (실제)
- `/ui-core` (개념) → `packages/ui-core` (실제)
- `/industry-*` (개념) → `packages/industry/industry-*` (실제)

⚠️ Architecture v3.3 "자동" 용어 해석 규칙 (불변):

**본 문서에서 "자동"이라는 단어는 반드시 주어를 명시해야 합니다.**

**⚠️ 프론트엔드 역할 재정의 (프론트 상황 신호 수집 문서 SSOT):**
프론트엔드는 다음 역할만 수행합니다:
- ✅ **상황 신호 수집** (Context Signal Collection)
- ✅ **UI 조정** (Priority 가중치, 배너 표시)
- ✅ **승인 요청** (Approval Request)
- ❌ **판단** (Judgment) - 서버/Edge Function 전담
- ❌ **실행** (Execution) - 서버/Edge Function 전담
- ❌ **권한 검증** (Authorization) - 서버/RLS 전담

**용어 3단 분리:**
| 단계 | 주체 | 용어 | 예시 |
|------|------|------|------|
| 1. 추천 | AI/Rule Engine | "AI가 추천한다" | AI가 메시지 초안을 추천한다 |
| 2. 정책 해석 | Edge Function | "서버가 정책을 해석한다" | 서버가 Policy 조회 및 해석 |
| 3. 생성 | Edge Function | "서버가 생성한다" | 서버가 TaskCard를 생성한다 (StudentTaskCard는 학생용 별칭) |
| 4. 승인 | 프론트엔드 | "UI가 승인 요청한다" | UI가 승인 요청을 보낸다 (실행은 서버) |

**UI 문서에서 "자동"이라는 단어는:**
- ❌ 실행을 의미하지 않음
- ✅ 시각적 강조/배너/우선순위 조정 의미
- ✅ 사용자 클릭이 필요한 추천 표현
- ✅ **반드시 주어 명시 필요**

**예시:**
- ❌ "자동 화면 전환" (오해 표현, 주어 없음)
- ❌ "UI가 자동 실행" (오해 표현, 실행은 Edge Function)
- ✅ "서버가 TaskCard를 자동 생성" (정본 표현, 주어 명시, StudentTaskCard는 학생용 별칭)
- ✅ "UI가 추천 배너를 표시, 사용자 클릭 시 이동" (정본 표현, 주어 명시)
- ✅ "SDK가 자동 재시도" (정본 표현, 주어 명시)
- ✅ "CI가 자동 실행" (정본 표현, 주어 명시)
- ❌ "UI는 자동 실행 금지" (정본: UI는 실행하지 않음, 표시·강조만 가능)

**UX 표현 ≠ 실행 의미**

---

## 자동화 설정 UI의 책임 범위 (신규 섹션)

### 자동화 설정 UI의 역할

**설정 UI는 정책을 편집한다.**
- ✅ Policy 값 수정 (ON/OFF, 임계값, 승인 레벨 등)
- ✅ Default Policy 표시 및 수정
- ✅ 설정값 저장 (`tenant_features`, `tenant_settings` 테이블)

**설정 UI는 실행 흐름을 설계하거나 시뮬레이션하지 않는다.**
- ❌ 실행 흐름 설계
- ❌ 실행 시뮬레이션
- ❌ 실행 결과 예측

**결과는 TaskCard / 로그로 확인한다.**
- ✅ TaskCard 조회 및 표시 (StudentTaskCard는 학생용 별칭, = TaskCard where entity_type='student')
- ✅ automation_actions 로그 조회 및 표시
- ✅ Daily Automation Digest 조회 및 표시

### L2 이상 액션의 정책 설정

**L2 이상 액션은 완전 자동 실행 옵션을 제공하지 않는다.**
- ❌ "완전 자동 실행" 옵션 제공 금지
- ✅ "승인 필요" 옵션만 제공
- ✅ Policy로 승인 레벨 조정 가능 (예: Teacher 승인 필요, Admin 승인 필요)

### 자동화 항목별 Policy 설정 표 (공통)

**⚠️ 모든 문서에 동일하게 삽입 (형태·내용 변경 금지)**

| 자동화 항목 | 사용자 설정 가능 | 하드코딩 금지 |
|------------|----------------|--------------|
| 출결 이상 감지 | 감지 기준, 카드 생성 여부 | 기준값 |
| 미납 알림 | 자동 발송 ON/OFF, 시점 | 발송 조건 |
| AI 업무 카드(TaskCard, task_type: 'ai_suggested', entity_type='student') | AI ON/OFF, 승인 필요 여부 | 서버가 정책에 따라 실행 |
| 대시보드 우선순위 | 가중치 조정 | 그룹 순서 |
| 리포트 생성 | 자동 생성 여부 | 생성 주기 |

※ 상위 Policy Key는 SSOT(v2 6개)로 고정된다. 신규 자동화는 event_type 카탈로그에 추가 후 가능하며, 카탈로그에 없는 event_type은 실행/추가할 수 없다. (카탈로그에 추가 = 코드 상수 `AUTOMATION_EVENT_CATALOG`에 event_type 추가)

## ✅ 설정 저장 SSOT (Single Source of Truth)

⚠️ 모든 자동화 설정은 아래 규격을 준수합니다.

저장소 및 경로 규격
- 저장소: tenant_settings KV 구조 (key='config' row의 value JSONB)
  - tenant_settings 테이블은 (tenant_id, key, value JSONB) KV 구조입니다.
  - ⚠️ 중요: `config`는 컬럼이 아니라 key='config'인 row의 value(JSONB)입니다. `tenant_settings.auto_notification.*` 같은 top-level 컬럼 표기 금지
- 자동화 정책 경로: auto_notification.<event_type>.(enabled|channel|template_key|throttle|...)
- 코드에서 설정 읽기:
  - 서버/Edge Function: getTenantSettingByPath(supabase, tenantId, path, legacyPath?) 형식 사용
    - 예: await getTenantSettingByPath(supabase, tenantId, "auto_notification.overdue_outstanding_over_limit.enabled")
    - 시그니처: (supabase: SupabaseClient, tenantId: string, path: string, legacyPath?: string) => Promise<T | null>
    - 반환 타입: T | null (Policy가 없으면 null, 있으면 직접 값 T 반환, .value 접근 불필요)
    - 프론트엔드 Hook useTenantSettingByPath: UseQueryResult<unknown, Error> 반환 (React Query의 useQuery 반환 객체)
      - 사용 예시: const { data: enabledValue } = useTenantSettingByPath("auto_notification.overdue.enabled");
      - data 속성: T | null (Policy가 없으면 null, 있으면 직접 값 T, .value 접근 불필요)
      - 코드 위치: packages/hooks/use-config/src/useConfig.ts
    - 코드 위치: infra/supabase/functions/_shared/policy-utils.ts
    - ⚠️ **자동 검증 (구현 상태)**: `getTenantSettingByPath()` 함수는 `auto_notification.<event_type>.*` 형식의 경로를 받을 때 자동으로 event_type을 추출하여 카탈로그에 등록된 값인지 검증합니다 (Fail-Closed, 구현 확인: `infra/supabase/functions/_shared/policy-utils.ts:82`에서 `assertAutomationEventType` 호출).
  - 프론트엔드: 프론트엔드 래퍼 함수 사용 (구현 필요 시 packages/hooks/use-config 또는 유사 패키지에서 제공)
    - ⚠️ 프론트엔드에서는 직접 getTenantSettingByPath를 호출하지 않으며, React Hook 또는 API 클라이언트를 통해 접근
  - 내부 동작: 1) tenant_settings에서 tenant_id + key='config' row의 value(JSONB) 획득, 2) value(JSONB)에서 경로 추출

✅ 금지 사항
- ❌ tenant_settings.auto_notification.* 처럼 config 없이 top-level 컬럼처럼 보이는 표기 금지
- ❌ v1/v2 키를 이중 저장 금지 (legacy v1은 alias-only, 저장 경로로 사용 금지)
- ❌ 채널 코드 'kakao' 저장 금지 (SSOT-3: 저장/실행용은 'sms' | 'kakao_at'만 허용)

## ⚠️ Policy Key v2 (Purpose-Based) — SSOT (정본)

⚠️ 중요: 정본은 Policy Key v2 6개만 사용, legacy_policy_key는 UI 필터/검색용 alias

본 시스템의 자동화는 Policy Key(v2) 6개를 정본(SSOT)으로 사용한다.
- 정책 저장/권한/라우팅/설정 UI 그룹핑은 policy_key_v2만 사용한다.
- 기존 5개 Policy Key는 legacy_policy_key(alias)로만 유지한다. (런타임 SSOT 아님)
- 신규 자동화 추가는 Policy Key를 늘리는 것이 아니라 event_type(시나리오) 카탈로그에 추가로만 수행한다. (카탈로그에 추가 = 코드 상수 `AUTOMATION_EVENT_CATALOG`에 event_type 추가)
- 설정값이 없거나 enabled=false이면 자동화는 실행되지 않는다(Fail-Closed).

### Policy Key v2 (6)
1) financial_health: 재무/현금흐름/수납/매출 KPI
2) capacity_optimization: 정원/시간표/반 운영 최적화
3) customer_retention: 출결 유지/이탈 예방/리스크 케어
4) growth_marketing: 신규/성장/전환/지역 경쟁(벤치마킹)
5) safety_compliance: 안전/공지/동의/민감정보/분쟁 리스크
6) workforce_ops: 강사/직원 운영(업무량/결근/대체)

### Legacy Policy Key(v1, 기존 5개) — Alias Only
- attendance_anomaly / payment_overdue / ai_suggestion / report_generation / dashboard_priority(미사용)
- legacy_policy_key는 표시/검색/호환을 위한 메타데이터이며, 정책 저장 경로의 SSOT가 아니다.
- 동일 event_type에 대해 v2 정책과 v1 정책을 이중 저장하지 않는다(설정 중복 금지).

### 확장 규칙
- 상위 Policy Key(v2 6개)는 고정(SSOT).
- 신규 자동화는 event_type 카탈로그에 추가하고, policy_key_v2 / legacy_policy_key / level / trigger / executor / policy_path를 정의한다.
- 문서/코드에서 "표에 없는 자동화 신규 추가 불가"는 "카탈로그에 없는 event_type은 실행/추가 불가"로 해석한다.

### 코드 SSOT 위치
- event_type 카탈로그 정본(SSOT)은 코드 상수 `AUTOMATION_EVENT_CATALOG`이며, 문서의 표는 그 카탈로그를 반영한 출력물이다.
  - **구현 상태**: ✅ `AUTOMATION_EVENT_CATALOG` 코드 상수 구현 완료 (2024년 구현, 파일 경로: `packages/core/core-automation/src/automation-event-catalog.ts`, `infra/supabase/functions/_shared/automation-event-catalog.ts`)
  - **코드 위치**: `packages/core/core-automation/src/automation-event-catalog.ts`, `infra/supabase/functions/_shared/automation-event-catalog.ts`
- legacy_policy_key는 UI 필터/검색/호환 표기용이며, 런타임 저장/실행/권한 분기에는 사용하지 않는다.
- 설정 저장은 tenant_settings KV 구조에서 key='config' row의 value(JSONB) 경로 기반이며, 신규 항목은 auto_notification.<event_type>.<field> 형식으로 추가한다.
  - 서버/Edge Function 코드 예시: await getTenantSettingByPath(supabase, tenantId, "auto_notification.overdue_outstanding_over_limit.enabled")
  - 내부 동작: 1) tenant_settings에서 key='config' row의 value(JSONB) 획득, 2) value(JSONB)에서 경로 추출

### 책임 경계 (Responsibility Boundary)

1) tenant_settings KV: key='config' row의 value(JSONB) 내부 경로 notification.* (메시지/알림 인프라 기본 정책)
  - ⚠️ 중요: notification.* 경로는 tenant_settings 테이블의 key='config' row의 value(JSONB) 내부 경로입니다. 저장 위치는 tenant_settings(key='config').value(JSONB)입니다.
- 기본 채널, 발송 제한, fallback, provider 등 "인프라 레벨" 정책
- 자동화별 오버레이가 없을 때 사용되는 기본값

2) tenant_settings KV: key='config' row의 value(JSONB) 내부 경로 auto_notification.<event_type>.* (자동화별 정책 오버레이)
- 자동화 enable/channel/template_key 등 "event_type 단위 정책"
- 각 자동화 시나리오별 세부 설정

3) tenant_features['ai'].enabled (+ PLATFORM_AI_ENABLED)
- AI 실행/비용이 걸리는 기능의 최종 스위치 (Fail-Closed)
- 프론트는 숨김이 아니라 "표시하되 실행을 막는 방식"이 원칙

### 자동화 설정 UI 그룹핑 규칙
- 자동화 설정 화면은 policy_key_v2 6개를 1차 탭/그룹으로 사용한다.
- "레거시 보기" 토글(선택)은 legacy_policy_key(기존 5개)로 필터/정렬만 제공한다.
- 실제 저장은 event_type 기반 설정(`auto_notification.*`)으로 1곳만 저장하며, legacy 키로 별도 저장 금지.
- L2(승인 필요) 시나리오는 UI에서 "승인 필요" 뱃지/설명 고정.

---

0. 문서 목적 (Purpose)

本 문서는 디어쌤 SaaS 플랫폼을 다음 목표 수준으로 안정적으로 운영하기 위한 최종 UI/UX 기술 아키텍처 규약이다:

✔ 업종 10 → 100 확장
✔ 테넌트 5,000 → 30,000 확장
✔ 고객용 + Backoffice UI를 통합적으로 운영
✔ 고성능(Initial Load ≤ 500KB) 유지
✔ 접근성 WCAG 2.1 AAA 목표
✔ Zero-Trust 기반 보안 모델
✔ SDUI 스키마 기반 자동 UI 생성
✔ 스키마 버전관리 + 안전한 업그레이드
✔ 모듈·앱·위젯 간 강력한 Isolation
1. Enterprise Architecture Principles (EA-Principles)
🎯 1.1 Zero-Trust UI Layer (강화됨)

UI는 테넌트/업종에 대한 신뢰를 갖지 않는다.

Zero-Trust 원칙:

UI는 절대로 테넌트 ID를 생성하거나 수정하지 않는다.

업종(Industry Context)도 UI가 직접 결정하지 않는다.

모든 데이터 요청은 @api-sdk/core를 통해서만 발생한다.

@api-sdk/core는 항상 아래 3개를 포함하여 요청한다:

tenant_id

industry_type

auth token

⚠️ 중요: 요청은 tenant/industry 컨텍스트를 포함할 수 있으나, 이는 JWT claim/서버 검증 기반이며 UI는 해당 값을 생성·수정·오버라이드할 수 없다.

➡ UI는 권한을 추론하지 않고, SDK는 권한을 생성하지 않는다.
➡ 권한 결정은 전부 Supabase RLS가 맡는다.

🎯 1.2 Boundary & Isolation (강화됨)
UI Architecture Boundary
schema-engine  →  core-ui  →  design-system  →  theme-engine
        ↓
(custom widget sandbox)

**Custom Widget Sandbox 격리 수준**:
- iframe sandbox 또는 VM 기반 실행 환경 사용
- `@api-sdk/core` import 금지 (보안 격리)
- 스키마 엔진에서 제공하는 제한된 API만 접근 가능
- 업종별 스키마 import 금지 (다른 업종 데이터 접근 방지)


각 모듈은 다음을 침범할 수 없다:

모듈	금지사항
schema-engine	Tailwind 클래스 직접 사용 금지
core-ui	스키마 구조 해석 금지
widgets	@api-sdk/core, 다른 업종 schema import 금지
apps	@api-sdk/core 우회 금지 (직접 fetch 금지)
🎯 1.3 Schema-Driven Everything

UI = 스키마
Form = 스키마
Table = 스키마
Validation = 스키마
Field 조건부 로직 = 스키마
레이아웃(columns/gap) = 스키마 → Props 형태로 전달

절대 Tailwind 클래스 문자열을 스키마에서 사용하지 않는다.

🎯 1.4 Performance Budget Enforcement = Hard Gate

성능 목표는 "권장"이 아니라 "필수(Gate)"이다.

**성능 목표 근거**:
- **Initial Load Bundle ≤ 500KB**: 모바일 4G 기준 1.5s FCP(First Contentful Paint)를 만족하기 위한 상한선
- **FCP ≤ 1.5s**: 사용자가 콘텐츠를 인지할 수 있는 최소 시간 기준
- **TTI ≤ 800ms**: 인터랙티브한 사용자 경험을 위한 상한선
- **Interaction Delay ≤ 100ms**: 사용자 입력에 대한 즉각적인 피드백 제공 기준

Metric	목표	Gate 동작	근거
Initial Load Bundle	≤ 500KB	초과 시 빌드 실패	모바일 4G 기준 1.5s FCP 만족
FCP	≤ 1.5s	초과 시 경고	콘텐츠 인지 가능 최소 시간
TTI	≤ 800ms	초과 시 빌드 실패	인터랙티브 경험 상한선
Interaction Delay	≤ 100ms	초과 시 경고	즉각적인 피드백 제공 기준

CI에 아래 도구를 통합한다:

Webpack/Next.js Bundle Analyzer

LightHouse CI

Custom JS Bundle Budget Script

🎯 1.5 Version-Safe SDUI

스키마 버전, 테마 버전, 업종 버전 모두 version-safe 구조다.

스키마 충돌 발생 시:

Migration Script 실행

Legacy Renderer와의 병행 운영 금지
(→ 엔터프라이즈는 번들 절감을 위해 병행 운영을 최대한 피해야 한다)

2. Module-Level Architecture (완전 정리)
2.1 Monorepo 구조
/packages
  /core/              # 업종 공통 Core Platform Layer
    /ui-core/         # 디자인 시스템 + 반응형 + 다크모드 + 확대보기 (실제 패키지: packages/ui-core)
    /core-tags/       # 공통 태깅 시스템
    /core-auth/       # 인증
    /core-tenancy/    # 테넌시
    /core-billing/    # 과금
    /core-party/      # 회원/고객 공통 모델
    /core-calendar/   # 일정/예약/수업 스케줄
    /core-community/  # 게시판/댓글/공지
    /core-storage/    # 파일 업로드/권한
    /core-search/     # Full Text Search
    /core-analytics/  # 통계 파이프라인
    /core-activity/   # Activity Feed / 타임라인 이벤트 기록
    /core-consultation/ # 상담/기록 관리
    /core-reviews/    # 리뷰/평가 시스템
    /core-coupons/    # 쿠폰/할인 관리
    /core-tenancy-referral/ # B2B 추천인 코드
    /core-events/     # 이벤트/프로모션
    /...              # 기타 Core 모듈
  /design-system      # Tokens, Theme Engine
  /schema-engine      # Renderer + Meta-Schema + Versioning + Custom Widget Registry
  /api-sdk            # Zero-Trust 권한 주입 (@api-sdk/core)
  /services/          # DB 접근 Service Layer
  /hooks/             # React Query 기반 Hooks
  /lib/               # 공통 유틸
  /industry/          # 업종별 모듈 (학원/미용/네일/부동산/체육관/비영리)
  /widgets            # 샌드박스 위젯 (격리)

/admin-ui-kit         # Backoffice 전용 UI Kit (상용화 단계)

/apps
  /academy-admin      # 학원 관리자/선생님용
  /academy-parent     # 학부모용
  /super-admin        # SaaS 본사 플랫폼 콘솔
  /public-gateway     # 로그인 없이 접근하는 결제/키오스크/공개 페이지

2.2 @api-sdk/core (실제 Zero-Trust 실행부)

UI는 다음을 직접 호출할 수 없다:

fetch

axios

supabase client

모든 요청은 @api-sdk/core에서만 수행한다.

SDK는 자동으로 다음을 요청에 삽입한다:

{
  tenant_id: <tenant_id>,
  industry_type: <industry_type>,
  authorization: <jwt_token>
}


➡ UI는 "무슨 테넌트인지" 또는 "어떤 업종인지" 이해하지 않아도 된다.
➡ UI가 접근할 수 있는 데이터 범위는 RLS가 책임진다.

**@api-sdk/core Error Handling 규칙**:

인증 만료:
- JWT 토큰 만료 시 자동으로 로그인 페이지로 리다이렉트
- 401 Unauthorized 응답 시 Context 초기화 및 인증 재요구

테넌트 변경:
- Context의 `tenantId` 변경 시 모든 활성 쿼리 자동 무효화 (`invalidateQueries()`)
- 새로운 테넌트 컨텍스트로 자동 재요청

Industry Mismatch:
- 요청한 `industry_type`과 실제 데이터의 `industry_type` 불일치 시 오류 반환
- RLS 정책에 의해 자동 차단되며, SDK는 오류를 UI에 전달

네트워크 오류:
- 일시적 네트워크 오류는 자동 재시도 (최대 3회)
- 영구적 오류는 Error Boundary로 전달하여 사용자에게 표시

→ 모든 오류 처리는 Zero-Trust 원칙을 준수하며, UI는 오류 메시지만 표시하고 권한 결정은 하지 않음

**Edge Function 호출 규칙**:

⚠️ 중요: Edge Function 호출도 반드시 `@api-sdk/core`를 통해서만 수행해야 합니다.

- UI는 절대 직접 `fetch`로 Edge Function을 호출하지 않음
- `apiClient.post()` 또는 `apiClient.get()`을 사용하여 Edge Function 호출
- Edge Function 엔드포인트는 `functions/v1/{function-name}` 형식으로 지정
- `apiClient`는 자동으로 tenant_id, industry_type, JWT 토큰을 포함하여 요청

예시:
```typescript
// ✅ 올바른 방법: @api-sdk/core 사용
import { apiClient } from '@api-sdk/core';

const response = await apiClient.post<ResponseType>(
  'functions/v1/student-risk-analysis',
  {
    student_id: studentId,
  } as Record<string, unknown>
);

if (response.error) {
  throw new Error(response.error.message || '요청에 실패했습니다.');
}

return response.data;
```

❌ 금지:
```typescript
// ❌ 잘못된 방법: fetch 직접 사용
const response = await fetch(`${supabaseUrl}/functions/v1/student-risk-analysis`, {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${token}`,
  },
  body: JSON.stringify({ student_id: studentId }),
});
```

2.3 schema-engine ↔ core-ui 통신 방식 (강력한 정교화)
❌ 스키마에서 Tailwind 문자열 사용 금지
✔ props 기반 layout 전달

예:

{
  "form": {
    "layout": {
      "columns": 2,
      "columnGap": "md"
    }
  }
}


ui-core는 이를 내부적으로 CSS 변수 기반 스타일/토큰(`var(--spacing-*)`, `var(--color-*)` 등)으로 해석하여 적용한다.

→ 스키마는 논리적 구조만, 스타일은 core-ui만 담당한다.

3. Schema-Driven UI (SDUI) — Enterprise 버전
3.1 Meta-Schema Validation

스키마 구조는 다음 단계에서 검증된다:

개발(local dev)

CI 빌드 단계

테넌트 배포 시

Schema Registry에 등록 시점

오류가 발견되면 UI는 뜨기 전에 Error Boundary로 안전 중단.

3.2 Schema Versioning (완벽 정리)

각 스키마는 다음 형태:

{
  "version": "2.0.1",
  "minSupportedClient": "1.12.0",
  "entity": "student",
  ...
}

버전 충돌 처리:
종류	처리
Schema > Client 지원 버전	Client 업데이트 유도
Client > Schema 버전	Migration Script 자동 실행
Major upgrade	Legacy renderer 삭제 + 사전 Migration
3.3 Schema Migration Script (실전 원칙)

Migration Script는 런타임이 아니라 빌드 타임 또는 백엔드 시점에서 실행해야 한다.

이유:

클라이언트가 두 버전 렌더러를 포함하면 번들 크기 폭증

엔터프라이즈에서는 “런타임 마이그레이션”을 허용하지 않는다

때문에:

빌드 타임 변환 (권장)

새로운 버전이 Schema Registry에 등록될 때 변환

백엔드에서 스키마 업그레이드를 atomic 작업으로 수행

4. Multi-Tenant Theme Engine
4.1 Theme Merge Priority

1. system default tokens (시스템 기본 토큰)
2. industry tokens (업종별 토큰) - `industry_themes` 테이블에서 조회
3. tenant theme override (테넌트별 오버라이드) - `tenant_theme_overrides` 테이블에서 조회
4. dark mode (다크모드) - 시스템 설정 자동 감지 (`prefers-color-scheme: dark`)
5. high contrast (forced-colors, 접근성) - 시스템 설정 자동 감지 (`prefers-contrast: high`) 또는 수동 설정

→ UI는 위 레이어에서 순차적으로 override되어 최종 Token Set을 사용한다.

**구현 위치**:
- Theme Engine: `packages/design-system/src/theme.ts`
- Theme Hook: `packages/ui-core/src/hooks/useTheme.ts`
- CSS 적용: `packages/ui-core/src/utils/applyTheme.ts`

**업종별 테마 토큰**:
- `industry_themes` 테이블에서 업종별 색상 토큰 조회
- 테이블이 없거나 데이터가 없으면 기본 테마 사용 (graceful fallback)

**다크모드 및 High Contrast 자동 감지**:
- `useTheme({ mode: 'auto' })` 사용 시 시스템 다크모드 설정 자동 감지
- `useTheme({ highContrast: false })` 사용 시 시스템 High Contrast 설정 자동 감지
- 시스템 설정 변경 시 자동으로 테마 재적용

**기본 스타일 수정 위치**:
- **전역 CSS 변수**: `packages/ui-core/src/styles.css` - 폰트, 간격, 크기, 테두리 반경, 그림자 등 모든 테넌트 공통 스타일
  - **폼 필드 컴포넌트 디자인 토큰**: `styles.css`의 "폼 필드 컴포넌트 디자인 토큰" 섹션에서 Input, Select, DatePicker, Textarea 등 모든 폼 필드 컴포넌트의 스타일을 통합 관리
  - **아이콘 관련 토큰**: `--size-icon-sm` (10px), `--size-icon-md` (14px), `--size-icon-base` (16px), `--stroke-width-icon` (1.5), `--stroke-width-icon-thin` (1), `--stroke-width-icon-medium` (2), `--stroke-width-icon-bold` (2), `--stroke-width-icon-bold-sidebar` (3)
  - **투명도 토큰**: `--opacity-disabled` (0.5), `--opacity-loading` (0.6), `--opacity-inactive` (0.6), `--opacity-secondary` (0.7), `--opacity-full` (1)
  - **필터 효과 토큰**: `--filter-icon-glow` (아이콘 발광 효과, 테이블 정렬 아이콘 등)
  - **테이블 컴포넌트 토큰**: `--color-table-row-border` (#bec9d3, 테이블 행간 테두리 색상), `--letter-spacing-table-header` (0.05em, 테이블 헤더 글자 간격)
  - **레이아웃 너비 토큰**: `--width-sidebar` (13rem, 사이드바 너비), `--width-sidebar-collapsed` (4.5rem, 사이드바 축소 너비), `--width-drawer` (20rem, Drawer 기본 너비), `--width-layer-menu` (레이어 메뉴 기본), `--width-layer-menu-tablet` (태블릿 레이어 메뉴), `--width-layer-menu-expanded` (레이어 메뉴 확장)
  - **레이아웃 간격 토큰**: `--spacing-content-top` (64px, 바디와 사이드바 동일한 상단 여백), `--spacing-negative-xs` (-4px, 사이드바 메뉴 행간 간격 줄이기용)
  - **타이포그래피 토큰**: `--letter-spacing-title` (-0.02em, 타이틀 글자 간격)
- **컴포넌트별 기본 스타일**: `packages/ui-core/src/components/*.tsx` - 각 컴포넌트의 레이아웃, 패딩, 마진, 호버 효과 등
  - **예외**: 폼 필드 컴포넌트는 개별 파일에서 하드코딩하지 않고, `styles.css`의 디자인 토큰만 사용
  - **DataTable 컴포넌트**: 정렬 기능 기본 활성화 (sortable 기본값: true), 필터 아이콘 클릭 시 정렬 기능 동작, 모든 스타일은 CSS 변수 사용
- **테넌트별 색상 변경**: `packages/ui-core/src/utils/applyTheme.ts` - 색상만 동적으로 변경 (기본 스타일은 변경하지 않음)

**기본 스타일 수정 예시**:
- 버튼 패딩 변경: `packages/ui-core/src/components/Button.tsx`의 `sizeStyles` 수정
- 테이블 헤더 스타일 변경: `packages/ui-core/src/components/DataTable.tsx`의 인라인 스타일 수정
- 전역 간격 변경: `packages/ui-core/src/styles.css`의 `--spacing-*` 변수 수정
- 폼 필드 테두리 스타일 변경: `packages/ui-core/src/styles.css`의 `--border-width-form-bottom`, `--shadow-form-bottom-*` 등 폼 필드 디자인 토큰 수정

**폼 필드 컴포넌트 디자인 토큰 (일관성 관리)**:
- 모든 폼 필드 컴포넌트(Input, Select, DatePicker, Textarea)는 `styles.css`의 디자인 토큰을 통해 일관성 있게 관리됨
- 테두리 두께, 색상, 포커스 효과 등 모든 스타일이 CSS 변수로 통합 관리
- 레이아웃 이동 방지: `border-bottom`은 항상 고정 두께로 유지하고, 시각적 효과는 `box-shadow`로 구현
- 에러 색상, 비활성화 색상 등도 디자인 토큰으로 통합 관리

→ 상세 가이드: `docu/컴포넌트 디자인.md` 참조 (폼 필드 컴포넌트 디자인 토큰 상세 가이드 포함)

5. UI Kit Strategy — Customer vs Backoffice

**Customer UI vs Admin UI 비교표**:

항목	Customer UI (core-ui)	Admin UI (admin-ui-kit)
Data Density	낮음 (가독성 우선)	높음 (정보 밀도 최대화)
Interaction	시각 중심 (애니메이션, 인터랙션 풍부)	작업 효율 중심 (단축키, 빠른 액션)
Table 기능	최소 (기본 정렬, 필터링)	고급 (pivot, grouping, 가상화, 다중 정렬)
반응형	모바일 중심 (모바일 우선 설계)	데스크톱 중심 (대형 화면 최적화)
시각적 완성도	높음 (브랜드 일관성, 애니메이션)	중간 (기능성 우선, 최소한의 스타일링)
사용자 타겟	최종 사용자 (학생, 학부모, 고객)	운영자 (관리자, 직원, 운영팀)
접근성	WCAG 2.1 AAA 목표	WCAG 2.1 AA 목표 (데이터 밀도로 인한 제약)

5.1 Customer-Facing UI (core-ui)

반응형 최적화

모바일 중심

시각적 완성도 우선

애니메이션·인터랙션 풍부

5.2 Backoffice (admin-ui-kit)

데이터 밀도 높음

고급 테이블 기능(그룹핑, pivot, 가상화)

단축키 지원

operator-first 설계

UI 효율성 우선

공통 요소:

동일 SDUI 엔진 사용

동일 Token Engine 사용

동일 Versioning 전략 적용

6. Responsive UX — Enterprise Version

6-0. 반응형 브레이크포인트 표준 (Critical)

⚠️ 중요: 모든 반응형 구현은 다음 공식 브레이크포인트 수치를 사용합니다.

⚠️ 참고: 이 수치는 Tailwind CSS와 동일하지만, 스키마엔진에서는 Tailwind 클래스 문자열을 직접 사용하지 않습니다. 숫자 규격만 참조합니다.

브레이크포인트 수치 (고정 값):

| 브레이크포인트 | 최소 너비 | 용도 |
|--------------|----------|------|
| xs (기본) | 0px | 모바일 (기본) |
| sm | 640px | 큰 모바일 / 작은 태블릿 |
| md | 768px | 태블릿 |
| lg | 1024px | 작은 데스크톱 |
| xl | 1280px | 큰 데스크톱 |

useResponsiveMode() 훅 사용:

```typescript
// packages/ui-core/src/hooks/useResponsiveMode.ts
export function useResponsiveMode() {
  const [mode, setMode] = useState<'xs' | 'sm' | 'md' | 'lg' | 'xl'>('xs');

  useEffect(() => {
    const updateMode = () => {
      const width = window.innerWidth;
      if (width >= 1280) setMode('xl');
      else if (width >= 1024) setMode('lg');
      else if (width >= 768) setMode('md');
      else if (width >= 640) setMode('sm');
      else setMode('xs');
    };

    updateMode();
    window.addEventListener('resize', updateMode);
    return () => window.removeEventListener('resize', updateMode);
  }, []);

  return mode;
}
```

→ 이 브레이크포인트 수치는 디자인팀/프론트엔드팀/백엔드팀 간 일관성을 보장하기 위한 표준입니다.

6-1. 기기별 UX 패턴

Mobile (xs, sm)

Bottom Action Bar (표준 명칭으로 통일)

Fullscreen Drawer

Card-first Layout

⚠️ 중요: 모바일에서는 모달 우선 사용
- 간단한 수정 작업: 모달 사용
- 복잡한 작업: Fullscreen Drawer 사용
- 페이지 전환은 최소화 (부자연스러움)

Tablet (md)

2-column + Drawer Overlay

⚠️ 중요: 태블릿에서는 Drawer 또는 모달 사용
- 수정 작업: Drawer Overlay 권장
- 간단한 확인/알림: 모달 사용

Desktop (lg, xl)

Multi-panel

High-density table

Persistent Sidebar

⚠️ 중요: 데스크톱에서는 페이지 또는 모달 선택 가능
- 복잡한 작업: 페이지 사용
- 간단한 수정: 모달 사용

6-2. 모달 vs 페이지 선택 기준

⚠️ 중요: 모든 UI 개발 시 다음 기준을 따라야 합니다.

모달 사용 기준:
1. 간단한 수정 작업 (1-2분 이내 완료 가능)
2. 목록에서 빠른 액션 (카드/테이블 행에서 직접 수정)
3. 확인/알림 메시지 (사용자 피드백)
4. 모바일 환경 (xs, sm) - 모든 수정 작업
5. 부분 데이터 수정 (전체 폼이 아닌 일부 필드만)

페이지 사용 기준:
1. 복잡한 작업 (5분 이상 소요, 여러 단계)
2. 독립적인 작업 흐름 (다른 데이터 참조 불필요)
3. 데스크톱 환경 (lg, xl)에서 복잡한 폼
4. 상세 정보 조회 (읽기 전용, 많은 정보 표시)
5. URL 공유 필요 (특정 리소스 링크 공유)

6-3. 알림/경고 모달 규칙 (Critical)

[불변 규칙] 모든 알림/경고/확인 대화상자는 커스텀 모달을 사용해야 합니다.

❌ 금지:
- window.alert()
- window.confirm()
- window.prompt()

✅ 허용:
- useModal().showAlert(message, title?, type?)
- useModal().showConfirm(message, title?)
- 커스텀 Modal 컴포넌트

이유:
1. 일관된 UX: 모든 알림이 동일한 디자인 시스템 사용
2. 접근성: 커스텀 모달은 접근성 개선 가능
3. 모바일 최적화: 모바일에서 네이티브 alert는 부자연스러움
4. 테마 지원: 다크모드, 테넌트 테마 적용 가능
5. i18n 지원: 다국어 메시지 지원

→ 상세 가이드라인은 본 문서의 "6-2. 모달 vs 페이지 선택 기준" 섹션 참조

6-4. [SSOT] 글로벌 헤더 AI 토글 — UX/정책 (불변)

[불변 규칙] 글로벌 헤더에는 AI 기능 온오프 토글 스위치가 포함되어야 합니다.

위치: `packages/ui-core/src/components/Header.tsx`

### 1) 토글의 위치/역할

- AI 기능 온/오프는 "글로벌 헤더"에서만 제어한다.
- 토글은 테넌트 단위 기능 스위치이며, 비용/정책 목적의 즉시 차단을 지원한다.

### 2) 상태(3-state) 표시 규칙

- **AI ON**: 사용 가능
- **AI OFF**: 사용자가 꺼둠
- **AI 차단(시스템)**: 시스템 정책으로 강제 OFF (토글 비활성 + 안내문 표시)

### 3) 숨김 금지 (Critical)

- AI OFF 상태에서도 관련 메뉴/페이지/섹션/버튼은 숨기지 않는다.
- 사용자는 기능 위치를 항상 동일하게 발견할 수 있어야 한다.

### 4) 대신 "실행만 차단" (일관 UX)

- AI OFF일 때:
  - 실행/생성/재생성/업데이트 버튼은 노출 유지하되 비활성(disabled)
  - 버튼 주변 또는 툴팁/헬퍼텍스트로 즉시 사유를 설명한다.
    예시 문구: "AI 기능이 꺼져 있어 실행할 수 없습니다. 상단 AI 토글에서 켜세요."
- 기존에 이미 생성된 AI 결과(요약/브리핑/인사이트/리포트)는 표시 가능(읽기 전용)
- 아직 결과가 없는 화면은 빈 상태로 안내한다.
  예시 문구: "AI 기능이 꺼져 있어 서버가 결과를 생성하지 않습니다."

### 5) 토글 조작 권한/안전

- 기본 권한: 원장/관리자(owner/admin)만 토글 변경 가능
- 토글 변경 시 즉시 적용(캐시 반영 포함)
- 시스템 강제 차단 상태에서는 사용자가 ON으로 바꿀 수 없음(토글 disabled)

### 6) 일관된 사용자 경험(권장)

- OFF 상태에서 사용자가 실행을 시도하면:
  - 실패/오류 대신 "AI OFF 안내"를 우선 제공한다.
- AI OFF는 기능 제거가 아니라 "실행 중지"라는 메시지를 일관되게 유지한다.

**⚠️ 참고:**
- 기술적 구현 상세는 프론트 상황 신호 수집 문서 "글로벌 헤더 AI 토글 — UX/정책 SSOT" 섹션 참조
- SSOT 스위치 정의 및 서버/Edge Function 가드 규칙은 프론트 상황 신호 수집 문서 참조

6-5. PageHeader 컴포넌트 사용 규칙 (Critical)

[불변 규칙] 모든 페이지는 PageHeader 컴포넌트를 사용하여 일관된 헤더 구조를 유지해야 합니다.

위치: `packages/ui-core/src/components/PageHeader.tsx`

기본 사용법:

```tsx
<Container maxWidth="xl" padding="lg">
  <PageHeader title="페이지 제목" />
  {/* 나머지 콘텐츠 */}
</Container>
```

Props:
- `title` (필수): 페이지 타이틀
- `actions` (선택): 타이틀 옆에 표시할 액션 버튼들
- `titleSize`: 'xl' | '2xl' | '3xl' (기본값: '3xl')
- `titleWeight`: 'bold' | 'extrabold' (기본값: 'extrabold')
- `style`: 추가 스타일 (특수 케이스용)

actions prop 사용 규칙:
- 단일 Button: 직접 전달 (PageHeader가 자동으로 감싸는 div 제공)
- 여러 요소: `<div style={{ display: 'flex', gap: 'var(--spacing-sm)' }}>`로 감싸서 전달

반응형 처리:
- 모바일 (xs, sm): 타이틀과 액션이 자동으로 줄바꿈됨
- 데스크톱 (lg, xl): 한 줄로 배치됨

특수 케이스:
- 태블릿 모드에서 특별한 폰트 크기 요구사항이 있는 경우 `style` prop 사용 가능
- 예: AttendancePage에서 태블릿 모드 제목 최소 24px 요구사항 충족

사용 예시:

```tsx
// 기본 사용 (타이틀만)
<PageHeader title="학생 관리" />

// 액션 버튼 포함 (단일 버튼)
<PageHeader
  title="강사 관리"
  actions={
    <Button variant="solid" size="sm" onClick={handleCreate}>
      강사 등록
    </Button>
  }
/>

// 액션 버튼 포함 (여러 버튼)
<PageHeader
  title="반 관리"
  actions={
    <div style={{ display: 'flex', gap: 'var(--spacing-sm)' }}>
      <Button variant="outline" size="sm" onClick={handleFilter}>
        필터
      </Button>
      <Button variant="solid" size="sm" onClick={handleCreate}>
        반 생성
      </Button>
    </div>
  }
/>
```

→ 상세 가이드라인은 `docu/컴포넌트 디자인.md`의 "PageHeader 컴포넌트 사용 가이드" 섹션을 참조하세요.

7. 성능 최적화 — Enterprise Version

7.0. React 성능 최적화 패턴

⚠️ 중요: useEffect 의존성 배열 최적화

useEffect에서 상태를 업데이트하는 경우, 의존성 배열에 해당 상태를 포함하면 불필요한 재실행이 발생할 수 있습니다.

**문제 상황**:
```typescript
useEffect(() => {
  const measure = () => {
    setShowTagListToggle(isWrapped);  // 상태 업데이트
    setIsTagListExpanded(false);      // 상태 업데이트
  };
  // ...
}, [tags, showTagListToggle, isTagListExpanded]);  // ❌ 문제: 상태가 의존성에 포함됨
```

**해결 방법: 함수형 업데이트 사용**:
```typescript
useEffect(() => {
  const measure = () => {
    // ✅ 함수형 업데이트로 이전 값과 비교하여 불필요한 상태 업데이트 방지
    setShowTagListToggle((prev) => prev !== isWrapped ? isWrapped : prev);
    setIsTagListExpanded((prev) => prev !== false ? false : prev);
  };
  // ...
}, [tags]);  // ✅ 의존성 배열에서 상태 제거
```

**규칙**:
- useEffect 내부에서 상태를 업데이트하는 경우, 함수형 업데이트를 사용
- 의존성 배열에서 업데이트되는 상태는 제거 (같은 값이면 리렌더링이 발생하지 않으므로 무한 루프 위험 없음)
- 하지만 의존성 배열에 포함하면 불필요한 재실행이 발생할 수 있으므로 제거

⚠️ 중요: useState lazy initialization 패턴

초기값 계산이 비용이 큰 경우 또는 함수 호출이 필요한 경우, lazy initialization을 사용하여 성능을 최적화합니다.

**문제 상황**:
```typescript
const getInitialTab = useCallback((): LayerMenuTab => {
  const path = location.pathname;
  // 복잡한 로직...
  return urlTab || 'info';
}, [location.pathname, urlTab]);

// ❌ 문제: 매 렌더마다 getInitialTab()이 실행됨 (초기 렌더링에서만 필요)
const [layerMenuTab, setLayerMenuTab] = useState<LayerMenuTab>(getInitialTab());
```

**해결 방법: lazy initialization 사용**:
```typescript
const getInitialTab = useCallback((): LayerMenuTab => {
  const path = location.pathname;
  // 복잡한 로직...
  return urlTab || 'info';
}, [location.pathname, urlTab]);

// ✅ lazy initialization: 초기 렌더링에서만 함수 실행
const [layerMenuTab, setLayerMenuTab] = useState<LayerMenuTab>(() => getInitialTab());
```

**규칙**:
- 초기값이 함수 호출 결과인 경우, lazy initialization 사용
- 초기값 계산이 비용이 큰 경우, lazy initialization 사용
- useState(() => ...) 패턴으로 초기 렌더링에서만 함수 실행

⚠️ 중요: 스키마 메모이제이션 패턴

동적으로 생성되는 스키마(예: createStudentFilterSchema)는 useMemo로 메모이제이션하여 중복 호출을 방지합니다.

**문제 상황**:
```typescript
// ❌ 문제: 매 렌더마다 createStudentFilterSchema가 호출됨
const { data: studentFilterSchemaData } = useSchema('student_filter', createStudentFilterSchema(classes || []), 'filter');
const effectiveFilterSchema: FilterSchema = studentFilterSchemaData || createStudentFilterSchema(classes || []);
```

**해결 방법: useMemo로 메모이제이션**:
```typescript
// ✅ 스키마를 메모이제이션하여 중복 호출 방지
const studentFilterSchema = useMemo(() => createStudentFilterSchema(classes || []), [classes]);
const { data: studentFilterSchemaData } = useSchema('student_filter', studentFilterSchema, 'filter');
const effectiveFilterSchema: FilterSchema = studentFilterSchemaData || studentFilterSchema;
```

**규칙**:
- 동적으로 생성되는 스키마는 useMemo로 메모이제이션
- 의존성 배열에 실제 의존하는 값만 포함 (예: classes)
- useSchema와 fallback에서 동일한 메모이제이션된 스키마 재사용

⚠️ 중요: 타입 안정성 패턴

React Query나 상태 관리에서 타입이 다른 데이터를 통합 처리할 때는 명시적 타입 정의가 필요합니다.

**문제 상황**:
```typescript
const riskAnalysis = newRiskAnalysis || savedRiskAnalysis;  // ❌ 타입 불일치 가능
const riskScore = riskAnalysis.risk_score;  // ❌ 타입 오류
```

**해결 방법: 타입 통합 및 null 체크**:
```typescript
// ✅ 타입 통합 처리
const riskAnalysis = (newRiskAnalysis || savedRiskAnalysis) as {
  risk_score: number;
  risk_level?: 'low' | 'medium' | 'high';
  reasons?: string[];
  recommended_actions?: string[];
  analyzed_at?: string;
  factors?: string[];
  recommendations?: string[];
} | null | undefined;

// ✅ null 체크 추가
if (!riskAnalysis || riskAnalysis.risk_score === undefined) {
  return null;
}

// ✅ 안전한 속성 접근
const riskScore = riskAnalysis.risk_score;
const reasons = riskAnalysis.reasons || riskAnalysis.factors || [];
const recommendedActions = riskAnalysis.recommended_actions || riskAnalysis.recommendations || [];
```

**규칙**:
- 타입이 다른 데이터를 통합할 때는 명시적 타입 정의 사용
- null/undefined 체크를 먼저 수행
- 옵셔널 속성은 fallback 값 제공

7.1 Performance Gates (CI/CD)

Bundle Analyzer 자동 실행

Lighthouse CI 자동 실행

예산 초과 시 빌드 실패

7.2 Runtime 최적화

SDUI memoization

Table virtualization

Suspense + concurrent features

React Query TTL/SWR

tenant 변경 시 invalidateQueries() 자동 발생

8. Error Handling & Debugging
Error Boundary Layer

Schema Validation Failure

Widget Rendering Failure

Data Fetch Error

Version Mismatch Error

각 카테고리마다 다른 UI/메시지·로그가 필요하다.

9. Testing Requirements — Hard Gate
종류	커버리지 요구	실패 시
Unit Test	80% 이상	빌드 실패
SDUI Rendering E2E	업종별 핵심 화면 100%	빌드 실패
A11Y (Axe-Core)	Critical = 0	빌드 실패
Visual Regression	주요 화면 100%	경고

9-1. Public Gateway 보안 규약 (Critical)

⚠️ 중요: Public Gateway는 로그인 없이 접근 가능한 공개 페이지이므로, Front-end 레이어에서도 보안 규칙을 따라야 합니다.

기술문서의 보안 규약과 동일한 출처를 따르며, UI 레이어에서 구현해야 하는 보안 규칙은 다음과 같습니다:

1. CSRF 방어
   - POST 요청 시 CSRF 토큰 필수
   - 토큰은 Public Gateway 토큰 검증 API에서 발급
   - 토큰 만료 시 자동 갱신 또는 재발급 UX 제공

2. X-Frame-Options / Clickjacking 방지
   - iframe 임베딩 방지 (X-Frame-Options: DENY)
   - iframe 필요 시 Content-Security-Policy: frame-ancestors 'self' 적용
   - UI에서 iframe 감지 시 경고 메시지 표시

3. 토큰 검증 UX
   - Public Gateway 토큰 유효성 검사 실패 시 명확한 에러 메시지
   - 토큰 만료 시 자동 갱신 또는 재발급 안내
   - 토큰이 없는 경우 접근 거부 메시지

4. Referrer 최소화
   - Referrer-Policy: no-referrer 적용
   - 외부 링크 클릭 시 referrer 정보 노출 방지

5. 세션/토큰 수명 관리
   - 토큰 수명 짧게 유지 (기술문서 규칙 준수)
   - 토큰 만료 전 자동 갱신 또는 경고 표시

6. 키오스크 모드 (해당 시)
   - 일정 시간 무입력 시 자동 잠금 (예: 10분, KST 기준)
   - ⚠️ 예외: UI-Local 자동(보안/레이아웃/접근성)은 "자동=실행 아님" 규칙의 예외입니다.
   - UI가 (보안 목적의) 화면 잠금을 자동 수행하는 것은 허용됩니다.
   - 잠금 해제 시 PIN/관리자 인증 UX 제공
   - 잠금 상태 시 명확한 안내 메시지

구현 예시:

```typescript
// apps/public-gateway/components/SecurePublicPage.tsx
export function SecurePublicPage({ token }: { token: string }) {
  // 1. 토큰 유효성 검사
  const { data: isValid, error } = usePublicGatewayToken(token);

  if (error || !isValid) {
    return <TokenExpiredMessage onRefresh={() => refreshToken()} />;
  }

  // 2. CSRF 토큰 발급
  const { csrfToken } = useCSRFToken(token);

  // 3. iframe 감지 및 경고
  useEffect(() => {
    if (window.self !== window.top) {
      // iframe 내부에서 실행 중
      showWarning('이 페이지는 iframe에서 실행할 수 없습니다.');
    }
  }, []);

  return (
    <form onSubmit={handleSubmit}>
      <input type="hidden" name="csrf_token" value={csrfToken} />
      {/* ... */}
    </form>
  );
}
```

→ Public Gateway 보안 규약의 상세 내용은 기술문서의 "19-8. Public Gateway/키오스크 보안" 섹션을 참조하세요.

10. Enterprise-Grade 장점 정리
항목	효과
Zero-Trust @api-sdk/core	보안 문제 원천 봉쇄
Meta-Schema Validation	UI 고장 방지
SDUI Versioning	수천 테넌트 안전 업그레이드
Custom Widget Sandbox	업종 확장 비용 최소화
Performance Gates	항상 빠른 SaaS 유지
Backoffice 분리	운영 효율 극대화
Multi-Tenant Theme Engine	브랜드 커스터마이징 비용 최소
