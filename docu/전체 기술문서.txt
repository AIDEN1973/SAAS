📘 디어쌤 Multi-Tenant SaaS 플랫폼 — 기술문서

Monorepo + Supabase + PostgreSQL + 멀티테넌트 + KST 운영 표준

## ⚠️ Automation Config First (불변 원칙)

**본 시스템에서 어떠한 자동화도 하드코딩된 조건으로 실행되지 않는다.**
**모든 자동화는 사용자 설정값(Policy / Threshold / Toggle)을 통해 활성·비활성 및 강도가 결정되며,**
**실행 여부는 서버/Edge Function이 해당 설정을 해석하여 판단한다.**

⚠️ 표현·단어·순서 변경 금지

### 기본값(Default)의 정본 정의

**기본값(Default)이란 코드 상수가 아니라 Default Policy이다.**
**모든 자동화 기능은 기본 정책(Default Policy)을 가지며,**
**이 기본 정책은 테넌트 생성 시 설정값으로 저장된다.**
**코드에 하드코딩된 기본 임계값이나 조건은 존재하지 않는다.**

**금지 패턴:**
- ❌ "값이 없으면 기본값 사용"
- ❌ "undefined면 3으로 처리"
- ❌ 코드 내부 상수 기반 조건

**정본 패턴:**
- ✅ 설정이 존재 → 사용
- ✅ 설정이 없음 → 실행하지 않음 (Fail Closed)

### 자동화의 정본 구조

자동화는 반드시 아래 3요소 조합으로만 설명한다:

1. **Trigger**: 상황 신호 또는 이벤트
2. **Policy**: 사용자 설정값 (ON/OFF, 임계값, 승인 레벨)
3. **Executor**: Server / Edge Function (정책 해석 + 실행)

❌ 프론트엔드는 판단·실행 주체가 아니다.

### 자동화 항목별 Policy 설정 표 (공통)

**⚠️ 모든 문서에 동일하게 삽입 (형태·내용 변경 금지)**

| 자동화 항목 | 사용자 설정 가능 | 하드코딩 금지 |
|------------|----------------|--------------|
| 출결 이상 감지 | 감지 기준, 카드 생성 여부 | 기준값 |
| 미납 알림 | 자동 발송 ON/OFF, 시점 | 발송 조건 |
| AI 업무 카드(TaskCard, task_type: 'ai_suggested', entity_type='student') | AI ON/OFF, 승인 필요 여부 | 서버가 정책에 따라 실행 | (StudentTaskCard는 학생용 별칭)
| 대시보드 우선순위 | 가중치 조정 | 그룹 순서 |
| 리포트 생성 | 자동 생성 여부 | 생성 주기 |

※ 상위 Policy Key는 SSOT(v2 6개)로 고정된다. 신규 자동화는 event_type 카탈로그에 추가 후 가능하며, 카탈로그에 없는 event_type은 실행/추가할 수 없다. (카탈로그에 추가 = 코드 상수 `AUTOMATION_EVENT_CATALOG`에 event_type 추가)

---

## ⚠️ Automation & AI Industry-Neutral Rule (SSOT)

본 플랫폼의 자동화 설정 및 AI 기능은 **업종(Academy/Salon/Nail 등)에 종속되지 않는다.**

### 불변 원칙
- 자동화/AI의 실행 구조는 **Core Platform 공통 로직**이다.
- 업종별 차이는 로직이 아니라 **Adapter + Schema 레이어**에서만 허용된다.
- 업종별 신규 자동화 엔진 또는 AI 엔진을 생성하는 행위는 금지된다.

### 허용 구조
```
Core Automation / AI Engine
 └─ Industry Adapter (academy | salon | nail | ...)
```

### 금지 구조
- 업종별 Automation Engine ❌
- 업종별 AI Engine ❌
- 업종별 하드코딩 조건 ❌

본 규칙은 모든 문서와 구현의 정본(SSOT)이다.

### AI Engine Architecture (SSOT)

AI 기능은 다음 2계층으로 구성된다.

1. **Core AI Engine**
- 요약, 패턴 감지, 리포트 생성, 이상 탐지
- 업종 비의존
- 모델 호출 / 프롬프트 / 결과 포맷 공통

2. **Industry Adapter**
- 업종별 데이터 매핑
- 용어 치환
- 가중치 설정
- UI Label 변환

⚠️ AI 판단 및 실행 로직은 Core Engine에만 존재한다.

### Automation Policy Schema Rule

자동화 설정(Policy)은 업종과 무관한 **중립 스키마**로 정의된다.

- Schema Key는 업종 용어를 포함하지 않는다.
- UI Label만 Industry Adapter에서 변환된다.
- tenant_settings JSON은 업종 공통 구조를 가진다.

예:
- academy: "출결 이상"
- salon: "방문 이상"
→ 내부 정책 키는 동일하다.

## ✅ 설정 저장 SSOT (Single Source of Truth)

⚠️ 모든 자동화 설정은 아래 규격을 준수합니다.

저장소 및 경로 규격
- 저장소: tenant_settings KV 구조 (key='config' row의 value JSONB)
  - tenant_settings 테이블은 (tenant_id, key, value JSONB) KV 구조입니다.
  - ⚠️ 중요: `config`는 컬럼이 아니라 key='config'인 row의 value(JSONB)입니다. `tenant_settings.auto_notification.*` 같은 top-level 컬럼 표기 금지
- 자동화 정책 경로: auto_notification.<event_type>.(enabled|channel|template_key|throttle|...)
- 코드에서 설정 읽기:
  - 서버/Edge Function: getTenantSettingByPath(supabase, tenantId, path, legacyPath?) 형식 사용
    - 예: await getTenantSettingByPath(supabase, tenantId, "auto_notification.overdue_outstanding_over_limit.enabled")
    - 시그니처: (supabase: SupabaseClient, tenantId: string, path: string, legacyPath?: string) => Promise<unknown>
    - 반환 타입: `unknown` (실제 구현 타입) → 사용 시 타입 캐스팅 필요 (예: `as boolean`, `as number`)
    - 반환 값 의미: Policy가 없으면 `null`, 있으면 직접 값 `T` 반환 (`.value` 접근 불필요)
    - 프론트엔드 Hook useTenantSettingByPath: UseQueryResult<unknown, Error> 반환 (React Query의 useQuery 반환 객체)
      - 사용 예시: const { data: enabledValue } = useTenantSettingByPath("auto_notification.overdue.enabled");
      - data 속성: T | null (Policy가 없으면 null, 있으면 직접 값 T, .value 접근 불필요)
      - 코드 위치: packages/hooks/use-config/src/useConfig.ts
    - 코드 위치: infra/supabase/functions/_shared/policy-utils.ts
    - ⚠️ **자동 검증 (구현 상태)**: `getTenantSettingByPath()` 함수는 `auto_notification.<event_type>.*` 형식의 경로를 받을 때 자동으로 event_type을 추출하여 카탈로그에 등록된 값인지 검증합니다 (Fail-Closed, 구현 확인: `infra/supabase/functions/_shared/policy-utils.ts:82`에서 `assertAutomationEventType` 호출).
  - 프론트엔드: 프론트엔드 래퍼 함수 사용 (구현 필요 시 packages/hooks/use-config 또는 유사 패키지에서 제공)
    - ⚠️ 프론트엔드에서는 직접 getTenantSettingByPath를 호출하지 않으며, React Hook 또는 API 클라이언트를 통해 접근
  - 내부 동작: 1) tenant_settings에서 tenant_id + key='config' row의 value(JSONB) 획득, 2) value(JSONB)에서 경로 추출

✅ 금지 사항
- ❌ tenant_settings.auto_notification.* 처럼 config 없이 top-level 컬럼처럼 보이는 표기 금지
- ❌ v1/v2 키를 이중 저장 금지 (legacy v1은 alias-only, 저장 경로로 사용 금지)
- ❌ 채널 코드 'kakao' 저장 금지 (SSOT-3: 저장/실행용은 'sms' | 'kakao_at'만 허용)

## ⚠️ Policy Key v2 (Purpose-Based) — SSOT (정본)

⚠️ 중요: 정본은 Policy Key v2 6개만 사용, legacy_policy_key는 UI 필터/검색용 alias

본 시스템의 자동화는 Policy Key(v2) 6개를 정본(SSOT)으로 사용한다.
- 정책 저장/권한/라우팅/설정 UI 그룹핑은 policy_key_v2만 사용한다.
- 기존 5개 Policy Key는 legacy_policy_key(alias)로만 유지한다. (런타임 SSOT 아님)
- 신규 자동화 추가는 Policy Key를 늘리는 것이 아니라 event_type(시나리오) 카탈로그에 추가로만 수행한다. (카탈로그에 추가 = 코드 상수 `AUTOMATION_EVENT_CATALOG`에 event_type 추가)
- 설정값이 없거나 enabled=false이면 자동화는 실행되지 않는다(Fail-Closed).

### Policy Key v2 (6)
1) financial_health: 재무/현금흐름/수납/매출 KPI
2) capacity_optimization: 정원/시간표/반 운영 최적화
3) customer_retention: 출결 유지/이탈 예방/리스크 케어
4) growth_marketing: 신규/성장/전환/지역 경쟁(벤치마킹)
5) safety_compliance: 안전/공지/동의/민감정보/분쟁 리스크
6) workforce_ops: 강사/직원 운영(업무량/결근/대체)

### Legacy Policy Key(v1, 기존 5개) — Alias Only
- attendance_anomaly / payment_overdue / ai_suggestion / report_generation / dashboard_priority(미사용)
- legacy_policy_key는 표시/검색/호환을 위한 메타데이터이며, 정책 저장 경로의 SSOT가 아니다.
- 동일 event_type에 대해 v2 정책과 v1 정책을 이중 저장하지 않는다(설정 중복 금지).

### 확장 규칙
- 상위 Policy Key(v2 6개)는 고정(SSOT).
- 신규 자동화는 event_type 카탈로그에 추가하고, policy_key_v2 / legacy_policy_key / level / trigger / executor / policy_path를 정의한다.
- 문서/코드에서 "표에 없는 자동화 신규 추가 불가"는 "카탈로그에 없는 event_type은 실행/추가 불가"로 해석한다.

### 코드 SSOT 위치
- ⚠️ 중요: 정본(SSOT)은 코드 상수 `AUTOMATION_EVENT_CATALOG`, 문서의 표는 그 출력물
- event_type 카탈로그 정본(SSOT)은 코드 상수 `AUTOMATION_EVENT_CATALOG`이며, 문서의 표는 그 카탈로그를 반영한 출력물이다.
  - **구현 상태**: ✅ `AUTOMATION_EVENT_CATALOG` 코드 상수 구현 완료 (2024년 구현, 파일 경로: `packages/core/core-automation/src/automation-event-catalog.ts`, `infra/supabase/functions/_shared/automation-event-catalog.ts`)
  - 코드 위치: packages/core/core-automation/src/automation-event-catalog.ts, infra/supabase/functions/_shared/automation-event-catalog.ts
- legacy_policy_key는 UI 필터/검색/호환 표기용이며, 런타임 저장/실행/권한 분기에는 사용하지 않는다.
- 설정 저장은 tenant_settings KV 구조에서 key='config' row의 value(JSONB) 경로 기반이며, 신규 항목은 auto_notification.<event_type>.<field> 형식으로 추가한다.
  - 서버/Edge Function 코드 예시: await getTenantSettingByPath(supabase, tenantId, "auto_notification.overdue_outstanding_over_limit.enabled")
  - 내부 동작: 1) tenant_settings에서 key='config' row의 value(JSONB) 획득, 2) value(JSONB)에서 경로 추출

### 책임 경계 (Responsibility Boundary)

1) tenant_settings KV: key='config' row의 value(JSONB) 내부 경로 notification.* (메시지/알림 인프라 기본 정책)
  - ⚠️ 중요: notification.* 경로는 tenant_settings 테이블의 key='config' row의 value(JSONB) 내부 경로입니다. 저장 위치는 tenant_settings(key='config').value(JSONB)입니다.
- 기본 채널, 발송 제한, fallback, provider 등 "인프라 레벨" 정책
- 자동화별 오버레이가 없을 때 사용되는 기본값

2) tenant_settings KV: key='config' row의 value(JSONB) 내부 경로 auto_notification.<event_type>.* (자동화별 정책 오버레이)
- 자동화 enable/channel/template_key 등 "event_type 단위 정책"
- 각 자동화 시나리오별 세부 설정

3) tenant_features['ai'].enabled (+ PLATFORM_AI_ENABLED)
- AI 실행/비용이 걸리는 기능의 최종 스위치 (Fail-Closed)
- 프론트는 숨김이 아니라 "표시하되 실행을 막는 방식"이 원칙

### Industry Expansion Rule (Critical)

신규 업종(Salon, Nail 등) 확장 시 다음을 금지한다:

- 신규 자동화 시스템 구축
- 신규 AI 분석 시스템 구축
- 신규 설정 UI 흐름 구축

허용되는 작업은 다음뿐이다:
- Industry Adapter 추가
- Schema Override 추가
- Label / Copy / 가중치 조정

---

⚠️ Architecture v3.3 실행 주체 분리 (정본 규칙):

**⚠️ 중요: 용어 통일 규칙 (모든 문서 공통):**

본 문서에서 "AI가 판단하여 실행한다"는 표현은 **오해를 유발할 수 있으므로** 다음으로 명확히 분리합니다:
- **AI/Rule Engine**: 판단 및 추천 생성 (서버, 실행 아님)
- **Edge Function**: 실제 실행 및 Role 검증 (서버, 실행 주체)
- **프론트엔드**: 상황 신호 수집, UI 조정, 승인 요청만 (UI는 실행하지 않음, 판단하지 않음, 권한 검증하지 않음)

**정본 표현:**
- ❌ "AI가 자동 실행한다" (오해 표현)
- ❌ "AI가 판단하고, Edge Function이 실행한다" (오해 표현, AI는 판단하지 않음)
- ✅ "서버가 AI 추천 생성하고, Edge Function이 정책 해석 후 실행한다" (정본 표현)
- ✅ "서버가 정책을 해석하여 TaskCard를 생성한다" (정본 표현, 주어 명시, StudentTaskCard는 학생용 별칭)

⚠️ Platform RBAC vs Tenant RBAC 분리 규칙 (보안 불변 규칙, 모든 문서 공통):

**meta.schema_registry는 Platform 권한(user_platform_roles)으로만 통제되어야 합니다.**
- ✅ **허용**: `user_platform_roles.role = 'super_admin'` 또는 `'developer'` 또는 `'qa'`
- ❌ **금지**: `user_tenant_roles` 기반 접근 (테넌트 권한으로는 절대 접근 불가)
- ⚠️ 중요: 이 규칙은 "한 문서의 예시"가 아니라, **전 구간 공통 SSOT 블록(= 보안 불변 규칙)**입니다.

**🔥 Critical 보안 경고 (즉시 수정 권장):**

현재 RLS.txt의 `meta.schema_registry` 정책에는 **fallback 로직**이 포함되어 있습니다:
```sql
OR (NOT (EXISTS ( SELECT 1 FROM information_schema.tables WHERE ... user_platform_roles ...)))
```

이 fallback은 `user_platform_roles` 테이블이 없을 경우 **모든 authenticated 사용자에게 접근을 허용**하는 치명적인 보안 취약점입니다.

**즉시 조치 필요:**
1. ❌ **fallback 로직 제거 필수**: `meta.schema_registry`는 무조건 `user_platform_roles` 존재 전제
2. ✅ **마이그레이션 순서 보장**: `user_platform_roles` 테이블 생성 → RLS 정책 적용 순서 필수
3. ✅ **CI Contract Test 강제**: 문서에 정의된 계약 테스트를 CI에 포함하여 보안 사고 방지
4. ⚠️ **초기 마이그레이션 환경**: 개발/스테이징 환경에서도 fallback 없이 테스트 필수

**정본 RLS 정책 (fallback 제거):**
```sql
-- ❌ 금지: fallback 로직 포함
-- OR (NOT (EXISTS ( SELECT 1 FROM information_schema.tables WHERE ... user_platform_roles ...)))

-- ✅ 정본: user_platform_roles 존재 전제
CREATE POLICY schema_registry_read ON meta.schema_registry
FOR SELECT TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM user_platform_roles
    WHERE user_id = auth.uid()
      AND role IN ('super_admin', 'developer', 'qa')
  )
);
```

**계약 테스트 체크리스트 (Contract Test, 필수):**

다음 테스트 케이스는 CI/CD 파이프라인에 포함되어야 하며, 모든 테스트가 통과해야 합니다:

| 테스트 케이스 | 기대 결과 | 설명 |
|------------|---------|------|
| `user_tenant_roles`만 가진 사용자가 `meta.schema_registry` SELECT 시도 | 403 Forbidden 또는 빈 결과셋 | ⚠️ 정본 규칙: `meta.schema_registry`는 `user_platform_roles`만 접근 가능, 테넌트 권한으로는 절대 접근 불가 |
| `user_tenant_roles`만 가진 사용자가 `meta.schema_registry` INSERT 시도 | 403 Forbidden | ⚠️ 정본 규칙: `meta.schema_registry`는 `user_platform_roles`만 접근 가능, 테넌트 권한으로는 절대 접근 불가 |
| `user_tenant_roles`만 가진 사용자가 `meta.schema_registry` UPDATE 시도 | 403 Forbidden | ⚠️ 정본 규칙: `meta.schema_registry`는 `user_platform_roles`만 접근 가능, 테넌트 권한으로는 절대 접근 불가 |
| `user_tenant_roles`만 가진 사용자가 `meta.schema_registry` DELETE 시도 | 403 Forbidden | ⚠️ 정본 규칙: `meta.schema_registry`는 `user_platform_roles`만 접근 가능, 테넌트 권한으로는 절대 접근 불가 |
| `user_platform_roles.role = 'super_admin'` 사용자가 SELECT | 성공 (데이터 반환) | Platform 권한 허용 |
| `user_platform_roles.role = 'developer'` 사용자가 SELECT | 성공 (데이터 반환) | Platform 권한 허용 |
| `user_platform_roles.role = 'qa'` 사용자가 SELECT | 성공 (데이터 반환) | Platform 권한 허용 |
| `user_platform_roles.role = 'super_admin'` 사용자가 INSERT/UPDATE/DELETE | 성공 | Platform 권한 허용 |

⚠️ 중요: 이 테스트들은 RLS 정책이 올바르게 작동하는지 검증하며, 보안 사고를 사전에 방지합니다.

**⚠️ Platform RBAC 적용 범위 (super_admin 우회 필요 테이블 목록):**

다음 테이블들은 운영/장애 대응/고객지원을 위해 `super_admin` 우회가 필요합니다:
- ✅ **persons**: Core Party 모델, 다중 테넌트 데이터 관리 필요
- ✅ **meta.schema_registry**: 플랫폼 전체 스키마 관리
- ✅ **tenant_schema_pins**: 테넌트별 스키마 핀 관리

**⚠️ notification_templates 정책 명확화:**

`notification_templates` 테이블은 **의도적으로 tenant role만으로 제한**됩니다 (super_admin 우회 없음):
- **정책 의도**: 테넌트별 템플릿은 테넌트 소유자(owner/admin)가 관리하며, 운영자 개입을 최소화
- **현재 RLS**: `user_tenant_roles` 기반 접근 제어 (owner/admin/sub_admin만 수정 가능)
- **super_admin 우회**: 없음 (의도적 제한)
- **운영 필요 시**: 별도 검토 후 정책 변경 가능하나, 현재는 의도적으로 제한됨

⚠️ 참고: RLS.txt에서 `super_admin` 우회가 없는 테이블은 의도적으로 제한된 것이며, 운영 필요 시 별도 검토가 필요합니다.

**⚠️ 프론트엔드 역할 재정의 (프론트 상황 신호 수집 문서 SSOT):**
- ✅ **상황 신호 수집** (Context Signal Collection)
- ✅ **UI 조정** (Priority 가중치, 배너 표시)
- ✅ **승인 요청** (Approval Request)
- ❌ **판단** (Judgment) - 서버/Edge Function 전담
- ❌ **실행** (Execution) - 서버/Edge Function 전담
- ❌ **권한 검증** (Authorization) - 서버/RLS 전담

**용어 통일:**
- ~~"AI Suggestion"~~ (v2.x 삭제) = TaskCard (task_type: 'ai_suggested', entity_type='student') (정본, StudentTaskCard는 학생용 별칭)
- "자동 실행" = 서버가 정책 해석 후 생성 및 실행
- "프론트 승인" = 승인 요청 (실행은 서버)

⚠️ 중요: 구현 가이드라인 (1인 개발사/소규모 팀 현실적 범위)

이 문서는 최종 목표(20,000~30,000+ 테넌트)를 기준으로 작성되었으나, 1인 개발사/소규모 팀 환경을 고려하여 현실적 범위로 구현합니다.

상용화 단계 (필수 기능 + 확장 기능):
- ✅ 기본 멀티테넌트 (RLS + tenant_id)
- ✅ 기본 인증/권한
- ✅ 기본 결제/알림뱅킹 (단일 Provider)
- ✅ 기본 Analytics (간단한 집계, Supabase Edge Function 사용)
- ⚠️ 지역 기반 통계 (기본 기능: 지역순위, 지역 평균 대비 비교, 기본 히트맵) - 상용화 단계 구현 예정 (테이블 스키마 정의 완료, core_stores/core_regions 및 analytics.daily_store_metrics/daily_region_metrics 테이블 생성 마이그레이션 필요)
- ✅ AI 분석 기능 (기본 인사이트: 상담일지 요약, 출결 이상 탐지, 기본 리포트)
- ✅ 기본 Public Gateway
- ✅ 기본 Custom Domain (수동 관리)
- ✅ 기본 모니터링
- ⚠️ Analytics 외부 워커 (Lambda/Workers) - 설계 완료, 구현 예정
- ✅ Edge Function Role 분리
- ⚠️ Custom Domain 자동화 - 운영 규칙 정의 완료, 구현 예정
- ✅ 고급 캐시 무효화
- ✅ PII 마스킹 강화
- ⚠️ 지역 기반 통계 고급 기능 (고급 히트맵, 다중 지역 비교, AI 인사이트 고도화) - 상용화 단계 구현 예정
- ⚠️ 지도 기반 매장 분포 시각화 (고급) - 상용화 단계 구현 예정
- ⚠️ 외부 검색 엔진 (Meilisearch/Algolia) - Phase 1 완료 (PostgreSQL FTS), Phase 2+ 검토 예정

선택적 구현 (실제 필요 시 도입):
- ⚠️ Multi-Region DR (외부 DB 사용 시, 난이도: 중)
  → 외부 PostgreSQL 솔루션(Neon, AWS RDS, Aurora) 기반 DR 도입
  → Supabase 단일 프로젝트에서는 불가능하므로 외부 DB 전환 필요
- ⚠️ PII AEAD 암호화 (금융인증 필요 시)
- ⚠️ KMS 키 회전 (금융인증 필요 시)
- ⚠️ 업종별 스키마 분리 (실제 데이터량 폭증 시)
- ⚠️ 이중 파티셔닝 (실제 필요 시)

초과 성장 시나리오 (현재 불필요, 1인 개발사에서는 구현 비현실적):
- ❌ Multi-Region + 샤딩 통합 구조 (난이도: 매우 높음, 초과 성장 시나리오)
- ❌ WebAuthn/Passkey (우선순위 낮음)
- ❌ Hot Tenant 수직 샤딩 (CDC 동기화, conflict 해결, routing layer, 영구 분리 정책 등 복잡도 매우 높음)
- ❌ Shard 재조정 (수십만 테넌트 규모에서만 필요)
- ❌ CDC 기반 샤딩 자동화 (운영 복잡도 매우 높음)

⚠️ 중요: 1인 개발사/소규모 팀 현실성 고려:
- 상용화 단계에서는 위의 필수 기능 + 확장 기능을 구현합니다.
- 선택적 구현은 실제 필요성이 확인된 후에만 도입합니다 (예: 금융인증 필요 시 PII 암호화, 외부 DB 전환 필요 시 Multi-Region DR).
- 초과 성장 시나리오 기능은 현재 사업 목표(2~3만 테넌트)를 넘어서는 규모에서도 대규모 팀이 필요하므로, 1인 개발사에서는 구현이 비현실적입니다.

→ 각 섹션에 "선택적 구현" 또는 "초과 성장 시나리오" 표시가 있는 경우, 상용화 단계에서는 구현하지 않습니다.

📘 PART 1
전체 아키텍처 / Monorepo / 멀티테넌트 / DB 모델

0. 목표 & 컨셉

이 플랫폼은 단일 Supabase + 단일 PostgreSQL 위에서
학원·미용실·네일샵·부동산·체육관·비영리 기관 등 여러 업종 SaaS를 동시에 운영하는 구조를 목표로 한다.

🎯 최종 목표

학원 10,000개, 부동산 10,000개, 기타 업종 수천 개

합계 20,000~30,000+ 테넌트 운영 가능한 구조

단일 코드베이스(Monorepo)에서 업종별 SaaS를 버튼처럼 생성

공통 Core Platform 모듈을 공유하면서 업종별 기능은 Industry Layer로 차별화

모바일·태블릿 완벽 대응

다크모드, UI 확대(Zoom) 기본 지원

효성FMS 알림뱅킹 연동(Payments Provider) 전 업종 공통 지원

장기적으로는 파티셔닝 → 리드 레플리카 → 샤딩까지 확장 가능한 구조

⚠️ 주의: 리전 분리는 Supabase에서 지원하지 않으므로, Multi-Region이 필요한 경우 외부 PostgreSQL 솔루션(Neon, AWS RDS, Aurora) 사용 필수

타임존 정책 (KST 표준):

모든 시간은 DB에는 UTC로 저장하되, 비즈니스 로직·표시·집계는 KST 기준으로 처리한다.

→ 상세 규칙은 PART 5 '19-1. 타임존(KST) 표준' 섹션 참조

여기서 말하는 "단일 Supabase + 단일 PostgreSQL"은 운영(prod) 환경 기준이며, dev/staging 환경은 별도 프로젝트/DB로 분리 운영하는 것을 전제로 한다.

📌 Supabase Multi-Region 제약 요약 (Critical - 즉시 수정)

⚠️ 중요: Supabase는 공식적으로 Cross-Region Read Replica / Region Failover 기능을 제공하지 않는다.

현재(2025 기준) Supabase는 단일 Region 운영만 가능하며, Replica도 동일 Region에서만 지원된다.

❌ Secondary Region = Supabase 기능이 아니다

❌ Region Failover = 불가능

❌ Replication across region = 지원 안 됨

DR/Failover를 하려면:

PostgreSQL 자체를 별도로 구축하거나

Neon/Aurora 등 외부 DB를 사용해야 한다

또는 Supabase의 단일 Region 백업/복원 기능만 사용

PITR(Point-in-Time Recovery)은 특정 시점 복원만 가능하며, table-level restore는 불가능하다.

→ Multi-Region DR이 필요한 경우 외부 PostgreSQL 솔루션(Neon, AWS RDS, Aurora) 사용 필수

⚠️ 주의: 위 제약사항과 수치는 2025년 기준이며, Supabase 기능·플랜 변경에 따라 달라질 수 있으므로 실제 설계·구현 시점에는 Supabase 최신 공식 문서를 다시 확인해야 한다.

⚠️ 중요: 우리 플랫폼의 초기~중기 단계에서는 Supabase 단일 리전 + 기본 백업만 사용하며, Multi-Region 구조를 당장 도입하지 않습니다.

→ 상용화 단계에서는 Supabase 단일 리전 운영이 기본입니다.
→ 선택적 구현: 외부 DB(Aurora/Neon) 기반 Multi-Region DR 도입 (외부 DB 전환 필요 시).
→ 초과 성장 시나리오: Multi-Region + 샤딩 통합 구조 (현재 불필요, 1인 개발사에서는 구현 비현실적).

→ 상세 DR 정책은 PART 7 '장애 복구 / 백업·복원 (DR & BCP)' 섹션 참조

1. 전체 아키텍처 개요
1-1. Monorepo 구조
.
├─ apps/                        # 최종 배포되는 프론트엔드 애플리케이션
│  ├─ academy-admin/            # 학원 관리자/선생님용
│  ├─ academy-parent/           # 학부모용
│  ├─ super-admin/              # SaaS 본사 플랫폼 콘솔
│  └─ public-gateway/           # 로그인 없이 접근하는 결제/키오스크/공개 페이지
│
├─ packages/                    # 공유 모듈
│  ├─ core/                     # 업종 공통 Core Platform Layer
│  │  ├─ core-auth/
│  │  ├─ core-tenancy/
│  │  ├─ core-billing/
│  │  ├─ core-metering/
│  │  ├─ core-notification/
│  │  ├─ core-payment/
│  │  ├─ core-config/
│  │  ├─ core-party/            # 회원/고객 공통 모델 (persons 테이블 기반)
│  │  ├─ core-community/      # 공통 게시판/댓글/공지/파일 첨부 스키마 및 API
│  │  ├─ core-storage/         # 파일 업로드/권한/폴더 구조 공통화, Supabase Storage 래핑
│  │  ├─ core-calendar/        # 일정/예약/수업 스케줄 공통 도메인
│  │  ├─ core-search/          # Full Text Search 공통 레이어 (PART 16 참조)
│  │  ├─ core-tags/            # 공통 태깅 시스템(학생 태그, 고객 태그, 매물 태그 등)
│  │  ├─ core-analytics/       # 통계 파이프라인 (PART 3의 15. Analytics & 통계 섹션 참조)
│  │  ├─ core-activity/        # Activity Feed / 타임라인 이벤트 기록
│  │  ├─ core-consultation/    # 상담/기록 관리 공통 모듈
│  │  ├─ core-reviews/             # 리뷰/평가 시스템
│  │  ├─ core-coupons/         # 쿠폰/할인 관리
│  │  ├─ core-tenancy-referral/ # B2B 추천인 코드 제도
│  │  ├─ core-events/          # 이벤트/프로모션 관리
│  │  └─ ui-core/               # UI 컴포넌트 (DataTable, TableCardView, SplitTableLayout 등)
│  │
│  ├─ schema-engine/            # SDUI Renderer + Meta-Schema + Versioning + Custom Widget Registry
│  │
│  ├─ design-system/            # Design Tokens, Theme Engine (다크모드, Zoom 지원)
│  │
│  ├─ api-sdk/                  # Zero-Trust API SDK Layer
│  │
│  └─ theme-engine/             # Theme Override Engine (테넌트별 테마 커스터마이징)
│
⚠️ 중요: UI 레이어 구조 개념 vs 실제 패키지 매핑 (모든 문서 공통):

**개념 레이어 (UI 문서 설명용):**
UI/UX 문서에서는 UI 아키텍처를 개념적으로 다음과 같이 설명합니다:
- schema-engine → core-ui → design-system → theme-engine

이는 **논리적 레이어 구조**이며, "의존성 방향"과 "책임 분리"를 설명하는 개념적 모델입니다.

**실제 패키지 구조 (개발 시 기준):**
- schema-engine: `packages/schema-engine` (독립 패키지)
- core-ui(개념 레이어): `packages/ui-core` (실제 패키지)
- design-system: `packages/design-system` (독립 패키지)
- theme-engine: `packages/design-system` 내부 또는 별도 `theme-engine` 패키지 (구현 방식에 따라)

**⚠️ 중요 규칙:**
- **개념 레이어 ≠ 디렉토리 1:1 아님**: UI 문서의 레이어 구조는 개념적 모델이며, 실제 디렉토리 구조와 1:1로 동일하지 않을 수 있습니다.
- **개발 시 기준**: 실제 Monorepo 구조(`packages/*`)를 기준으로 하되, UI 문서의 레이어 개념을 참고하여 모듈 간 의존성을 관리합니다.
- **SSOT**: 실제 패키지 경로는 R1.1(rules.md)만 정본이며, 개념 레이어는 설명용입니다.
│  │  ├─ core/                  # 공통 API SDK (tenant_id, industry_type 자동 삽입)
│  │  └─ academy/               # 업종별 확장 SDK (향후 추가)
│  │
│  ├─ payments/
│  │  └─ payment-alimbank/      # 효성FMS 알림뱅킹 Adapter
│  │
│  ├─ industry/                 # 업종별 모듈 (학원/미용/네일/부동산/체육관/비영리)
│  │  ├─ industry-academy/
│  │  ├─ industry-salon/
│  │  ├─ industry-real-estate/
│  │  ├─ industry-gym/
│  │  ├─ industry-ngo/
│  │  └─ ...
│  │
│  │  ⚠️ 업종 키 매핑 규칙 (SSOT):
│  │  - 폴더명: 하이픈 사용 (예: industry-real-estate)
│  │  - DB 키(industry_type): 언더스코어 사용 (예: real_estate)
│  │  - UI 라벨: 업종별 Adapter에서 변환
│  │  매핑 표:
│  │  | 폴더명 | DB 키(industry_type) | UI 라벨 예시 |
│  │  |--------|---------------------|-------------|
│  │  | industry-academy | academy | 학원 |
│  │  | industry-salon | salon | 미용실 |
│  │  | industry-real-estate | real_estate | 부동산 (⚠️ realestate 사용 금지) |
│  │  | industry-gym | gym | 체육관 |
│  │  | industry-ngo | ngo | 비영리 |
│  │  | industry-nail | nail | 네일샵 (⚠️ 실제 DB 제약조건 확인 필요) |
│  │
│  ├─ services/                 # DB 접근 Service Layer
│  │  ├─ attendance-service/
│  │  ├─ billing-service/
│  │  ├─ messaging-service/
│  │  ├─ student-service/
│  │  ├─ community-service/
│  │  └─ ...
│  │
│  ├─ hooks/                    # React Query 기반 Hooks
│  │  ├─ use-attendance/
│  │  ├─ use-billing/
│  │  ├─ use-notification/
│  │  ├─ use-community/
│  │  └─ ...
│  │
│  ├─ lib/                      # 공통 유틸
│  │  ├─ supabase-client/
│  │  ├─ logger/
│  │  └─ router-guards/
│  │
│  ├─ env-registry/             # 중앙 환경변수 관리 시스템 (타입 안정성 + 검증 + 환경 자동 인식)
│  │
│  └─ docs/                     # 설계 문서
│
└─ infra/
   ├─ supabase/
   │  ├─ migrations/            # DB 마이그레이션 SQL
   │  ├─ functions/             # Supabase Edge Functions
   │  │  ├─ fns-payment-alimbank-webhook/
   │  │  ├─ fns-payment-alimbank-request/
   │  │  ├─ fns-notification-dispatch/
   │  │  ├─ fns-daily-metrics-aggregation/
   │  │  └─ ...
   │  └─ policies/              # RLS/정책 SQL
   │
   ├─ scripts/                  # 운영 스크립트
   └─ .github/                  # CI/CD

2. 멀티테넌트 모델 & 용어

2-0. 테넌트 삭제 정책 (Critical)

필수 항목:

grace period (예: 30일 보관 후 삭제):

테넌트 삭제 요청 시 즉시 삭제하지 않고 30일간 보관

30일 내 복구 요청 가능

billing unpaid 케이스 처리:

미납 테넌트는 삭제하지 않고 일시 정지 상태로 전환

미납 해결 후 자동 활성화 또는 수동 승인 필요

audit/events는 보관해야 하는가 여부:

audit.events는 법적 요구사항에 따라 최소 1년 보관

테넌트 삭제 후에도 audit.events는 보관 (tenant_id로 조회 가능)

storage 파일삭제 정책:

테넌트 삭제 시 storage 파일은 즉시 삭제하지 않고 30일 보관

30일 후 자동 삭제 배치 실행

구현 예시:

```typescript
async function deleteTenant(tenantId: string) {
  // 1. 테넌트 상태를 'deleting'으로 변경
  await db.updateTenantStatus(tenantId, 'deleting');

  // 2. 삭제 예약 (30일 후)
  await db.scheduleDeletion(tenantId, new Date(Date.now() + 30 * 24 * 60 * 60 * 1000));

  // 3. Storage 파일 삭제 예약
  await scheduleStorageDeletion(tenantId, 30);

  // 4. audit.events는 보관 (삭제하지 않음)
}
```
2-1. 용어 정의
용어	설명
Platform	전체 SaaS 생성 플랫폼
Tenant(테넌트)	하나의 사업자(학원/매장/지점 1개)
Industry	업종 레이어(academy/salon/real_estate/gym/ngo 등)
User	개인 계정 (여러 테넌트에 소속 가능)
SaaS 제품	업종별 패키지(학원관리, 네일샵관리 등)
2-2. 핵심 테이블
tenants (
  id uuid PK,
  name text,
  industry_type text,
  plan text,
  status text,
  created_at timestamptz
)

users (...)

user_tenant_roles (
  user_id,
  tenant_id,
  role (owner/staff/instructor/teacher/guardian/parent ...)  -- instructor/guardian은 정본 키, teacher/parent는 backward compatibility
)

⚠️ 역할 키 SSOT (Single Source of Truth):
- 정본 역할 키: owner, staff, instructor, guardian (업종 공통)
- Backward compatibility: teacher (instructor의 alias), parent (guardian의 alias)
- 플랫폼 권한: super_admin, developer, qa (user_platform_roles 테이블)
- 테넌트 권한: owner, admin, sub_admin, instructor, assistant (user_tenant_roles 테이블)
- ⚠️ 중요: 실제 허용 역할 목록은 마이그레이션 파일의 CHECK 제약조건을 SSOT로 참조하세요.

tenant_settings (
  tenant_id,
  key,
  value jsonb
)

tenant_features (
  tenant_id,
  feature_key,
  enabled,
  quota
)

2-2-1. 스키마 단단화(데이터 무결성) (Critical)

industry_type, status, role, provider 등은 ENUM 또는 CHECK로 표준화:

-- 예시
ALTER TABLE tenants
  ADD CONSTRAINT chk_tenants_status CHECK (status IN ('active','paused','closed'));

ALTER TABLE tenants
  ADD CONSTRAINT chk_tenants_industry CHECK (industry_type IN ('academy','salon','real_estate','gym','ngo','nail'));
  -- ⚠️ 주의: 위 목록은 예시이며, 실제 허용 업종은 마이그레이션 파일의 CHECK 제약조건을 SSOT로 참조하세요.
  -- nail 업종은 문서 예시에서 자주 언급되지만, 실제 DB 제약조건에 포함 여부는 마이그레이션 파일을 확인해야 합니다.

tenant_settings.value는 JSON Schema 유효성(서버단) + 마이그레이션 시 기본값 강제

→ 데이터 무결성 보장 및 런타임 오류 방지

→ 모든 도메인 테이블은 tenant_id 필수 + 인덱스 구성

2-2-2. 매장(Store) 및 지역(Region) 모델

⚠️ 중요: 기본 매장/지역 모델과 고급 매장 관리 기능은 상용화 단계 구현 예정 (테이블 스키마 정의 완료, core_stores/core_regions 테이블 생성 마이그레이션 필요).

상용화 단계 기본 구조:
- core_stores 테이블 (기본 매장 정보)
- core_regions 테이블 (지역 마스터 데이터)
- 매장 ↔ 지역 매핑 (지역 통계용)

상용화 단계 고급 기능:
- 다중 매장 관리
- 매장별 세부 설정
- 매장별 권한 관리

지역 계층 테이블 (Core Layer 공통):

CREATE TABLE core_regions (
  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  level           text NOT NULL CHECK (level IN ('dong', 'gu_gun', 'si', 'nation')), -- 동/읍/면, 구/군, 시/도, 전국
  code            text NOT NULL,    -- 행정안전부 행정구역 코드 등
  name_ko         text NOT NULL,
  parent_id       uuid NULL REFERENCES core_regions(id),
  created_at      timestamptz NOT NULL DEFAULT now()
);

CREATE UNIQUE INDEX ux_core_regions_level_code
  ON core_regions(level, code);

CREATE INDEX idx_core_regions_parent ON core_regions(parent_id);

매장(Store) 테이블:

CREATE TABLE core_stores (
  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id       uuid NOT NULL REFERENCES tenants(id),
  name            text NOT NULL,
  industry_type   text NOT NULL,    -- tenants.industry_type과 동일
  region_id       uuid NOT NULL REFERENCES core_regions(id),  -- 매장이 속한 기준 지역(보통 동/읍/면)
  latitude        double precision,  -- 지도 렌더링용 위도 (WGS84)
  longitude       double precision, -- 지도 렌더링용 경도 (WGS84)
  address         text,
  phone           text,
  status          text NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'paused', 'closed')),
  created_at      timestamptz NOT NULL DEFAULT now(),
  updated_at      timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX idx_core_stores_tenant ON core_stores(tenant_id);
CREATE INDEX idx_core_stores_region ON core_stores(region_id);
CREATE INDEX idx_core_stores_industry_region ON core_stores(industry_type, region_id);

ALTER TABLE core_stores ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation_core_stores ON core_stores
FOR ALL TO authenticated
USING (
  tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
)
WITH CHECK (
  tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
);

⚠️ 중요: PgBouncer Transaction Pooling을 사용하는 경우, JWT claim 기반 RLS를 사용해야 합니다. set_config 기반 RLS는 Session Pooling 또는 전용 커넥션 전용입니다.

→ Region은 Core Layer의 공통 차원(Dimension)이고, Industry Layer(학원, 부동산 등)는 이 Region을 그대로 공용으로 사용합니다.

→ 상용화 단계에서 기본 매장/지역 모델과 고급 매장 관리 기능을 모두 구현 예정 (테이블 스키마 정의 완료, core_stores/core_regions 테이블 생성 마이그레이션 필요).

3. Supabase 구조 & 원칙
3-1. 단일 프로젝트 전략

Supabase 프로젝트는 환경별로 분리하며, 특히 prod는 dev/staging과 완전히 다른 프로젝트/DB를 사용한다.

이 문서의 "단일 PostgreSQL"은 운영(prod) 환경 내 멀티테넌트를 의미한다.

모든 업종 SaaS 테넌트는 운영(prod) 환경의 단일 PostgreSQL에 저장

원칙적으로는 모든 테넌트가 단일 PostgreSQL 인스턴스에 공존하며, 특정 Hot Tenant가 전체 부하에 심각한 영향을 주는 경우에 한해 예외적으로 해당 테넌트만 별도 샤드(분리 DB)로 수직 분리할 수 있다.

RLS + tenant_id + app.current_tenant_id 조합으로 완전 격리

⚠️ 중요: 테넌트별 테이블 생성 구조가 아님

이 플랫폼은 "테넌트마다 스키마/테이블을 새로 만드는 구조"가 아닙니다.

기본 구조:
- public 스키마 + tenant_id + industry_type 컬럼 (표준)
- 파티셔닝은 시간 기준(RANGE, occurred_at)
- 업종별 테이블은 "필요할 때만" academy_*, salon_* 같은 소수의 prefix 테이블

즉, 테넌트 3만 개가 생겨도:
- "테이블 개수"는 그대로 (또는 월/연 파티션만 시간에 따라 증가)
- "행(row) 수"만 늘어나는 구조

선택적 구현에서 말하는 "업종별 스키마 분리"도 industry 단위지, tenant 단위가 아닙니다.

→ "사스 하나 생길 때마다 DB 테이블 잔뜩 늘어나는 구조는 아니다"로 이해하면 됩니다.
→ 테이블 폭증은 "월별 파티션 수 × 로그성 테이블 수" 정도라서, 운영 설계로 컨트롤 가능합니다.

3-1-1. Supabase 단일 프로젝트 확장성 및 병목 대응 전략 (Critical)

⚠️ 중요: 20,000~30,000 테넌트를 단일 Supabase 프로젝트에서 운영하려면 반드시 다음 전략이 필요합니다.

DB 연결 수 & 풀링 전략:

[불변 규칙] Supabase는 플랜/컴퓨트 스펙별로 DB 연결 수가 제한되어 있으므로, PgBouncer(커넥션 풀러) 사용을 전제로 합니다.

연결 수 제한 (예시, 실제는 Supabase 최신 문서 확인 필요):
- Free/Pro 플랜: 제한적 연결 수
- Enterprise: 더 많은 연결 수 제공

PgBouncer 풀링 모드:
- Transaction Pooling (권장): 짧은 트랜잭션에 최적화
- Session Pooling: 긴 트랜잭션 필요 시

⚠️ Critical: PgBouncer Transaction Pooling과 RLS 전략 (구조적 해결책 필수)

🚨 중요: PgBouncer Transaction Pooling 모드에서는 세션 변수(set_config)가 트랜잭션 종료 후 유지되지 않으므로, RLS는 기본적으로 JWT claim 기반으로 구현합니다.

**정본 패턴 (권장):**
- JWT claim 기반: `tenant_id = (auth.jwt() ->> 'tenant_id')::uuid`
- Transaction Pooling 호환, 성능 우수

**예외 패턴 (허용, 근거 필요):**
- auth.uid + RBAC 조인: `tenant_id IN (SELECT tenant_id FROM user_tenant_roles WHERE user_id = auth.uid())`
- 사용 조건: 복잡한 권한 매트릭스가 필요한 경우, 인덱스 최적화 필요
- ⚠️ 주의: JOIN 기반 RLS는 PgBouncer Transaction Pooling과 호환되지만, 성능 최적화(인덱스)가 필수입니다. 가능하면 JWT claim 기반을 우선 사용하세요.

[불변 규칙] PgBouncer Transaction Pooling 모드를 사용할 때는 RLS 정책이 JWT claim 기반으로 작동하도록 설계해야 합니다. set_config 기반 RLS는 Transaction Pooling과 호환되지 않습니다.

**⚠️ 현재 상태 및 마이그레이션 방향:**
- **현황**: 일부 테이블은 레거시 패턴(JOIN 기반 또는 set_config 기반) 사용 중
- **목표**: 모든 테이블을 JWT claim 기반으로 마이그레이션 (상용화 단계)
- **금지 대상**: set_config('app.current_tenant_id') 기반 RLS (Transaction Pooling과 호환 안 됨, 절대 사용 금지)
- **예외 패턴**: JOIN 기반 RLS는 인덱스 최적화 시 허용 가능하나, JWT claim 기반 권장
- **마이그레이션 우선순위**: 신규 테이블은 반드시 JWT claim 기반만 사용, 기존 테이블은 점진적 마이그레이션

문제점:
- Transaction Pooling 모드에서는 세션 레벨 SET이 트랜잭션 종료 후 유지되지 않음
- set_config('app.current_tenant_id') 기반 RLS는 Transaction Pooling에서 작동하지 않음
- RLS 정책이 잘못된 tenant_id로 평가되거나 모든 row가 차단될 위험

해결책 (구조적):

옵션 1: JWT claim 기반 RLS (권장, Supabase 기본 방식):
- Supabase JWT에 tenant_id를 claim으로 포함
- RLS 정책에서 JWT claim을 직접 읽어 tenant_id 확인
- PgBouncer Transaction Pooling과 완벽 호환

옵션 2: Session Pooling 모드 (제한적):
- PgBouncer Session Pooling 모드 사용 (커넥션 수 제한 증가)
- 세션 변수 유지 가능하나 커넥션 효율성 저하

옵션 3: 전용 커넥션 (특수 케이스):
- 특정 Edge Function만 전용 커넥션 사용 (논풀링)
- 일반적인 경우에는 권장하지 않음

📌 JWT claim 기반 RLS 구현 (권장):

1. Supabase JWT에 tenant_id 포함:
   - 사용자 인증 시 user_tenant_roles에서 tenant_id 조회
   - JWT 생성 시 claim에 tenant_id 포함

2. RLS 정책 수정:
```sql
CREATE POLICY tenant_isolation_students ON public.students
FOR ALL TO authenticated
USING (
  tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
)
WITH CHECK (
  tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
);
```

3. Service Layer에서 withTenant() 사용:
   - RLS는 보안 레이어, Service Layer는 쿼리 레이어
   - 2중 필터로 보안 강화

모니터링 전략:
- RLS 실패율 모니터링 (예상치 못한 401/403 증가 감지)
- JWT claim 누락 감지 (로그 수집)
- 테넌트 간 데이터 누수 감지 (audit 로그 분석)

🚨 [불변 규칙] PgBouncer Transaction Pooling 사용 시 set_config 기반 RLS 금지:

[불변 규칙] Supabase 환경에서는 기본적으로 PgBouncer Transaction Pooling을 사용하므로, set_config('app.current_tenant_id') 기반 RLS는 절대 사용하지 않습니다.

[불변 규칙] Transaction Pooling 모드에서는 세션 변수가 트랜잭션 종료 후 유지되지 않으므로, set_config 기반 RLS는 보안 상 안전하게 동작하지 않을 가능성이 매우 높습니다.

[불변 규칙] RLS 정책은 기본적으로 JWT claim 기반(auth.jwt() ->> 'tenant_id')을 사용합니다.

**⚠️ 레거시 참고: app.current_tenant_id (사용 금지, 참고용):**

`app.current_tenant_id`는 **Session Pooling 모드 또는 전용 커넥션 전용**이며, 현재 Supabase 환경(Transaction Pooling)에서는 **절대 사용하지 않습니다**.

**레거시 패턴 (참고용, 사용 금지):**
```sql
-- ❌ 금지: Transaction Pooling 환경에서 작동하지 않음
SELECT set_config('app.current_tenant_id', tenant_id, true);
```

**정본 패턴 (필수):**
```sql
-- ✅ 정본: JWT claim 기반
tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
```

**❌ 잘못된 패턴 (금지):**
```sql
-- ❌ 금지: 중복 괄호와 불필요한 ::text 캐스팅
tenant_id = ((auth.jwt() ->> 'tenant_id'::text))::uuid
```

**잘못된 패턴의 문제점:**
- 중복 괄호 `((...))`는 불필요하며 가독성을 해칩니다
- `'tenant_id'::text` 캐스팅은 불필요합니다 (JSON 연산자 `->>` 는 이미 text를 반환)
- 올바른 패턴: `(auth.jwt() ->> 'tenant_id')::uuid` (단일 괄호, ::text 없음)

**참고:** 일부 문서에서 `app.current_tenant_id`가 언급되어 있으나, 이는 **레거시 참고용**이며, 신규 코드는 반드시 JWT claim 기반을 사용해야 합니다.

**정본 패턴 (권장):**
- JWT claim 기반: `tenant_id = (auth.jwt() ->> 'tenant_id')::uuid`
- Transaction Pooling 호환, 성능 우수

**예외 패턴 (허용, 근거 필요):**
- auth.uid + RBAC 조인: `tenant_id IN (SELECT tenant_id FROM user_tenant_roles WHERE user_id = auth.uid())`
- 사용 조건: 복잡한 권한 매트릭스가 필요한 경우, 인덱스 최적화 필요
- 성능 고려: user_tenant_roles 테이블에 (user_id, tenant_id) 복합 인덱스 필수

⚠️ 중요: 현재 문서의 set_config 기반 RLS 예시는 Session Pooling 모드 또는 전용 커넥션을 사용하는 경우에만 유효합니다. Transaction Pooling을 사용하는 경우(기본 설정) 기본적으로 JWT claim 기반 RLS를 사용합니다.

**정본 패턴 (권장):**
- JWT claim 기반: `tenant_id = (auth.jwt() ->> 'tenant_id')::uuid`
- Transaction Pooling 호환, 성능 우수

**예외 패턴 (허용, 근거 필요):**
- auth.uid + RBAC 조인: `tenant_id IN (SELECT tenant_id FROM user_tenant_roles WHERE user_id = auth.uid())`
- 사용 조건: 복잡한 권한 매트릭스가 필요한 경우, 인덱스 최적화 필요

[불변 규칙] 긴 트랜잭션 / 통계 쿼리 / 배치 쿼리는 Primary DB에 직접 실행하지 않으며, Read Replica 또는 외부 Worker로 분리합니다.

[불변 규칙] Admin 도구(예: Metabase, Grafana)도 낮은 커넥션 소비를 위해 Read Replica를 사용하도록 설정합니다.

연결 수 모니터링:
- pg_stat_activity 모니터링
- PgBouncer 통계 수집
- 연결 수 임계값 설정 (예: 80% 도달 시 알림)

리드 레플리카(Read Replica) 전략:

[불변 규칙] 운영 트랜잭션은 Primary, 대시보드·통계·리포트는 Read Replica로 분리합니다.

트래픽 분리 전략:

Primary DB (쓰기 + 실시간 읽기):
- INSERT/UPDATE/DELETE 작업
- 실시간 조회 (학생 목록, 수납 내역 등)
- Edge Function에서의 트랜잭션 작업

Read Replica (읽기 전용):
- 대시보드 통계 쿼리
- 리포트 생성
- Analytics 집계 쿼리
- Admin 도구 쿼리

Read Replica 라우팅 예시:

// services/analytics-service.ts
import { createClient } from '@supabase/supabase-js';
import { envServer } from '@env-registry/server';

// Primary DB (쓰기용)
const supabasePrimary = createClient(
  envServer.SUPABASE_URL,
  envServer.SERVICE_ROLE_KEY,
);

// Read Replica (읽기 전용)
const supabaseReplica = createClient(
  envServer.SUPABASE_READ_REPLICA_URL,  // Read Replica URL
  envServer.SUPABASE_ANON_KEY,  // 읽기 전용이므로 ANON_KEY 사용 가능
);

// 통계 쿼리는 Read Replica 사용
export async function getDashboardStats(tenantId: string) {
  return withTenant(
    supabaseReplica
      .from('analytics.daily_store_metrics') // 정본: daily_metrics는 구버전
      .select('*')
      .order('date_kst', { ascending: false })
      .limit(30),
    tenantId,
  );
}

⚠️ 주의: Read Replica는 복제 지연(replication lag)이 있을 수 있으므로, 실시간성이 중요한 쿼리는 Primary를 사용합니다.

복제 지연 모니터링:
- pg_stat_replication 모니터링
- UI에 "최근 동기화 시각(KST)" 배지 표기

파티셔닝 전략:

[불변 규칙] 대용량 테이블은 반드시 파티셔닝을 적용합니다.

파티셔닝 대상 테이블:
- attendance_logs (로그성)
- invoice_items (거래 로그)
- notification_logs (알림 로그)
- audit_logs (감사 로그)
- analytics.events (이벤트 로그)

파티셔닝 전략:

로그성 테이블: tenant_id + 날짜(월) 기준 RANGE 파티셔닝

CREATE TABLE attendance_logs (
  id bigserial,
  tenant_id uuid NOT NULL,
  occurred_at timestamptz NOT NULL,
  ...
) PARTITION BY RANGE (occurred_at);

CREATE TABLE attendance_logs_2025_01
  PARTITION OF attendance_logs
  FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE INDEX ON attendance_logs_2025_01 (tenant_id, occurred_at DESC);

[불변 규칙] 로그성 테이블(attendance_logs, analytics.events 등)의 모든 파티션에는 반드시 (tenant_id, occurred_at DESC) 복합 인덱스가 적용되어야 합니다.

→ 파티셔닝 기준이 없으면, 5~10년 데이터가 쌓였을 때 인덱스가 비효율적이 됩니다.

파티셔닝 도입 기준 및 타이밍:

⚠️ Critical: 파티셔닝은 성능 저하가 발생하기 전에 미리 도입해야 합니다.

📌 파티셔닝 기준 수치 및 근거:

로그성 테이블 (attendance_logs, analytics.events 등):
- 도입 기준: 단일 파티션 1억 rows 또는 파티션 파일 크기 ~50GB 도달
- 근거: 로그성 테이블은 시간 기반 조회가 주 패턴이며, 인덱스 크기가 커질수록 성능 저하가 급격히 발생. 1억 rows 기준은 PostgreSQL 인덱스 효율성 임계값 근거
- 도입 타이밍: 임계값의 50~70% 도달 시점 (5천만 rows 또는 25GB 도달 시)에 미리 도입

코어 테이블 (students, invoices 등):
- 도입 기준: 테넌트 수 ≥ 5,000, 총 rows ≥ 5천만 또는 테이블 크기 ≥ 200GB 시 industry_type 기반 파티셔닝 검토
- 근거: 코어 테이블은 로그성 테이블보다 조회 패턴이 다양하고, tenant_id + industry_type 복합 인덱스로 인해 인덱스 크기가 더 크게 증가. 200GB 기준은 코어 테이블의 복잡한 인덱스 구조를 고려한 수치
- 도입 타이밍: 임계값의 50~70% 도달 시점에 미리 도입

→ 파티셔닝 도입은 "성능 문제 해결"이 아니라 "성능 문제 예방" 목적입니다.

Supabase 쿼터 / 제한:

⚠️ 중요: Supabase는 "서버리스처럼 무한정 쓴다"는 착각을 하면 안 됩니다. 플랜별 제한이 있습니다.

주요 제한 사항 (예시, 실제는 Supabase 최신 문서 확인 필요):

함수 실행 수:
- Free: 제한적
- Pro: 월간 실행 수 제한
- Enterprise: 더 높은 제한

스토리지:
- 파일 저장 용량 제한
- 대용량 파일 업로드 시 주의

네트워크 전송량:
- 월간 전송량 제한
- 대용량 리포트 다운로드 시 주의

DB 크기:
- 플랜별 최대 DB 크기 제한
- 파티셔닝으로 오래된 데이터 아카이빙 필요

모니터링 전략:
- Supabase Dashboard에서 사용량 모니터링
- 쿼터 임계값 설정 (예: 80% 도달 시 알림)
- 상용화 단계에서 플랜 업그레이드 구현 예정

→ 상세 제약사항은 Supabase 최신 공식 문서를 반드시 확인해야 합니다.

3-2. 멀티테넌트 & RLS 설계 원칙 (Critical)

⚠️ 중요: 이 섹션은 멀티테넌트 구조의 핵심 설계 원칙을 명시합니다.

3-2-1. tenant_id 전략 및 PK 설계

[불변 규칙] 모든 비즈니스 테이블은 tenant_id를 필수 컬럼으로 포함합니다.

[불변 규칙] PK 설계는 bigserial id + tenant_id 조합을 사용합니다. (tenant_id, local_id) 복합키는 사용하지 않습니다.

PK 설계 원칙:

✅ 권장 패턴 (표준):
-- ⚠️ 레거시: students 테이블은 레거시이며, 신규 코드에서는 사용 금지
-- 정본 엔티티 모델: persons 테이블 (Core Party) + academy_students 테이블 (업종별 확장)
-- 신규 코드는 persons + academy_students 조합만 사용
CREATE TABLE students (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL REFERENCES tenants(id),
  name text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  ...
);

CREATE INDEX idx_students_tenant ON students(tenant_id);
CREATE INDEX idx_students_tenant_created ON students(tenant_id, created_at DESC);

❌ 금지 패턴:
-- ⚠️ 레거시 참고: students 테이블은 레거시입니다.
-- 정본 엔티티 모델: persons 테이블 (Core Party) + academy_students 테이블 (업종별 확장)
-- 신규 코드는 persons + academy_students 조합을 사용해야 합니다.
CREATE TABLE students (
  tenant_id uuid NOT NULL,
  local_id bigint NOT NULL,
  PRIMARY KEY (tenant_id, local_id),  -- 복합키 사용 금지
  ...
);

이유:
- bigserial id는 전역 유니크성을 보장하여 외부 시스템 연동 시 안전
- 복합키는 JOIN 복잡도 증가 및 외래키 참조 어려움
- 인덱스 성능 측면에서 bigserial 단일 PK가 유리

industry_type 처리 전략:

[불변 규칙] industry_type은 tenants 테이블에서 조인하여 가져오는 것을 기본으로 하며, 자주 조회되는 테이블(students, invoices 등)에는 컬럼으로 함께 저장합니다.

옵션 1 (권장): 테이블에 industry_type 컬럼 포함
-- ⚠️ 레거시 참고: students 테이블은 레거시입니다.
-- 정본 엔티티 모델: persons 테이블 (Core Party) + academy_students 테이블 (업종별 확장)
-- 신규 코드는 persons + academy_students 조합을 사용해야 합니다.
CREATE TABLE students (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL REFERENCES tenants(id),
  industry_type text NOT NULL,  -- tenants.industry_type과 동일
  name text NOT NULL,
  ...
);

옵션 2: tenant_settings에서 조인 (특수 케이스용)
-- 자주 조회되지 않는 테이블에서만 사용
SELECT s.*, t.industry_type
FROM students s
JOIN tenants t ON s.tenant_id = t.id;

→ 기본은 옵션 1이며, 옵션 2는 특수 케이스에서만 사용합니다.

3-2-2. RLS 규칙 템플릿 및 테이블 그룹 구분

[불변 규칙] RLS 정책은 테이블 그룹별로 다르게 적용합니다.

테이블 그룹 분류:

A. 완전 테넌트별 격리 테이블 (모든 비즈니스 데이터)

예: students, invoices, payments, attendance_logs, guardians, classes 등

RLS 정책 템플릿 (표준):

⚠️ 중요: PgBouncer Transaction Pooling을 사용하는 경우, 기본적으로 JWT claim 기반 RLS를 사용합니다.

**정본 패턴 (권장):**
- JWT claim 기반: `tenant_id = (auth.jwt() ->> 'tenant_id')::uuid`
- Transaction Pooling 호환, 성능 우수

**예외 패턴 (허용, 근거 필요):**
- auth.uid + RBAC 조인: `tenant_id IN (SELECT tenant_id FROM user_tenant_roles WHERE user_id = auth.uid())`
- 사용 조건: 복잡한 권한 매트릭스가 필요한 경우, 인덱스 최적화 필요

옵션 1: JWT claim 기반 RLS (권장, Transaction Pooling 호환):

ALTER TABLE public.students ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation_students ON public.students
FOR ALL TO authenticated
USING (
  tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
)
WITH CHECK (
  tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
);

→ JWT claim에서 tenant_id를 직접 읽어 RLS 정책 적용
→ PgBouncer Transaction Pooling과 완벽 호환
→ Supabase JWT 생성 시 tenant_id를 claim에 포함해야 함

⚠️ 레거시 옵션 2: 세션 변수 기반 RLS (Session Pooling 또는 전용 커넥션 전용):

ALTER TABLE public.students ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation_students ON public.students
FOR ALL TO authenticated
USING (
  tenant_id = NULLIF(current_setting('app.current_tenant_id', true), '')::uuid
)
WITH CHECK (
  tenant_id = NULLIF(current_setting('app.current_tenant_id', true), '')::uuid
);

⚠️ 레거시 예시: JWT claim 기반 RLS 사용 권장. 이 방식은 PgBouncer Transaction Pooling과 호환되지 않습니다.
→ NULLIF(current_setting(..., true), '') 패턴은 미설정 시 NULL을 반환하여 어떤 row도 통과하지 못하도록 안전 가드를 제공합니다.
→ ⚠️ 주의: 이 방식은 PgBouncer Transaction Pooling과 호환되지 않습니다. Session Pooling 또는 전용 커넥션을 사용하는 경우에만 유효합니다.

→ 쿼리층(services/*)에서는 항상 명시적 tenant_id 필터를 동시에 적용해야 합니다 (RLS는 보안 레이어, 필터링은 쿼리 레이어).

B. 전역 공통 테이블 (RLS 적용 안 함 또는 제한적 적용)

예: notification_templates, system_configs, core_regions 등

RLS 정책:
- Super Admin만 접근 가능하거나
- RLS 비활성화 (전역 공통 데이터)

예시:
ALTER TABLE notification_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY notification_templates_superadmin ON notification_templates
FOR ALL TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM user_platform_roles
    WHERE user_id = auth.uid()
    AND role = 'super_admin'
  )
);
-- ⚠️ 중요: super_admin은 user_platform_roles(플랫폼 권한)에 속하며, user_tenant_roles(테넌트 권한)가 아닙니다.
-- 위 예시는 RLS 정책 예시이며, 실제 구현은 RLS.txt 또는 마이그레이션 파일을 SSOT로 참조하세요.

C. 익명 접근 허용 테이블 (Public 데이터)

예: public_landing_pages, public_announcements 등

RLS 정책:
- SELECT는 익명 사용자도 허용
- INSERT/UPDATE/DELETE는 인증된 사용자만

예시:
CREATE POLICY public_landing_pages_read ON public_landing_pages
FOR SELECT
TO public
USING (true);  -- 모든 사용자 조회 가능

CREATE POLICY public_landing_pages_write ON public_landing_pages
FOR ALL
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM user_tenant_roles
    WHERE user_id = auth.uid()
    AND role IN ('super_admin', 'admin')
  )
);

3-2-3. Industry Layer 스키마 확장 전략

[불변 규칙] Industry Layer는 "Core Party 테이블 + 업종별 확장 테이블" 패턴을 사용합니다.

업종별로 완전 별도 테이블을 만드는 패턴은 사용하지 않습니다.

⚠️ 중요: Core Party 모델은 `core-party` 모듈에서 관리됩니다.

Core Party 테이블 (모든 업종 공통):

CREATE TABLE persons (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES tenants(id),
  name text NOT NULL,
  email text,
  phone text,
  address text,
  person_type text NOT NULL CHECK (person_type IN ('learner', 'student', 'customer', 'member', 'resident', 'donor', 'instructor', 'teacher')),  -- 업종별 의미 다름 (learner/instructor는 정본 키, student/teacher는 backward compatibility)
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

[불변 규칙] persons 테이블은 `core-party` 모듈에서 관리되며, Industry Layer는 이를 확장하여 사용합니다.

업종별 확장 테이블:

학원(academy):
CREATE TABLE academy_students (
  person_id uuid PRIMARY KEY REFERENCES persons(id),
  grade text,
  class_name text,
  school_name text,
  ...
);

CREATE TABLE academy_classes (
  id uuid PRIMARY KEY,
  tenant_id uuid NOT NULL,
  name text NOT NULL,
  ...
);

미용실(salon):
CREATE TABLE salon_customers (
  person_id uuid PRIMARY KEY REFERENCES persons(id),
  hair_type text,
  preferred_style text,
  ...
);

CREATE TABLE salon_reservations (
  id uuid PRIMARY KEY,
  tenant_id uuid NOT NULL,
  customer_id uuid REFERENCES salon_customers(person_id),
  service_id uuid,
  ...
);

부동산(real_estate):
CREATE TABLE estate_properties (
  id uuid PRIMARY KEY,
  tenant_id uuid NOT NULL,
  address text NOT NULL,
  property_type text,
  ...
);

CREATE TABLE estate_contracts (
  id uuid PRIMARY KEY,
  tenant_id uuid NOT NULL,
  property_id uuid REFERENCES estate_properties(id),
  tenant_person_id uuid REFERENCES persons(id),  -- 세입자
  ...
);

→ 업종별 확장 테이블은 Industry Layer에서 정의하며, Core Layer는 공통 persons 테이블만 제공합니다.

→ 업종이 늘어나도 테이블 수는 "업종 수 × 도메인 수"에 따라 늘어나며, 테넌트 수와는 무관합니다.

3-2-3-1. Industry Layer 확장 규범 (Critical)

⚠️ 중요: 업종별 스키마 확장 시 반드시 준수해야 하는 규칙입니다.

컬럼 확장 규칙:

Core Party 테이블 (persons)은 Core Layer에서 관리:
- Core Layer는 persons 테이블의 기본 컬럼만 제공
- Core Layer는 업종별 확장 컬럼을 추가하지 않음

업종별 확장 테이블은 Industry Layer에서 관리:
- 업종별 확장 테이블은 persons 테이블을 참조 (person_id FK)
- 업종별 확장 테이블은 업종 전용 컬럼만 포함
- 업종별 확장 테이블은 tenant_id 필수 포함

업종 공통 vs 업종 특화 구분:

업종 공통 컬럼 (Core Party 테이블):
- name, email, phone, address, person_type
- created_at, updated_at

업종 특화 컬럼 (업종별 확장 테이블):
- 학원: grade, class_name, school_name
- 미용실: hair_type, preferred_style
- 부동산: property_type, contract_type

스키마 버전 충돌 전략:

업종별 확장 테이블 추가 시:
- 마이그레이션 스크립트는 Industry Layer 패키지에 포함
- 마이그레이션 파일명: `{업종}_{테이블명}_{날짜}.sql`
- 예: `academy_students_20250115.sql`

업종 간 스키마 충돌 방지:
- 업종별 확장 테이블은 업종 prefix 사용 (academy_, salon_, estate_ 등)
- 테이블 이름 충돌 방지
- 인덱스 이름 충돌 방지 (tenant_id 인덱스는 업종별로 분리)

업종별 마이그레이션 실행 순서:
1. Core Layer 마이그레이션 (persons 테이블 변경)
2. Industry Layer 마이그레이션 (업종별 확장 테이블)
3. 데이터 마이그레이션 (기존 데이터 변환)

업종별 기본 엔티티 템플릿:

모든 업종은 다음 패턴을 따라야 함:

```sql
-- Core Party 테이블 (Core Layer)
CREATE TABLE persons (
  id uuid PRIMARY KEY,
  tenant_id uuid NOT NULL,
  name text NOT NULL,
  -- ... 공통 필드
);

-- 업종별 확장 테이블 (Industry Layer)
CREATE TABLE {업종}_{엔티티명} (
  person_id uuid PRIMARY KEY REFERENCES persons(id),
  tenant_id uuid NOT NULL,  -- 인덱스 필수
  -- ... 업종 특화 필드
);

-- 인덱스
CREATE INDEX idx_{업종}_{엔티티}_tenant ON {업종}_{엔티티명}(tenant_id);

-- RLS 정책
CREATE POLICY tenant_isolation_{업종}_{엔티티} ON {업종}_{엔티티명}
FOR ALL TO authenticated
USING (tenant_id = (auth.jwt() -> 'tenant_id')::uuid)
WITH CHECK (tenant_id = (auth.jwt() -> 'tenant_id')::uuid);
```

→ 이 템플릿을 따라야 업종 간 일관성 유지 및 확장 용이

3-2-4. Soft vs Hard Isolation 수준

현재 구조: Soft Isolation (공용 DB + RLS)

[불변 규칙] 현재 구조는 Soft Isolation(공용 DB + RLS)을 사용하며, 모든 테넌트가 단일 PostgreSQL 인스턴스에 공존합니다.

📌 Isolation 전략 구분 (Critical):

| Isolation 수준 | 적용 범위 | 설명 | Phase |
|----------------|----------|------|-------|
| **Soft Isolation** | 모든 테넌트 | 공용 DB + RLS + tenant_id 논리적 격리 | 상용화 단계 기본 |
| **업종별 분리** | 업종 단위 | industry_type 파티셔닝 → prefix 테이블 → 스키마 분리 | 선택적 구현 (실제 필요 시) |
| **Hot Tenant 분리** | 특정 테넌트 단위 | 특정 tenant_id만 별도 DB로 수직 분리 | 초과 성장 시나리오 (현재 불필요) |
| **Hard Isolation** | 전체 구조 변경 | 테넌트 단위 DB 분리, Multi-Region | 초과 성장 시나리오 (현재 불필요) |

⚠️ 중요: 이 4가지 전략은 서로 다른 목적과 범위를 가지며, 혼동하지 않도록 명확히 구분해야 합니다.

Soft Isolation 특징:
- 모든 테넌트가 동일 DB/스키마 공유
- RLS + tenant_id로 논리적 격리
- 테넌트 수 증가 시 행(row) 수만 증가, 테이블 구조는 동일
- 운영 비용 효율적, 관리 단순
- **적용 범위**: 상용화 단계 기본 구조, 2~3만 테넌트까지 충분

업종별 분리 (업종 단위 Isolation):
- **목적**: 특정 업종의 데이터량/조회량이 폭증할 때 해당 업종만 분리
- **방식**: industry_type 파티셔닝 → prefix 테이블 → 스키마 분리 (Migration Roadmap 참조)
- **적용 범위**: 선택적 구현 (실제 필요 시), 업종 단위로 선택적 적용
- **예시**: academy 업종만 academy.students 스키마로 분리

Hot Tenant 분리 (테넌트 단위 Isolation):
- **목적**: 특정 테넌트의 트래픽/데이터량이 전체 DB 성능에 영향을 줄 때 해당 테넌트만 분리
- **방식**: 특정 tenant_id 데이터를 별도 PostgreSQL 인스턴스로 수직 분리 (수동)
- **적용 범위**: 초과 성장 시나리오 (현재 불필요), 테넌트 단위로 선택적 적용
- **예시**: 대형 학원 체인(단일 테넌트)만 별도 DB로 분리

Hard Isolation 로드맵 (초과 성장 시나리오, 현재 불필요):

⚠️ 중요: Hard Isolation은 수십만 테넌트 규모에서만 검토하는 옵션이며, 1인 개발사에서는 구현이 비현실적입니다.

Hard Isolation 옵션:

옵션 1: 테넌트 단위 DB 분리 (수동)
- 특정 Hot Tenant만 별도 PostgreSQL 인스턴스로 분리
- CDC(Change Data Capture) 기반 동기화
- 운영 복잡도 매우 높음

옵션 2: 프로젝트 단위 분리 (Supabase Multi-Project)
- Supabase는 공식적으로 Multi-Project 자동화를 지원하지 않음
- 수동으로 프로젝트 생성/관리 필요

옵션 3: 외부 DB 솔루션 (Neon, AWS RDS, Aurora)
- Multi-Region 지원 필요 시
- Supabase 제약을 벗어나야 할 때

→ 상용화 단계에서는 Soft Isolation만 사용하며, Hard Isolation은 초과 성장 시나리오(수십만 테넌트)에서도 대규모 팀이 필요하므로 현재 불필요합니다.

→ 실제 2~3만 테넌트 수준에서는 Soft Isolation + 파티셔닝 + Read Replica만으로 충분합니다.

⚠️ 중요: 멀티테넌트/RLS 구조 안전성

이 조합(tenant_id NOT NULL + INDEX + RLS + 서비스 레이어 2중 필터)은 Supabase + PostgreSQL 멀티테넌트에서 거의 표준에 가까운 패턴으로, 보안/성능 관점에서 구조적으로 안전합니다.

다만, 개발팀에 계속 강조해야 할 사항:
- 쿼리에서 tenant_id 조건 빠지면 "동작은 하지만 느려지는" 케이스 → 모니터링 필요
- 특히 attendance_logs, analytics.events 같이 파티셔닝된 테이블은 tenant_id, occurred_at 인덱스 패턴을 반드시 지켜야 함


Edge Function에서 tenant_id 설정:

⚠️ 중요: PgBouncer Transaction Pooling을 사용하는 경우, set_config는 작동하지 않으므로 JWT claim 기반 RLS를 사용해야 합니다.

옵션 1: JWT claim 기반 (권장):
- Supabase JWT 생성 시 tenant_id를 claim에 포함
- RLS 정책에서 auth.jwt() ->> 'tenant_id'로 읽기
- Edge Function에서 별도 설정 불필요

옵션 2: 세션 변수 기반 (Session Pooling 또는 전용 커넥션 전용) - ⚠️ Deprecated:

🚨 [불변 규칙] set_config('app.current_tenant_id')는 RLS 정책에서 직접 사용해서는 안 됩니다.

⚠️ 중요: RLS 패턴 SSOT (정본 규칙, 확정)

**정본 패턴 (안 A, 확정): JWT claim 기반 `auth.jwt() ->> 'tenant_id'`**

- ✅ **정본**: 모든 일반 테이블은 JWT claim 기반 `auth.jwt() ->> 'tenant_id'` 사용 (Transaction Pooling 호환)
- ✅ **장점**: "현재 선택된 테넌트" 격리가 확실, Zero-Trust 원칙과 일관성
- ⚠️ **요구사항**: 테넌트 전환 시 토큰 재발급/갱신 플로우까지 SSOT로 고정 필요 (아래 참조)

**테넌트 전환 플로우 (SSOT):**
1. 사용자가 테넌트 선택 UI에서 테넌트 변경
2. 프론트엔드: `@api-sdk/core`의 `switchTenant(tenantId)` 호출
3. 서버/Edge Function: 새로운 JWT 토큰 발급 (tenant_id claim 포함)
4. 프론트엔드: 새 토큰으로 모든 후속 요청 수행

**🔥 Critical: RLS tenant 판별 방식 혼재 문제 (즉시 수정 권장):**

**현재 RLS.txt 상태 (마이그레이션 진행 중):**

현재 RLS.txt에는 두 패턴이 혼재되어 있습니다:
- ✅ **JWT claim 기반 (정본)**: `attendance_logs`, `automation_actions`, `automation_undo_logs`, `automation_safety_state`, `ai_decision_logs`, `tags`, `tag_assignments`, `tenant_features` 등
- ⚠️ **레거시 패턴 (마이그레이션 대상)**: `academy_classes`, `academy_students`, `academy_teachers`, `ai_insights`, `persons` 등은 `user_tenant_roles` 조인 기반

**문제점:**
1. **성능 저하**: `user_tenant_roles` 조인은 매 쿼리마다 서브쿼리 실행 → 인덱스 최적화 필요
2. **보안 위험**: PgBouncer Transaction Pooling 환경에서 일관성 문제 발생 가능
3. **예측 불가능성**: 향후 PgBouncer 설정 변경 시 일부 테이블만 접근 불가/허용되는 비정상 상태 발생 가능

**조치 권장:**
- **A그룹 (일반 비즈니스 테이블)**: JWT claim 기반으로 단일화 (`tenant_id = (auth.jwt() ->> 'tenant_id')::uuid`)
- **B그룹 (복잡 권한 테이블)**: 조인 허용 + 명시적 문서화 (예: `user_tenant_roles` 자체는 조인 필요)
- **혼재 금지**: 문서/코드 SSOT 위반, 마이그레이션 계획 수립 필수

**마이그레이션 우선순위:**
1. **P0 (즉시)**: `persons`, `academy_students`, `academy_teachers` (Core Party 모델, 모든 업종 기반)
2. **P1 (상용화 단계 전)**: `academy_classes`, `ai_insights` (비즈니스 로직 핵심)
3. **P2 (상용화 단계)**: 나머지 레거시 테이블

**마이그레이션 계획:**
- 신규 테이블/정책: 반드시 JWT claim 기반만 사용
- 기존 테이블: 점진적으로 JWT claim 기반으로 마이그레이션 예정 (상용화 단계)
- ⚠️ 현재 상태: 문서 SSOT는 JWT claim 기반이지만, 일부 테이블은 아직 레거시 패턴 사용 중

⚠️ 중요: 이 방식은 Supabase 환경에서 기본적으로 사용하는 PgBouncer Transaction Pooling과 호환되지 않으므로, 절대 사용하지 않습니다.

**⚠️ 레거시/예외 케이스 (Session Pooling 또는 전용 커넥션 전용, 상용화 단계에서는 사용 금지):**

아래 패턴은 Transaction Pooling과 호환되지 않으므로, 상용화 단계에서는 절대 사용하지 않습니다.

```sql
-- ⚠️ 레거시 예시: Transaction Pooling에서는 작동하지 않음, JWT claim 기반 RLS 사용 권장
-- ❌ 금지: RLS 정책에서 직접 사용하는 경우 (상용화 단계 사용 금지)
SELECT set_config('app.current_tenant_id', tenant_id, true);
```

⚠️ 참고: 이 패턴은 Session Pooling 또는 전용 커넥션 환경에서만 예외적으로 사용 가능하며, Supabase 기본 환경(Transaction Pooling)에서는 작동하지 않습니다.

✅ **정본**: JWT claim 기반 RLS를 사용하세요 (옵션 1 참조)

3-3. 스키마 분리

기본 구조: public 스키마 + industry_type 컬럼으로 관리 (표준)

모든 도메인 테이블은 public 스키마에 저장되며, industry_type 컬럼으로 업종을 구분한다.

스키마	역할
public	대부분의 도메인 (기본 패턴)
analytics	집계/통계
meta	배치/마이그레이션 관리
audit	감사 로그 (조회 포함)

업종별 데이터 분리 전략 (계층적 확장):

📌 상위 원칙 (철학적 통일성):

[불변 규칙] 기본 철학은 "단일 테이블 + industry_type 컬럼 + Soft Isolation"이며, 모든 확장 전략은 이 기본 구조를 유지하면서 선택적으로 분리하는 방식입니다.

핵심 원칙:
1. 기본 구조: 모든 업종이 public 스키마의 동일 테이블에 공존 (industry_type 컬럼으로 구분)
2. 확장 전략: 특정 업종의 데이터량/조회량이 폭증할 때만 해당 업종을 선택적으로 분리
3. 분리 범위: 전체 구조를 변경하지 않고, 필요한 업종만 선택적으로 분리
4. 일관성 유지: 분리된 업종도 동일한 스키마 구조와 비즈니스 로직을 유지

⚠️ 중요: 업종별 데이터 분리는 3가지 모델이 있으나, 도입 순서와 조건이 명확히 구분되어야 합니다.

📌 Migration Roadmap (업종별 데이터 분리 전략) - 통합 전환 기준표:

| 단계 | 분리 방식 | 전환 기준 (명확한 수치) | 설명 |
|------|----------|----------------------|------|
| 상용화 단계 | industry_type 컬럼 단일 테이블 | 테넌트 수 < 5,000<br>테이블 크기 < 50GB<br>단일 업종 row 수 < 1천만 | 기본 구조. 모든 업종이 public 스키마의 동일 테이블에 공존 |
| 상용화 단계 | industry_type 기반 파티셔닝 | 특정 업종 row 수 ≥ 1천만<br>또는 특정 업종 테이블 크기 ≥ 50GB<br>또는 특정 업종 QPS가 전체의 30% 초과 | SELECT 경로 차별화 용도. 예: `students_academy PARTITION OF students FOR VALUES IN ('academy')` |
| 상용화 단계 | 업종별 prefix 테이블 (선택적) | 업종 전용 도메인 테이블 필요 시<br>(Core Party 테이블과는 별개) | 업종 전용 도메인 테이블만. 예: `academy_classes`, `salon_customers` (Core Party 테이블과는 별개) |
| 선택적 구현 | 업종별 스키마 분리 | 테넌트 수 ≥ 20k<br>또는 Core 테이블(students/invoices) 단일 파티션 ≥ 200GB<br>또는 특정 업종 조회량이 전체의 50% 초과 | 조회량 편중 시. 예: `academy.students`, `salon.customers` |

📌 전환 기준 상세 설명:

1. **테넌트 수 기준**: 전체 테넌트 수가 증가하면 업종별 분리 필요성 증가
2. **테이블 크기 기준**: 단일 테이블 또는 파티션이 50GB(파티셔닝) 또는 200GB(스키마 분리) 도달 시 성능 저하
3. **Row 수 기준**: 특정 업종의 row 수가 1천만 이상이면 파티셔닝 검토
4. **트래픽 기준**: 특정 업종의 QPS가 전체의 30% 초과 시 파티셔닝, 50% 초과 시 스키마 분리 검토
5. **업종별 데이터 증가 속도**: 월간 증가율이 10% 이상 지속되면 조기 전환 검토

⚠️ 중요: 위 기준 중 하나라도 도달하면 해당 업종만 선택적으로 분리합니다. 전체 구조를 변경하지 않고 필요한 업종만 분리하는 것이 핵심 원칙입니다.

⚠️ 중요: 업종별 스키마 분리(academy.students)와 업종별 테이블 prefix(academy_classes)는 서로 다른 전략이며, 둘 중 하나만 선택합니다. 둘을 동시에 사용하지 않습니다.

기본 원칙:
- 기본은 public 스키마 + industry_type 컬럼
- 확장은 파티셔닝 → prefix 테이블 → 스키마 분리 순서로 검토
- 업종별 스키마 분리는 "특수 케이스(초대규모)"에만 제한적으로 사용
- ⚠️ 중요: "3만 테넌트까지 괜찮다"는 것은 Soft Isolation 구조를 유지할 수 있다는 의미이며, 업종별 분리 전략(파티셔닝/prefix/스키마 분리)은 3만 테넌트 이전에도 필요할 수 있습니다. 업종별 데이터량/조회량이 폭증하면 해당 업종만 선택적으로 분리합니다.

3-4. 중앙 환경변수 관리 시스템 (Critical)

⚠️ 중요: 모든 환경변수는 packages/env-registry를 통해서만 접근해야 하며, process.env 직접 접근은 금지됩니다.

3-4-1. 구조 및 위치

packages/env-registry/

├─ src/
│  ├─ index.ts                 # 진입점 (server/client/common export)
│  ├─ server.ts                # 🔵 서버/Edge 전용 (Node + Edge + Supabase용)
│  ├─ client.ts                # 🔵 클라이언트 전용 (React/Next.js 클라이언트용)
│  ├─ common.ts                # 🔵 서버/클라이언트 공통 (앱명, 버전정보 등)
│  ├─ schema.ts                 # Zod 기반 환경변수 스키마 정의
│  └─ resolve.ts               # Vercel/Supabase 환경변수 로딩 로직 (Edge/App/Node 환경 자동 인식)
├─ .env.example                # 환경변수 예시 파일 (실제 키 제외)
└─ package.json

⚠️ 중요: 환경변수 파일 위치
- 프로젝트 루트 디렉토리: .env.local (로컬 개발용, gitignore, 중앙 관리)
- packages/env-registry/.env.example: 예시 파일만 (실제 키 제외)
- 모든 앱과 패키지는 루트의 .env.local 파일을 공유하며, packages/env-registry/src/server.ts에서 dotenv로 자동 로드됨

3단계 분리 구조:
- 🔵 server-env: 모든 SECRET 변수 포함 (SERVICE_ROLE_KEY, webhook secret 등)
- 🔵 client-env: NEXT_PUBLIC_*로 시작하는 변수만 (절대 Service Role Key 포함 X)
- 🔵 common-env: 서버/클라이언트 공통 (industry_mode, 앱명, 버전정보 등)

특징:
- 유효성 검증(Zod): Missing 변수 에러 즉시 표시
- Edge / App / Node 환경 자동 인식
- 서버/클라이언트/공통 3단계 분리: 비밀 값이 클라이언트 번들에 포함되지 않도록 보호
- Cursor가 .env 직접 접근할 일 없음
- 타입 안정성 보장

3-4-2. 핵심 원칙

[불변 규칙] 서버/Edge/Node 코드(services/*, Edge Functions, Server Components)는 process.env를 직접 사용하지 않고 반드시 packages/env-registry에서 export된 envServer 객체를 사용해야 합니다.

[불변 규칙] React 클라이언트 코드에서는 @env-registry/server import는 금지이고, @env-registry/client, envClient/envCommon만 사용합니다. Service Role Key가 포함된 envServer는 절대 클라이언트 번들에 들어가면 안 됩니다.

[불변 규칙] 환경변수는 애플리케이션 시작 시 한 번만 검증되며, 누락되거나 잘못된 값이 있으면 즉시 에러를 발생시켜야 합니다.

[불변 규칙] 민감한 정보(Service Role Key, Webhook Secret 등)는 타입 안정성을 보장하면서도 런타임에만 접근 가능하도록 설계해야 합니다.

[불변 규칙] Edge/App/Node 환경은 자동으로 인식되며, 각 환경에 맞는 환경변수 로딩 전략을 사용합니다.

[불변 규칙] envServer는 서버/Edge 전용이며, 클라이언트 번들에 포함되면 안 됩니다. ESLint 규칙으로 강제합니다.

3-4-3. 환경변수 스키마 정의 예시

// packages/env-registry/src/schema.ts
import { z } from 'zod';

// 서버/Edge 전용 스키마 (모든 환경변수 포함)
const envServerSchema = z.object({
  // Supabase
  SUPABASE_URL: z.string().url(),
  SUPABASE_ANON_KEY: z.string().min(1),
  SERVICE_ROLE_KEY: z.string().min(1),  // Edge Function / 서버 전용
  SUPABASE_READ_REPLICA_URL: z.string().url().optional(),  // 상용화 단계 Read Replica (읽기 전용)

  // 환경 구분
  NODE_ENV: z.enum(['development', 'staging', 'production']),

  // 결제/알림뱅킹 (상용화 단계 필수, 실제 사용 시점에 requireEnv()로 체크)
  PAYMENT_ALIMBANK_API_URL: z.string().url().optional(),
  PAYMENT_ALIMBANK_API_KEY: z.string().min(1).optional(),
  PAYMENT_WEBHOOK_SECRET: z.string().min(1).optional(),

  // 상용화 단계 (Role 분리)
  PAYMENT_WEBHOOK_ROLE_KEY: z.string().min(1).optional(),
  BILLING_BATCH_ROLE_KEY: z.string().min(1).optional(),
  ANALYTICS_ROLE_KEY: z.string().min(1).optional(),

  // Custom Domain (상용화 단계)
  CUSTOM_DOMAIN_VERIFY_SECRET: z.string().min(1).optional(),

  // 외부 워커 (상용화 단계)
  AWS_LAMBDA_ANALYTICS_FUNCTION_NAME: z.string().optional(),
  CLOUDFLARE_WORKER_ANALYTICS_URL: z.string().url().optional(),

  // Kakao Maps API (상용화 단계 지도 기능용, 서버/Edge Function 전용)
  KAKAO_REST_API_KEY: z.string().min(1).optional(),
});

// 클라이언트 전용 스키마 (NEXT_PUBLIC_* 등 빌드타임 노출 값만)
const envClientSchema = z.object({
  NEXT_PUBLIC_SUPABASE_URL: z.string().url().optional(),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1).optional(),
  NEXT_PUBLIC_KAKAO_JS_KEY: z.string().min(1).optional(),  // 상용화 단계 지도 기능용 (JavaScript SDK)
  // 클라이언트에 노출 가능한 공개 값만 포함
  // 절대 Service Role Key나 비밀 값 포함 금지
});

// 서버/Edge 전용 공통 스키마 (앱명, 버전정보 등)
// 클라이언트에서 필요한 값은 NEXT_PUBLIC_*로 envClient에 포함
const envCommonSchema = z.object({
  APP_NAME: z.string().min(1).optional(),
  APP_VERSION: z.string().min(1).optional(),
  INDUSTRY_MODE: z.enum(['academy', 'salon', 'real_estate', 'gym', 'ngo']).optional(),
  // 서버/Edge에서만 사용하는 공개 값
});

export type EnvServer = z.infer<typeof envServerSchema>;
export type EnvClient = z.infer<typeof envClientSchema>;
export type EnvCommon = z.infer<typeof envCommonSchema>;
export { envServerSchema, envClientSchema, envCommonSchema };

// packages/env-registry/src/resolve.ts
/**
 * 서버/Edge 환경별 환경변수 로딩 전략
 * - Edge Function (Supabase): Deno.env.toObject()
 * - Vercel (App/Node): process.env
 * - 로컬 개발: process.env (dotenv로 루트 디렉토리의 .env.local 파일 자동 로드)
 *
 * ⚠️ 주의: 브라우저 환경에서는 사용 불가 (resolveEnv() 호출 시 에러 발생)
 *
 * 환경변수 파일 위치:
 * - 프로젝트 루트 디렉토리: .env.local (로컬 개발용, 중앙 관리)
 * - packages/env-registry/src/server.ts에서 dotenv로 자동 로드
 */
export function resolveEnv(): Record<string, string | undefined> {
  // Edge Function 환경 감지 (Supabase Edge Functions는 Deno 런타임)
  if (typeof Deno !== 'undefined' && Deno.env) {
    const env: Record<string, string | undefined> = {};
    for (const [key, value] of Object.entries(Deno.env.toObject())) {
      env[key] = value;
    }
    return env;
  }

  // Node.js / Vercel 환경
  if (typeof process !== 'undefined' && process.env) {
    return process.env;
  }

  throw new Error(
    '환경변수 접근 불가: Edge/App/Node 환경을 감지할 수 없습니다.\n' +
    '브라우저 환경에서는 env-registry/server를 사용할 수 없습니다.\n' +
    '클라이언트 코드에서는 NEXT_PUBLIC_* 등 빌드타임 값을 직접 사용하세요.'
  );
}

// packages/env-registry/src/server.ts
import { envServerSchema, type EnvServer } from './schema';
import { resolveEnv } from './resolve';

function validateEnvServer(): EnvServer {
  const rawEnv = resolveEnv();
  const parsed = envServerSchema.safeParse(rawEnv);

  if (!parsed.success) {
    const errors = parsed.error.errors.map(e =>
      `${e.path.join('.')}: ${e.message}`
    ).join('\n');

    const missingVars = parsed.error.errors
      .filter(e => e.code === 'invalid_type' && e.received === 'undefined')
      .map(e => e.path.join('.'))
      .join(', ');

    throw new Error(
      `환경변수 검증 실패:\n${errors}\n\n` +
      (missingVars ? `누락된 필수 환경변수: ${missingVars}\n\n` : '') +
      `필수 환경변수가 누락되었거나 형식이 잘못되었습니다.\n` +
      `프로젝트 루트 디렉토리에 .env.local 파일을 생성하거나, packages/env-registry/.env.example 파일을 참고하세요.`
    );
  }

  return parsed.data;
}

// 애플리케이션 시작 시 한 번만 검증
export const envServer = validateEnvServer();

// 타입 안전한 접근
// 사용 예: envServer.SUPABASE_URL, envServer.SERVICE_ROLE_KEY

// packages/env-registry/src/client.ts
import { envClientSchema, type EnvClient } from './schema';

function validateEnvClient(): EnvClient {
  // 클라이언트 환경에서는 process.env가 빌드타임에 인라인됨
  // Next.js의 경우 NEXT_PUBLIC_*만 클라이언트 번들에 포함
  // ⚠️ 주의: 클라이언트 번들에서 process.env는 빌드 타임에만 존재하며,
  // 런타임(브라우저)에서는 이미 값이 인라인되어 있어 process.env 객체 자체는 undefined일 수 있습니다.
  if (typeof window !== 'undefined' || typeof process === 'undefined') {
    // 브라우저 환경에서는 빌드타임에 이미 값이 인라인되어 있음
    const rawEnv: Record<string, string | undefined> = {};
    if (typeof process !== 'undefined' && process.env) {
      // 빌드타임에 이미 NEXT_PUBLIC_* 값만 포함됨
      // 런타임에서는 process.env가 undefined일 수 있지만, 빌드타임에 인라인된 값은 정상 동작합니다.
      for (const key in process.env) {
        if (key.startsWith('NEXT_PUBLIC_')) {
          rawEnv[key] = process.env[key];
        }
      }
    }
    const parsed = envClientSchema.safeParse(rawEnv);
    return parsed.success ? parsed.data : ({} as EnvClient);
  }

  // 서버 사이드 렌더링 중에도 클라이언트 스키마만 사용
  const rawEnv: Record<string, string | undefined> = {};
  if (process.env) {
    for (const key in process.env) {
      if (key.startsWith('NEXT_PUBLIC_')) {
        rawEnv[key] = process.env[key];
      }
    }
  }
  const parsed = envClientSchema.safeParse(rawEnv);
  return parsed.success ? parsed.data : ({} as EnvClient);
}

export const envClient = validateEnvClient();

// packages/env-registry/src/common.ts
import { envCommonSchema, type EnvCommon } from './schema';

function validateEnvCommon(): EnvCommon {
  // 공통 환경변수는 기본적으로 서버/Edge에서 사용
  // 클라이언트에서 필요한 값은 NEXT_PUBLIC_*로 별도 노출
  const rawEnv: Record<string, string | undefined> = {};

  if (typeof process !== 'undefined' && process.env) {
    // APP_NAME, APP_VERSION, INDUSTRY_MODE 등 공개 값만
    for (const key in process.env) {
      if (['APP_NAME', 'APP_VERSION', 'INDUSTRY_MODE'].includes(key)) {
        rawEnv[key] = process.env[key];
      }
    }
  }

  const parsed = envCommonSchema.safeParse(rawEnv);
  return parsed.success ? parsed.data : ({} as EnvCommon);
}

export const envCommon = validateEnvCommon();

// packages/env-registry/src/index.ts
// 🔵 서버/Edge 전용 export (클라이언트에서 import 시 ESLint 에러)
export { envServer } from './server';
export type { EnvServer } from './schema';

// 🔵 클라이언트 전용 export
export { envClient } from './client';
export type { EnvClient } from './schema';

// 🔵 서버/Edge 전용 공통 export (클라이언트에서는 사용하지 않음)
// envCommon은 서버/Edge에서만 사용하며, 클라이언트에서 필요한 값은 NEXT_PUBLIC_*로 envClient에 포함
export { envCommon } from './common';
export type { EnvCommon } from './schema';

3-4-4. 사용 패턴

❌ 금지 (process.env 직접 접근):
const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SERVICE_ROLE_KEY!,
);

✅ 허용 (서버/Edge 코드):
import { envServer } from '@env-registry/server';

const supabase = createClient(
  envServer.SUPABASE_URL,
  envServer.SERVICE_ROLE_KEY,
);

✅ 허용 (클라이언트 코드):
// 클라이언트에서는 NEXT_PUBLIC_* 값만 직접 사용
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

// 또는 선택적으로 envClient 사용 (빌드타임 값만)
import { envClient } from '@env-registry/client';
const supabaseUrl = envClient.NEXT_PUBLIC_SUPABASE_URL;

❌ 절대 금지 (클라이언트 코드):
import { envServer } from '@env-registry/server';  // ESLint 에러 발생
// Service Role Key가 클라이언트 번들에 포함될 위험

3-4-5. 환경별 설정 관리

개발 환경:
- 프로젝트 루트 디렉토리: .env.local (로컬 개발용, gitignore, 중앙 관리)
  - 모든 앱과 패키지가 이 파일을 공유
  - packages/env-registry/src/server.ts에서 dotenv로 자동 로드
- packages/env-registry/.env.example: 예시 파일 (실제 키 제외, git 포함)

스테이징/프로덕션:
- 환경변수는 배포 플랫폼(Vercel, Supabase Secrets 등)에서 관리
- 코드에는 기본값이나 예시만 포함

⚠️ 중요:
- .env.local 파일은 프로젝트 루트 디렉토리에만 생성 (각 앱별로 생성하지 않음)
- .env.local 파일에는 실제 Service Role Key를 포함하지 않고, 개발용 테스트 키만 사용합니다.

3-4-6. Edge Function에서의 사용

Edge Function은 Supabase Secrets를 통해 환경변수를 주입받으며, 동일한 packages/env-registry 패키지를 사용합니다.

resolve.ts가 자동으로 Deno 환경을 감지하여 Deno.env.toObject()를 사용합니다.

⚠️ 주의: Edge Function 번들에 env-registry 패키지를 포함할 때 번들 사이즈와 cold start 영향이 있을 수 있습니다. 상용화 단계에서 실제 성능 측정 후 최적화를 검토합니다.

// supabase/functions/payment-webhook/index.ts
import { envServer } from '@env-registry/server';

// envServer.SERVICE_ROLE_KEY는 Supabase Secrets에서 자동 주입됨
// resolve.ts가 Deno 환경을 자동 감지하여 Deno.env에서 로드

3-4-7. Phase별 환경변수 관리

상용화 단계:
- SUPABASE_URL, SUPABASE_ANON_KEY, SERVICE_ROLE_KEY (단일)
- PAYMENT_ALIMBANK_* (결제 연동) - 스키마는 optional이지만 실제 사용 시점에 requireEnv()로 체크
- PAYMENT_WEBHOOK_SECRET

상용화 단계 (확장):
- Read Replica: SUPABASE_READ_REPLICA_URL (읽기 전용, 통계/리포트 쿼리 분리용)
- Role 분리: PAYMENT_WEBHOOK_ROLE_KEY, BILLING_BATCH_ROLE_KEY 등
- Custom Domain: CUSTOM_DOMAIN_VERIFY_SECRET
- 외부 워커: AWS_LAMBDA_*, CLOUDFLARE_WORKER_* 등
- Kakao Maps API: KAKAO_REST_API_KEY (서버/Edge Function 전용), NEXT_PUBLIC_KAKAO_JS_KEY (클라이언트 전용)

→ 상용화 단계 환경변수는 .optional()로 정의하여 누락되어도 검증 에러가 발생하지 않도록 합니다.

3-4-7-1. Optional 환경변수의 실제 사용 시점 체크 (Lazy Validation)

상용화 단계에서 알림뱅킹은 필수 기능이지만, 스키마에서는 optional로 정의하여 알림뱅킹이 활성화되지 않은 환경에서는 앱 시작 시 에러가 발생하지 않도록 합니다.

실제 payment-alimbank, analytics, custom-domain 모듈에서 사용 시점에 requireEnv() 유틸을 사용하여 강하게 체크합니다 (Lazy Validation):

// packages/payments/payment-alimbank/src/env.ts
import { envServer, type EnvServer } from '@env-registry/server';

/**
 * 환경변수가 실제로 필요한 시점에만 체크하는 유틸 (Lazy Validation)
 * 상용화 단계에서 알림뱅킹은 필수이지만, 스키마는 optional로 정의되어 있음
 *
 * 사용 패턴:
 * const secret = envServer.PAYMENT_ALIMBANK_SECRET;
 * if (!secret) throw new Error("PAYMENT_ALIMBANK_SECRET missing");
 *
 * 또는 requireEnv() 유틸 사용:
 */
export function requireEnv<K extends keyof EnvServer>(
  key: K
): NonNullable<EnvServer[K]> {
  const value = envServer[key];
  if (!value) {
    throw new Error(
      `환경변수 ${key}가 설정되어 있지 않습니다. (payment-alimbank 모듈)\n` +
      `알림뱅킹 기능을 사용하려면 이 환경변수가 필수입니다.`
    );
  }
  return value as NonNullable<EnvServer[K]>;
}

// 사용 예시
// packages/payments/payment-alimbank/src/client.ts
import { requireEnv } from './env';

const apiUrl = requireEnv('PAYMENT_ALIMBANK_API_URL');
const apiKey = requireEnv('PAYMENT_ALIMBANK_API_KEY');
const webhookSecret = requireEnv('PAYMENT_WEBHOOK_SECRET');

// 또는 직접 체크 (간단한 경우)
const secret = envServer.PAYMENT_ALIMBANK_SECRET;
if (!secret) throw new Error("PAYMENT_ALIMBANK_SECRET missing");

→ 이렇게 하면 상용화 단계에서 알림뱅킹 기능을 실제로 "사용하는 순간"에만 강하게 에러를 띄우고, 알림뱅킹이 아직 활성화되지 않은 환경에서는 그냥 그 코드를 안 타면 됩니다.

→ Payment, Analytics, Custom Domain 모듈 모두 동일한 패턴을 사용합니다.

3-4-7-2. 테넌트별 환경변수 관리 (선택적 구현, 실제 필요 시)

⚠️ 중요: 이 섹션은 선택적 구현이며, 실제 필요성이 확인된 후에만 도입합니다.

현재 구조는 "환경변수는 전역(Global)"이지만, SaaS가 커지면 "테넌트별 Secret Storage"가 필요해질 수 있습니다.

사용 사례:
- Larger SaaS 고객이 자체 PG 계약을 사용하고 싶을 때
- Industry Layer에 따라 키가 달라질 때
- 테넌트별 Custom Domain Key 관리가 필요한 경우

구조 예시:

CREATE TABLE tenant_secrets (
  tenant_id uuid NOT NULL REFERENCES tenants(id),
  secret_key text NOT NULL,  -- 예: 'payment_alimbank_api_key', 'custom_domain_verify_secret'
  secret_value text NOT NULL,  -- 암호화된 값
  encrypted_at timestamptz NOT NULL DEFAULT now(),
  key_version smallint DEFAULT 1,
  PRIMARY KEY (tenant_id, secret_key)
);

CREATE INDEX idx_tenant_secrets_tenant ON tenant_secrets(tenant_id);

ALTER TABLE tenant_secrets ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation_tenant_secrets ON tenant_secrets
FOR ALL TO authenticated
USING (
  tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
)
WITH CHECK (
  tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
);

⚠️ 중요: PgBouncer Transaction Pooling을 사용하는 경우, JWT claim 기반 RLS를 사용해야 합니다. set_config 기반 RLS는 Session Pooling 또는 전용 커넥션 전용입니다.

보안 고려사항:
- secret_value는 반드시 암호화하여 저장 (AEAD 암호화, 선택적 구현)
- KMS 기반 키 회전 지원
- 테넌트별 Secret 접근은 RLS로 격리

사용 패턴:

// packages/services/tenant-secret-service.ts
// services/tenant-secret-service.ts
import { withTenant } from '../_db';

export async function getTenantSecret(
  tenantId: string,
  secretKey: string
): Promise<string | null> {
  // RLS로 자동 필터링 + withTenant() 사용
  const { data } = await withTenant(
    supabase
      .from('tenant_secrets')
      .select('secret_value, key_version')
      .eq('secret_key', secretKey),
    tenantId
  ).single();

  if (!data) return null;

  // 복호화 후 반환
  return decryptSecret(data.secret_value, data.key_version);
}

→ 상용화 단계에서는 전역 환경변수만 사용하며, 테넌트별 Secret Storage는 선택적 구현(실제 필요 시)으로 도입합니다.

3-4-8. 보안 고려사항

[불변 규칙] Service Role Key는 프론트엔드 코드(apps/*의 Client Components)에서 절대 사용하지 않으며, Edge Function과 서버 사이드 코드에서만 사용됩니다.

[불변 규칙] envServer는 서버/Edge 전용이며, 클라이언트 번들에 포함되면 안 됩니다. ESLint 규칙으로 강제합니다.

[불변 규칙] 환경변수는 코드에 하드코딩하지 않고, 반드시 환경변수 또는 Secrets 관리 시스템을 통해 주입받아야 합니다.

[불변 규칙] .env.local 파일은 git에 커밋하지 않으며, 프로젝트 루트 디렉토리에만 생성합니다 (각 앱별로 생성하지 않음).
[불변 규칙] packages/env-registry/.env.example 파일에 예시만 포함합니다 (실제 키 제외).

3-4-8-1. ESLint 규칙 (클라이언트에서 envServer import 금지)

클라이언트 코드에서 envServer를 import하면 Service Role Key 등 비밀 값이 번들에 포함될 위험이 있습니다.

ESLint 규칙으로 강제합니다:

// .eslintrc.json (apps/* 프로젝트)
{
  "rules": {
    "no-restricted-imports": [
      "error",
      {
        "paths": [
          {
            "name": "@env-registry/server",
            "message": "클라이언트 코드에서는 @env-registry/server를 import할 수 없습니다. NEXT_PUBLIC_* 값만 직접 사용하세요."
          }
        ],
        "patterns": [
          {
            "group": ["@env-registry/server"],
            "message": "클라이언트 코드에서는 @env-registry/server를 import할 수 없습니다."
          }
        ]
      }
    ]
  }
}

→ 클라이언트 컴포넌트에서 envServer를 import하려고 하면 빌드 시점에 ESLint 에러가 발생합니다.

3-4-9. Phase별 확장 전략

상용화 단계 - 현재 방식 (A안: Monorepo 내부 패키지):
- packages/env-registry/ 사용
- Zod 기반 검증
- Edge/App/Node 환경 자동 인식
- Vercel Environment Variables + Supabase Secrets

상용화 단계 (확장 시 고려 가능한 옵션):

B안) 외부 비밀 관리 시스템 연동:
- AWS SSM Parameter Store
- AWS Secrets Manager
- HashiCorp Vault
- Doppler / Infisical / 1Password Secrets Automation
- → DearSaaS 규모가 커지면 확장성과 보안 면에서 최상

C안) Supabase Config 기반:
- Edge Function: Supabase Secrets 사용
- 프론트와 Node: Vercel Environment Variables 사용
- 중앙 Manifest에서 동기화

⚠️ 중요: 상용화 단계에서는 A안(Monorepo 내부 패키지)을 사용하며, 실제 필요성이 확인된 후 B안 또는 C안으로 확장을 검토합니다.

4. Core 데이터 모델

4-0. Profile 확장 전략 (Critical)

업종별/테넌트별로 회원가입 양식/필드 구성이 다르므로, Profile 확장 전략이 필요하다.

옵션 1: 공통 profiles + 업종별 확장 테이블

공통 profiles 테이블:
CREATE TABLE profiles (
  id uuid PRIMARY KEY,
  user_id uuid NOT NULL,
  tenant_id uuid NOT NULL,
  name text,
  email text,
  phone text,
  created_at timestamptz
);

4-0-1. Profile Schema 변경 정책 (migration 없는 schema add/remove)

업종마다 다른 profile schema 정의 전략:

migration 없는 schema add/remove 정책 명시:

JSON Schema 기반 동적 필드 추가/제거는 migration 없이 가능

테이블 컬럼 추가/제거는 반드시 migration 필요

업종별 확장 테이블:

CREATE TABLE academy_profiles (
  profile_id uuid PRIMARY KEY REFERENCES profiles(id),
  grade text,        -- 학년
  class_name text,   -- 반
  school_name text   -- 학교명
);

CREATE TABLE salon_profiles (
  profile_id uuid PRIMARY KEY REFERENCES profiles(id),
  hair_type text,      -- 모발타입
  preferred_style text -- 선호스타일
);

옵션 2: 공통 profiles + extra_fields jsonb + JSON Schema

CREATE TABLE profiles (
  id uuid PRIMARY KEY,
  user_id uuid NOT NULL,
  tenant_id uuid NOT NULL,
  name text,
  email text,
  phone text,
  extra_fields jsonb,  -- 업종별/테넌트별 확장 필드
  created_at timestamptz
);

테넌트별 폼 설정은 tenant_settings KV 구조에서 key='profile_schema' row의 value(JSONB)에 JSON Schema로 저장:

{
  "schema": {
    "type": "object",
    "properties": {
      "grade": { "type": "string" },
      "class_name": { "type": "string" }
    }
  }
}

Core는 공통 필드만 알고, 업종별/테넌트별 폼은 JSON Schema 기반 렌더링

→ 업종/테넌트별 프로필 컬럼 차이 이슈 해결

4-1. Billing/Payment 공통 스키마
invoices

tenant_id

payer_id

amount

due_date

status

industry_type

…

invoice_items

item_type

category

quantity

unit_price

description

payments

invoice_id

provider(alimbank/toss/kg 등)

paid_at

amount

status

업종별 차이는 industry 모듈에서 templating/mapping,
DB는 Core에서 공통 유지.

4-1-1. 트랜잭션 격리 수준 명시 (Critical)

금융성 도메인은 트랜잭션 격리 수준을 명확히 정의해야 함:

Billing: REPEATABLE READ

청구서 생성 시 일관성 보장 필요

중복 청구 방지

Attendance: READ COMMITTED

출결 데이터는 실시간성이 중요

낮은 격리 수준으로 성능 최적화

Payments: REPEATABLE READ (권장)

SERIALIZABLE은 PostgreSQL에서 비용이 커서 REPEATABLE READ 권장

중복 결제 방지 및 금액 정합성 보장

설정 예시:

BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- billing 작업 수행

COMMIT;

4-1-2. 멱등성 및 중복 방지 전략 (Critical)

⚠️ 중요: 멱등성 및 Duplicate 처리 상세 정책은 PART 3의 14-2-1-1 "결제/알림뱅킹 운영 정책" 섹션을 참조하세요.

멱등성 키 + 유니크 제약으로 논리적 중복 차단:

-- 청구서 멱등성 (테넌트·주기·템플릿 조합)
ALTER TABLE invoices
  ADD CONSTRAINT ux_invoice_period UNIQUE (tenant_id, period_start, period_end, template_key);

-- 결제 멱등성 (요청 단위)
ALTER TABLE payments
  ADD COLUMN idempotency_key text,
  ADD CONSTRAINT ux_payment_idem UNIQUE (tenant_id, idempotency_key);

-- Webhook 멱등성은 14-2-1-1 (audit.webhook_events) 섹션 참조

Advisory Lock 사용 (청구서 생성 시):

-- 서비스 계층에서 테넌트-주기 단위 Advisory Lock 사용
-- SELECT pg_advisory_xact_lock(hashtext(:tenant_id || :period_key));

-- 청구서 생성 전 락 획득 → 중복 생성 방지
-- 트랜잭션 종료 시 자동 해제

주의사항:

Supabase 플랜·pool 모드에 따라 트랜잭션 격리 수준 변경이 제한될 수 있으므로, 실제 prod 환경에서 지원 여부를 확인하고, 필요한 경우 DB 레벨 기본 격리 수준 또는 별도 전용 커넥션을 사용한다.

예시는 direct PG 접속 또는 전용 커넥션(논풀링) 기준이며, PgBouncer 트랜잭션 풀링일 때 SET류가 세션에 안 남는 문제가 있을 수 있다.

→ 금융성 도메인에서는 반드시 명시해야 함

4-2. 공통 도메인 예시

students, guardians, classes, attendance

members, contracts

contacts, properties

donors, donations

→ tenant_id + industry_type로 확장 지원.

4-3. Multi-Industry 공용 테이블 경쟁 위험 (Optional)

현재 구조는 industry_type + tenant_id 모델로 동작하며 매우 효율적입니다.

그러나 Core 테이블(students, invoices 등)은 여러 산업을 공유하므로 테이블이 수십~수백 GB 수준까지 커질 수 있습니다.

Industry 간 cross-traffic 영향 방지:

Core 테이블은 industry_type + tenant_id 복합 인덱스가 필수

예시:

CREATE INDEX idx_students_industry_tenant
ON students(industry_type, tenant_id, created_at DESC);


장기적으로 industry_type 단위 파티셔닝도 옵션으로 고려:

-- ⚠️ 레거시: students 테이블은 레거시이며, 신규 코드에서는 persons + academy_students 조합 사용. students 테이블 파티셔닝은 레거시 모델입니다.
-- 정본 엔티티 모델: persons 테이블 (Core Party) + academy_students 테이블 (업종별 확장)
-- 신규 코드는 persons + academy_students 조합을 사용해야 합니다.
CREATE TABLE students_academy PARTITION OF students
FOR VALUES IN ('academy');

CREATE TABLE students_salon PARTITION OF students
FOR VALUES IN ('salon');

Industry 파티션 테이블명 규칙:

Industry 파티션 테이블명은 <table>_<industry_type> 패턴을 강제한다.

예: industry_type='academy' → students_academy, industry_type='salon' → students_salon

→ industry_type 값과 partition 이름을 1:1로 맞춰야 하며, 테이블 이름을 제멋대로 짓지 않도록 규칙화


업종별 스키마 분리 도입 기준 (선택적 구현, 실제 필요 시):

⚠️ 중요: 이 섹션은 선택적 구현이며, 실제 필요성이 확인된 후에만 도입합니다.

상용화 단계에서는 industry_type 컬럼 기반 단일 public 테이블을 유지합니다.

📌 Migration Roadmap 참조: 위 "업종별 데이터 분리 전략" 섹션의 단계별 도입 조건을 따릅니다.

Core 테이블(students/invoices)이 200~300GB 이상으로 커지거나 industry_type 교착이 발생하는 경우, 업종별 분리 옵션을 도입할 수 있다.

📌 명시적 전환 기준:

다음 기준 중 하나라도 도달하면 업종별 스키마 분리 검토가 필요합니다:

- ⚠️ 레거시: students 테이블 단일 파티션 200~300GB 도달 (신규 코드에서는 persons + academy_students 조합 사용)
- invoices 테이블 100M rows 이상
- analytics.events 연간 1B rows 이상

근거:
- ⚠️ 레거시: students/invoices는 코어 테이블로 복잡한 인덱스 구조(tenant_id + industry_type + created_at 등)를 가지므로, 200~300GB 도달 시 인덱스 크기가 수십 GB에 달하여 쿼리 성능 저하가 발생 (신규 코드에서는 persons + academy_students 조합 사용)
- analytics.events는 로그성 테이블이지만 연간 1B rows는 월 파티션 기준 약 8천만 rows/월로, 단일 파티션 1억 rows 임계값에 근접
- Industry 간 cross-traffic 영향 최소화를 위한 필수 인덱스 전략

→ 업종 데이터량이 200~300GB 넘어가기 전에는 필요 없으며, "향후 파티셔닝 필요 시 도입 가능" 정도로 축소합니다.

⚠️ 중요: 업종별 스키마 분리(academy.students)와 업종별 테이블 prefix(academy_classes)는 서로 다른 전략이며, 둘 중 하나만 선택합니다. 둘을 동시에 사용하지 않습니다.

- 업종별 스키마 분리: academy.students, salon.customers (스키마 레벨 분리)
- 업종별 prefix 테이블: academy_classes, salon_customers (같은 스키마 내 prefix)

→ 기본은 industry_type 컬럼 기반 단일 테이블이며, 확장 시 파티셔닝 → prefix 테이블 → 스키마 분리 순서로 검토합니다.

5. 대규모 테넌트 확장 전략
5-1. 예상 규모

10,000 학원 × 50명 = 학생 50만

출결 로그: 연 1억 8천만 건

납부 로그: 연 600만 건

5-2. 단계별 확장
단계 1) 기본 멀티테넌트

모든 테이블 tenant_id & 인덱스

RLS 전면 적용

analytics 집계는 외부 런타임(Lambda/Cloudflare Workers) 배치로 처리

단계 2) 파티셔닝 도입 (5천~2만 테넌트 구간)

로그성 테이블 대상:

attendance_logs

activity_logs

payments

전략: 월/연 단위 RANGE 파티셔닝

✅ 기본 권장안(단일 RANGE 파티션) 예시:

CREATE TABLE attendance_logs (
  id bigserial,
  tenant_id uuid,
  ...
  occurred_at timestamptz
) PARTITION BY RANGE (occurred_at);

파티셔닝 도입 기준 (구체적 수치):

로그성 테이블: 월 파티션 권장. 단일 파티션 1억 rows 또는 파티션 파일 크기 ~50GB 도달 시 분할 검토.
- 근거: 로그성 테이블은 시간 기반 조회가 주 패턴이며, 인덱스 크기가 커질수록 성능 저하가 급격히 발생

코어 테이블(students/invoices): 테넌트 수 ≥ 5,000, 총 rows ≥ 5천만 or 테이블 크기 ≥ 200GB 시 industry_type 서브테이블(파티션) 분리 검토.
- 근거: 코어 테이블은 로그성 테이블보다 조회 패턴이 다양하고, tenant_id + industry_type 복합 인덱스로 인해 인덱스 크기가 더 크게 증가

각 파티션에 인덱스:

[불변 규칙] 모든 파티션에는 반드시 (tenant_id, occurred_at DESC) 복합 인덱스가 적용되어야 합니다.

CREATE INDEX ON attendance_logs_2025 (tenant_id, occurred_at DESC);

기본 파티셔닝 예시 (상용화 단계):

CREATE TABLE attendance_logs (
  id bigserial,
  tenant_id uuid NOT NULL,
  student_id uuid,
  occurred_at timestamptz NOT NULL,
  ...
) PARTITION BY RANGE (occurred_at);

CREATE TABLE attendance_logs_2025
  PARTITION OF attendance_logs
  FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');

[불변 규칙] 모든 파티션에는 반드시 (tenant_id, occurred_at DESC) 복합 인덱스가 적용되어야 합니다.

CREATE INDEX ON attendance_logs_2025 (tenant_id, occurred_at DESC);

→ 상용화 단계에서는 단일 RANGE 파티셔닝만 사용합니다.

코어 조회 인덱스 (필수):

CREATE INDEX IF NOT EXISTS idx_students_tenant_created
  ON public.students(tenant_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_invoices_tenant_status_due
  ON public.invoices(tenant_id, status, due_date DESC);

상용화 단계 선택 인덱스 (이름 검색 등 실운영 최적화):

학생 이름 검색이 빈번한 경우 (상용화 단계):
CREATE INDEX IF NOT EXISTS idx_students_name_pattern
  ON public.students USING btree (name text_pattern_ops)
  WHERE tenant_id IS NOT NULL;

→ text_pattern_ops는 LIKE '김%' 같은 패턴 검색에 최적화된 인덱스입니다.
→ 상용화 단계에서 실제 검색 성능 문제가 발생할 때 추가합니다.

인덱스 검증 루틴:

월 1회 pg_stat_statements 상위 50개 쿼리 분석 → 인덱스 점검 체크리스트에 반영

Autovacuum 튜닝:

attendance_logs, payments 등 write-heavy 테이블은 autovacuum_vacuum_scale_factor, autovacuum_analyze_scale_factor, freeze_min_age 파라미터를 테이블 단위로 조정해야 한다.

예시:

ALTER TABLE attendance_logs SET (
  autovacuum_vacuum_scale_factor = 0.05,
  autovacuum_analyze_scale_factor = 0.02,
  autovacuum_freeze_min_age = 50000000
);

→ 수백만 row/hour 수준의 write-heavy 테이블에서는 필수 튜닝

5-2-1. 파티션 정책 기반 생성·보존 배치 (Critical)

매월 [Policy 기반 임계값일] 03:00 KST: 다음 달 파티션 정책 해석 후 생성 (Policy 기반)
⚠️ 중요: 월말 임계값은 Policy에서 조회 (`billing.month_end_threshold_day`, 기본값은 25일, 저장 위치는 tenant_settings(key='config').value(JSONB))

매월 01일 03:10 KST: TTL 지난 파티션 아카이브/드롭

파티션 생성 함수 예시:

CREATE OR REPLACE FUNCTION meta.create_month_partition(_table regclass, _yyyymm text) RETURNS void AS $$
DECLARE
  _from date := to_date(_yyyymm || '01','YYYYMMDD');
  _to   date := (_from + INTERVAL '1 month')::date;
BEGIN
  EXECUTE format(
    'CREATE TABLE IF NOT EXISTS %s_%s PARTITION OF %s FOR VALUES FROM (%L) TO (%L);',
    _table::text, to_char(_from,'YYYY_MM'), _table::text, _from, _to
  );
END; $$ LANGUAGE plpgsql SECURITY DEFINER;

스케줄: 외부 런타임(Lambda/Cloudflare Workers)에서 호출 (KST 03:00/03:10)

→ 파티션 관리 자동화는 운영 필수 요소

5-3. RLS 성능 가드레일 및 최적화

실시간 트랜잭션 → RLS 100% 적용

Heavy Analytics / Export → SECURITY DEFINER 또는 Edge Function + Service Role

tenant_id 화이트리스트, audit 로그 필수

제어된 우회 예시:

CREATE OR REPLACE FUNCTION analytics.fn_aggregate_daily(
  _tenant_ids uuid[], _kst_date date
) RETURNS void
LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  -- tenant_id IN (_tenant_ids) 강제
  -- statement_timeout, row limit 필수
END; $$;


UI 트랜잭션 경로에서는 항상 RLS 적용

모든 우회 쿼리는 audit.events 에 로그 남김

RLS 성능 최적화: 2중 필터링 패턴 (Critical)

문제점: PostgreSQL RLS 정책으로 인해 쿼리 플래너가 인덱스를 최적으로 선택하지 못하는 경우 존재

RLS + Partition 조합 시 예상되는 성능 문제 (Critical):

Partition Pruning이 tenant_id에 의존하지 않음 (시간 기반 파티션 기준)

RLS 조건이 planner에 영향을 줄 수 있음

PostgreSQL 14+에서도 RLS가 planner에 간섭 가능

Partitioned Table에서는 RLS가 Partition Pruning에 영향을 줄 수 있다

→ RLS와 Partition은 완전히 독립적이지 않으며, planner가 최적화를 제대로 수행하지 못할 수 있음

⚠️ 중요: Supabase 환경에서의 추가 고려사항

PgBouncer 트랜잭션 풀링에서는 set_config가 세션 레벨이 아님

일부 Edge Function 환경에선 planner 예측이 낮아질 가능성 있음

📌 권고: Service Layer에서 tenant_id 강제 필터를 lint 규칙으로 만들어라

multi-column index 설계 전략이 명확해야 함

해결책: Service Layer에서 항상 tenant_id 조건을 명시적으로 추가

규칙: 모든 Service Layer 쿼리는 WHERE 절에 tenant_id 조건 필수

→ 이미 문서에 기재되어 있으므로 OK. ESLint 규칙으로 강제하여 개발자가 실수로 tenant_id 조건을 빠뜨리는 것을 방지합니다.

5-3-1. 쿼리 패턴별 권장 인덱스 매트릭스 (Critical)

쿼리 패턴	권장 인덱스	예시
tenant_id + occurred_at (시간 범위)	(tenant_id, occurred_at)	attendance_logs 조회
tenant_id + status + created_at	(tenant_id, status, created_at)	미납 청구서 조회
tenant_id + industry_type	(tenant_id, industry_type)	업종별 학생 조회
tenant_id + email_hash (PII 검색)	(tenant_id, email_hash)	보호자 이메일 검색

인덱스 설계 원칙:

항상 tenant_id를 첫 번째 컬럼으로 포함 (Partition Pruning 최적화)

시간 기반 쿼리는 (tenant_id, occurred_at) 복합 인덱스 필수

RLS 조건과 WHERE 절 조건이 일치하도록 설계

예시:

-- ❌ 잘못된 예 (RLS만 의존)
SELECT * FROM students WHERE name = '김철수';

-- ✅ 올바른 예 (RLS + 명시적 필터)
SELECT * FROM students
WHERE tenant_id = :tenant_id AND name = '김철수';


RLS는 보안 레이어, 필터링은 쿼리 레이어에서 수행하는 "2중 필터링 패턴" 도입

→ 성능 저하 방지에 매우 효과적이며 실무에서 필수적으로 사용하는 방식

RLS + Partition 조합 성능 고려사항:

Partitioned Tables 사용 시, RLS 조건이 Partition Pruning에 영향을 줄 수 있으므로, tenant_id를 Partition Key로 사용하지 않는 구조(=시간 기반 파티션)는 유지하는 것이 옳음.

시간 기반 파티셔닝을 유지하면 RLS 조건과 독립적으로 Partition Pruning이 작동하여 쿼리 플래너가 최적의 플랜을 생성할 수 있다.

5-4. 이중 파티셔닝 (시간 RANGE + tenant HASH) (선택적 구현, 실제 필요 시)

⚠️ 중요: 이 섹션은 선택적 구현이며, 실제 필요성이 확인된 후에만 도입합니다.

상용화 단계에서는 단일 RANGE 파티셔닝만으로 충분합니다.

트래픽이 매우 큰 환경에서 선택적으로 도입 가능한 옵션(이중 파티셔닝 예시):

Hot Partition 방지 및 Shard 이행 용이성을 위해 이중 파티셔닝 전략 적용 (선택적 구현, 실제 필요 시):

⚠️ 중요: 이 섹션은 선택적 구현이며, 실제 필요성이 확인된 후에만 도입합니다.

상용화 단계에서는 단일 RANGE 파티셔닝만 사용합니다.

이중 파티셔닝 구조 (참고용 예시):

CREATE TABLE attendance_logs (
  id bigserial,
  tenant_id uuid NOT NULL,
  occurred_at timestamptz NOT NULL
) PARTITION BY RANGE (occurred_at);

CREATE TABLE attendance_logs_2025_01
  PARTITION OF attendance_logs
  FOR VALUES FROM ('2025-01-01') TO ('2025-02-01')
  PARTITION BY HASH (tenant_id);

→ Hot Partition 방지 / Shard 이행 용이.

→ 상용화 단계에서는 단일 RANGE 파티셔닝만 사용하며, 이중 파티셔닝은 선택적 구현(실제 필요 시)으로 검토합니다.

→ 실제 2~3만 테넌트 수준에서는 단일 RANGE 파티셔닝만으로 충분하며, 이중 파티셔닝은 수십만 테넌트 규모에서만 검토합니다.

단계 3) Read Replica (조회 트래픽 분리)

리포트/통계/대시보드 조회는 replica로 전송

core-analytics는 replica 기반 heavy query 실행

단계 4) 리전/샤딩 (초과 성장 시나리오, 현재 불필요)

AP-Northeast-2(한국), AP-Southeast-1(동남아) 등 분리

테넌트 ID 해시 기반 라우팅

Supabase 클라이언트에서 DB route layer 추가

5-5. Hot Tenant 대응 전략 (Critical)

문제점: 특정 테넌트의 트래픽·청구·출결 폭주 시 전체 DB 성능에 영향

Hot Tenant 자동 감지 지표

tenant별 QPS, CPU, IOPS 비중 모니터링

급증 패턴 탐지: 5분 이동평균 대비 200% 증가 시 경고

Hot Tenant 감지 임계값 (모니터링용):
- 단일 테넌트 QPS가 전체의 10% 초과
- 단일 테넌트 CPU 사용량이 전체의 15% 초과
- 단일 테넌트 IOPS가 전체의 20% 초과

📌 Hot Tenant 샤딩 트리거 기준 (정량화된 수치):

[불변 규칙] 다음 기준 중 3개 이상을 동시에 만족하면 Hot Tenant 샤딩을 검토합니다:

1. 초당 요청 수 (QPS):
   - 단일 테넌트 QPS ≥ 1,000 req/s
   - 또는 단일 테넌트 QPS가 전체의 30% 초과 (7일 이동평균)

2. 월별 Row 증가량:
   - 단일 테넌트 월별 row 증가량 ≥ 1천만 rows/월
   - 또는 단일 테넌트 총 row 수가 전체의 20% 초과

3. 이벤트 Ingestion 속도:
   - 단일 테넌트 이벤트 ingestion 속도 ≥ 10,000 events/min
   - 또는 analytics.events 테이블에서 단일 테넌트 비중 ≥ 25%

4. CPU/IO 부하 기준:
   - 단일 테넌트 CPU 사용량이 전체의 25% 초과 (1시간 이동평균)
   - 단일 테넌트 IOPS가 전체의 30% 초과 (1시간 이동평균)
   - 단일 테넌트 DB 연결 수가 전체의 20% 초과

5. 트래픽 급증 패턴:
   - 5분 이동평균 대비 300% 증가가 3회 이상 발생
   - 또는 일일 트래픽이 전일 대비 200% 증가

⚠️ 중요: 위 기준 중 3개 이상을 동시에 만족하고, Read Replica로 트래픽 분산, 파티셔닝, 업종별 분리 전략으로 해결되지 않는 경우에만 Hot Tenant 샤딩을 검토합니다.

Hot Tenant 수직 샤딩 절차

Step 1: 특정 tenant_id 트래픽을 read replica 또는 전용 replica로 라우팅

Step 2: traffic routing layer에서 해당 테넌트만 별도 DB로 이동 (vertical split)

Step 3: 다른 테넌트 영향 없이 실시간 마이그레이션 수행

5-5-1. Hot Tenant 수직 분리 절차 (초과 성장 시나리오, 현재 불필요)

⚠️ 중요: 이 섹션은 초과 성장 시나리오(수십만 테넌트)에서도 대규모 팀이 필요하며, 1인 개발사에서는 구현이 비현실적입니다.

🚨 1인 개발사/소규모 팀 현실성 경고: Hot Tenant 수직 샤딩은 기술적으로 매우 복잡한 작업이며, Supabase 단일 프로젝트 철학과 충돌할 수 있습니다. CDC 동기화, conflict 해결, routing layer, 영구 분리 정책 등 복잡도가 매우 높아 1인 개발사에서는 구현이 비현실적입니다. 현재 사업 목표(2~3만 테넌트)에서는 불필요하며, 초과 성장 시나리오(수십만 테넌트)에서도 대규모 팀이 필요합니다.

실제 난이도:
- CDC 동기화: 복잡도 매우 높음
- 다운타임 없는 이행: 매우 어려움
- Merge back 불가: 영구 분리 정책 유지 필요
- 모니터링 파이프라인: 별도 구축 필요

상용화 단계에서는 Read Replica로 트래픽 분산만으로 충분합니다.

CDC 기반 샤딩 자동화는 초과 성장 시나리오(수십만 테넌트급)에서나 사용하는 방식이며, 실제 2~3만 테넌트 수준에서는 PostgreSQL 파티셔닝 + Read Replica만으로 충분합니다.

Hot Tenant 발생 시 대응 순서 (초과 성장 시나리오):

⚠️ 중요: Hot Tenant 샤딩은 "최후의 수단"이며, 다음 순서로 대응을 검토합니다:
1. Read Replica로 트래픽 분산 (우선 시도)
2. 파티셔닝으로 데이터 분리 (다음 단계)
3. 업종별 분리 전략 적용 (업종 단위 분리)
4. Hot Tenant 수직 샤딩 (최후의 수단, 수동 분리만, 초과 성장 시나리오)

수동 수직 분리 절차 (초과 성장 시나리오):

Step 1: 특정 tenant_id 데이터를 별도 DB로 수동 마이그레이션
- 다운타임 최소화를 위한 점진적 마이그레이션
- CDC 동기화는 초과 성장 시나리오에서도 대규모 팀이 필요

Step 2: 트래픽 라우팅 레이어에서 해당 테넌트만 별도 DB로 라우팅
- 애플리케이션 레벨에서 tenant_id 기반 라우팅 구현
- Supabase 클라이언트 래퍼 필요

Step 3: 마이그레이션 완료 후 소스 DB에서 해당 tenant_id 데이터 제거
- Merge back 불가 정책 유지
- 영구 분리로 운영

→ 자동화된 CDC 기반 샤딩은 개발 복잡도가 매우 높으므로, 초과 성장 시나리오에서도 대규모 팀이 필요합니다.

구현 범위:

상용화 단계 (초기, 학원 100~300개 수준): Read Replica로 트래픽 분산만 사용

선택적 구현: Multi-Region DR 도입 (외부 DB 사용 시, 난이도: 중)

초과 성장 시나리오: Hot Tenant 수직 샤딩 도입 (수동 분리, 난이도: 매우 높음, 대규모 팀 필요)

초과 성장 시나리오: CDC 기반 샤딩 자동화 검토 (선택적, 난이도: 매우 높음, 대규모 팀 필요)

→ 상용화 단계에서는 Over-engineering을 방지하기 위해 Read Replica와 파티셔닝만 사용합니다.

5-5-2. Hot Tenant 수직 샤딩 원복 전략 (Critical)

수직 샤딩된 테넌트는 원칙적으로 "영구 분리(shard-pinned)" 상태로 유지하며, merge-back은 지원하지 않는다.

정책 근거:

Merge-back 과정에서 데이터 충돌 방지 복잡도가 매우 높음

CDC 동기화 중단 및 정합성 검증 프로세스가 복잡

운영 난이도 극적으로 감소

대안:

트래픽이 진정된 경우에도 독립 샤드에서 계속 운영

샤드 간 부하 분산으로 전체 시스템 안정성 향상

만약 merge-back이 필수인 경우:

CDC 기반 양방향 동기화 필요

정합성 검증 프로세스 필수

데이터 충돌 해결 전략 수립

→ 운영 복잡도를 줄이기 위해 영구 분리 정책 권장

5-5-3. Shard 재조정 전략 (초과 성장 시나리오, 현재 불필요)

⚠️ 중요: 이 섹션은 초과 성장 시나리오(수십만 테넌트)에서도 대규모 팀이 필요하며, 1인 개발사에서는 구현이 비현실적입니다.

🚨 1인 개발사/소규모 팀 현실성 경고: Shard 재조정은 수십만 테넌트 규모에서만 필요하며, CDC 기반 자동화는 운영 복잡도가 매우 높아 1인 개발사에서는 구현이 비현실적입니다.

상용화 단계에서는 샤딩 자체가 불필요하므로 이 기능도 불필요합니다.

샤드 간 부하 불균형이 생겼을 때 대응 (초과 성장 시나리오):

시나리오:

특정 shard만 과부하되는 경우 (수십만 테넌트 운영 시 발생 가능)

샤드 간 부하 분산을 위한 테넌트 재배치

구현 방식:

수동 마이그레이션 기반 재배치 (우선 권장)

CDC 기반 자동화는 운영 복잡도가 매우 높으므로 대규모 팀이 필요

운영 조건:

부하 기반 shard 재조정은 운영 비용이 크므로 월 단위/분기 단위와 같은 제한된 시점에만 실행한다.

→ 수십만 테넌트 이상 규모에서도 대규모 팀이 필요하며, 현재 불필요합니다.

자동 경고 및 라우팅 시스템

Edge → Supabase Routing Layer → fallback replica

모니터링 대시보드에서 Hot Tenant 자동 감지 시 Slack/이메일 알림

라우팅 레이어에서 tenant_id 기반 자동 분산 처리

Hot Tenant 라우팅 레이어는 Edge Middleware 또는 Server Gateway(API Layer)에 구현되며, Supabase의 단일 RLS 모델과 충돌 없이 테넌트 단위 수직 샤딩을 가능하게 한다.

5. Schema Registry 운영 문서 (Critical)

⚠️ 중요: Schema Registry는 수천 테넌트 운영 시 핵심 인프라입니다. 스키마 버전 관리, 충돌 해결, Rollback 정책이 필수입니다.

5-6. Schema Registry 저장 위치 및 관리 방식

저장 방식 옵션:

옵션 1: PostgreSQL 테이블 (권장, 상용화 단계)
- 테이블: `meta.schema_registry` (실제 테이블)
- VIEW: `public.schema_registry` (PostgREST 노출용, underlying table은 `meta.schema_registry`)
- 장점: Supabase와 통합, 트랜잭션 보장, RLS 적용 가능
- 단점: Git 연동이 수동
- ⚠️ 중요: `public.schema_registry`는 VIEW이므로, RLS 정책은 underlying table(`meta.schema_registry`)의 RLS에 의해 보호됨

옵션 2: Git-managed JSON 파일 (상용화 단계 권장)
- 저장 위치: `infra/schemas/{industry_type}/{entity}/{version}.json`
- 장점: 버전 관리 자동화, PR 기반 검토, 롤백 용이
- 단점: Git 연동 필요, CI/CD 파이프라인 구성 필요

옵션 3: S3 + Git 하이브리드 (선택적 구현)
- Git: 스키마 정의 파일 (소스)
- S3: 배포된 스키마 버전 (런타임)
- 장점: 소스 관리와 배포 분리, CDN 캐싱 가능
- 단점: 복잡도 증가

상용화 단계 권장 구조:

```sql
CREATE SCHEMA IF NOT EXISTS meta;

CREATE TABLE meta.schema_registry (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  entity text NOT NULL,              -- 'student', 'invoice', 'schedule' 등
  industry_type text,                -- 'academy', 'salon' 등 (nullable = 공통)
  version text NOT NULL,             -- '2.0.1'
  min_supported_client text NOT NULL, -- '1.12.0' (정본, 필수)
  min_client text,                    -- '1.12.0' (레거시 입력 허용, 저장 시 min_supported_client로 정규화)
  -- ⚠️ 중요: min_client 정규화 규칙 (DB/API 레벨 강제)
  -- 1. min_client 입력 시: 자동으로 min_supported_client에 저장하고 min_client는 NULL로 설정 (아래 트리거 참조)
  -- 2. 우선순위: min_supported_client가 항상 SSOT, 둘 다 값이 있으면 min_supported_client 우선
  -- 3. 읽기 시: min_supported_client를 우선 사용, 없으면 min_client 사용 (하위 호환)
  -- 4. ⚠️ 신규 코드에서는 min_client 사용 금지, min_supported_client만 사용
  schema_json jsonb NOT NULL,        -- 실제 스키마 정의
  migration_script text,             -- Migration Script (nullable)
  status text NOT NULL DEFAULT 'draft', -- 'draft', 'active', 'deprecated'
  registered_by uuid REFERENCES auth.users(id),
  registered_at timestamptz NOT NULL DEFAULT now(),
  activated_at timestamptz,          -- 활성화 시점
  deprecated_at timestamptz,         -- 폐기 시점
  UNIQUE(entity, industry_type, version)
);

-- ⚠️ 중요: Schema Registry 컬럼 SSOT (정본)
-- 정본 컬럼: registered_at, activated_at, deprecated_at, registered_by (전체 기술문서 정본)
-- ⚠️ 참고: 스키마에디터 문서의 created_at/updated_at/created_by/updated_by는 개념적 표기이며,
-- 실제 DB 컬럼은 위 정본 컬럼을 사용합니다.

CREATE INDEX idx_schema_registry_entity ON meta.schema_registry(entity, industry_type, status);
CREATE INDEX idx_schema_registry_version ON meta.schema_registry(entity, industry_type, version DESC);

-- ⚠️ 중요: min_client 정규화 트리거 (DB 레벨 강제)
-- min_client 입력 시 자동으로 min_supported_client로 정규화하고 min_client는 NULL로 설정
CREATE OR REPLACE FUNCTION normalize_min_client()
RETURNS TRIGGER AS $$
BEGIN
  -- min_client가 입력되면 min_supported_client로 정규화
  IF NEW.min_client IS NOT NULL AND NEW.min_client != '' THEN
    NEW.min_supported_client := NEW.min_client;
    NEW.min_client := NULL;
  END IF;

  -- 둘 다 값이 있으면 min_supported_client 우선 (SSOT)
  IF NEW.min_supported_client IS NOT NULL AND NEW.min_client IS NOT NULL THEN
    NEW.min_client := NULL;  -- min_supported_client가 SSOT이므로 min_client는 무시
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_normalize_min_client
  BEFORE INSERT OR UPDATE ON meta.schema_registry
  FOR EACH ROW
  EXECUTE FUNCTION normalize_min_client();
```

⚠️ 중요: 마이그레이션 파일 일관성
- 정본 마이그레이션: `infra/supabase/migrations/039_create_schema_registry.sql` (20줄)에서 `min_supported_client text NOT NULL`로 정의됨
- ⚠️ 코드 수정 필요: `infra/supabase/migrations/043_verify_meta_tables.sql` (35줄)에서 `min_supported_client text,` (nullable)로 생성되고 있어 불일치
  - 수정 필요: `min_supported_client text NOT NULL,`로 변경
- ⚠️ 코드 수정 필요: `packages/core/core-schema-registry/src/service.ts` (61줄)에서 `input.minSupportedClient`가 null/undefined인 경우 에러 처리 또는 기본값 설정 필요
  - 문서 스펙에 따르면 `min_supported_client`는 필수(NOT NULL)이므로, 서비스 레벨에서도 검증 필요

5-7. Schema Registry 등록 시점 Validation

스키마 등록 시 다음 검증을 수행합니다:

1. Meta-Schema Validation
   - 스키마 구조가 Meta-Schema 규칙을 준수하는지 검증
   - 필수 필드: version, minSupportedClient (camelCase, Schema JSON 정본), entity
   - ⚠️ 중요: 필드명 SSOT
     - Schema JSON (문서/레지스트리 정본): `minSupportedClient` (camelCase)
     - DB 컬럼 정본: `min_supported_client` (snake_case)
     - 하위호환 alias: `minClient`/`min_client`는 "읽기만 허용(Deprecated)"로 두고, 저장 시 정규화해서 `minSupportedClient`로 변환
   - Tailwind 클래스 문자열 사용 금지 검증

2. 버전 충돌 검증
   - 동일 entity + industry_type에서 이미 활성화된 버전과 충돌 여부 확인
   - Major 버전 업그레이드 시 Migration Script 필수

3. 하위 호환성 검증
   - 기존 클라이언트가 새 스키마를 렌더링할 수 있는지 검증
   - Breaking change 감지 시 경고 또는 거부

4. Migration Script 검증 (Major 업그레이드 시)
   - Migration Script 구문 검증
   - 빌드 타임 변환 가능 여부 확인

등록 프로세스:

```typescript
// packages/schema-engine/registry.ts
export async function registerSchema(schema: SchemaDefinition) {
  // 1. Meta-Schema Validation
  const validationResult = validateMetaSchema(schema);
  if (!validationResult.valid) {
    throw new Error(`Meta-Schema validation failed: ${validationResult.errors}`);
  }

  // 2. 버전 충돌 검증
  const existingActive = await getActiveSchema(schema.entity, schema.industry_type);
  if (existingActive && isVersionConflict(existingActive.version, schema.version)) {
    throw new Error(`Version conflict: ${existingActive.version} is still active`);
  }

  // 3. 하위 호환성 검증
  if (existingActive && !isBackwardCompatible(existingActive, schema)) {
    if (!schema.migrationScript) {
      throw new Error('Breaking change requires migration script');
    }
  }

  // 4. 등록 (status = 'draft')
  await db.insert('meta.schema_registry', {
    entity: schema.entity,
    industry_type: schema.industry_type,
    version: schema.version,
    min_supported_client: schema.minSupportedClient,
    schema_json: schema,
    migration_script: schema.migrationScript,
    status: 'draft'
  });
}
```

5-8. Git 연동 (상용화 단계)

Git-managed Schema Registry 구조:

```
infra/schemas/
  ├─ common/                    # 공통 스키마
  │  ├─ invoice/
  │  │  ├─ 1.0.0.json
  │  │  ├─ 2.0.0.json
  │  │  └─ migrations/
  │  │     └─ 1.0.0_to_2.0.0.ts
  │  └─ payment/
  │     └─ 1.0.0.json
  ├─ academy/                   # 업종별 스키마
  │  ├─ student/
  │  │  ├─ 1.0.0.json
  │  │  ├─ 2.0.1.json
  │  │  └─ migrations/
  │  └─ class/
  └─ salon/
     └─ customer/
```

CI/CD 파이프라인:

1. 개발자가 PR 생성 → 스키마 파일 추가/수정
2. CI에서 Meta-Schema Validation 실행
3. PR 머지 시 자동으로 `meta.schema_registry`에 등록 (status = 'draft')
4. 운영자가 Super Admin에서 활성화 (status = 'active')

5-9. Rollback 정책

Rollback 시나리오:

시나리오 1: 새 스키마 버전 배포 실패
- 이전 활성 버전으로 자동 롤백
- `meta.schema_registry`에서 새 버전 status를 'deprecated'로 변경
- 이전 버전을 다시 'active'로 변경

시나리오 2: Migration Script 실행 실패
- 스키마 활성화 전에 Migration Script를 테스트 환경에서 검증
- 실패 시 스키마 등록 자체를 거부

시나리오 3: 클라이언트 호환성 문제
- `minSupportedClient` (정본) 또는 `min_supported_client` (DB 컬럼) 버전 미만 클라이언트가 존재하는 경우
- ⚠️ 중요: 정본은 `minSupportedClient` (Schema JSON) / `min_supported_client` (DB 컬럼)입니다. `minClient`/`min_client`는 레거시 입력 허용 시 저장 시 정규화됩니다.
- 스키마 활성화를 지연하거나 클라이언트 업데이트 유도

Rollback 절차:

```typescript
export async function rollbackSchema(entity: string, industryType: string | null) {
  // 1. 현재 활성 버전 확인
  const active = await getActiveSchema(entity, industryType);
  if (!active) {
    throw new Error('No active schema to rollback');
  }

  // 2. 이전 버전 찾기
  const previous = await getPreviousVersion(entity, industryType, active.version);
  if (!previous) {
    throw new Error('No previous version available');
  }

  // 3. 현재 버전 비활성화
  await db.update('meta.schema_registry',
    { id: active.id },
    { status: 'deprecated', deprecated_at: now() }
  );

  // 4. 이전 버전 활성화
  await db.update('meta.schema_registry',
    { id: previous.id },
    { status: 'active', activated_at: now() }
  );

  // 5. 알림 발송
  await sendAlert('Schema rollback', { entity, industryType, from: active.version, to: previous.version });
}
```

5-10. Version Pinning 정책

테넌트별 스키마 버전 고정:

특정 테넌트가 특정 스키마 버전을 사용해야 하는 경우 (예: 커스텀 위젯 호환성):

```sql
CREATE TABLE meta.tenant_schema_pins (
  tenant_id uuid NOT NULL REFERENCES tenants(id),
  entity text NOT NULL,
  industry_type text,
  pinned_version text NOT NULL,
  reason text,
  pinned_at timestamptz NOT NULL DEFAULT now(),
  pinned_by uuid REFERENCES auth.users(id),
  UNIQUE(tenant_id, entity, industry_type)
);
```

Version Pinning 우선순위:

1. 테넌트별 Pin이 있으면 해당 버전 사용
2. Pin이 없으면 활성화된 최신 버전 사용
3. 클라이언트 `minSupportedClient` (정본) / `min_supported_client` (DB 컬럼) 미만 버전은 사용 불가
- ⚠️ 중요: 정본은 `minSupportedClient` (Schema JSON) / `min_supported_client` (DB 컬럼)입니다. `minClient`/`min_client`는 레거시 입력 허용 시 저장 시 정규화됩니다.

5-11. Conflict Resolution 정책

스키마 버전 충돌 해결:

충돌 유형 1: 동시 등록
- 동일 entity + industry_type + version이 동시에 등록되는 경우
- UNIQUE 제약조건으로 차단
- 먼저 등록된 것이 승인, 나머지는 거부

충돌 유형 2: 활성 버전과의 호환성
- 새 버전이 기존 활성 버전과 호환되지 않는 경우
- Migration Script 필수
- Migration Script 없이는 등록 거부

충돌 유형 3: 클라이언트 지원 범위
- `minSupportedClient` (정본) / `min_supported_client` (DB 컬럼)가 너무 높아서 기존 클라이언트가 지원하지 않는 경우
- ⚠️ 중요: 정본은 `minSupportedClient` (Schema JSON) / `min_supported_client` (DB 컬럼)입니다. `minClient`/`min_client`는 레거시 입력 허용 시 저장 시 정규화됩니다.
- 경고 발송, 활성화는 수동 승인 필요

5-12. 운영 담당자 기준 문서

Super Admin에서 Schema Registry 관리:

1. 스키마 목록 조회
   - entity, industry_type, version, status 필터링
   - 활성/비활성 버전 구분 표시

2. 스키마 활성화/비활성화
   - Draft → Active 전환 시 Migration Script 실행 확인
   - Active → Deprecated 전환 시 영향 범위 확인

3. Rollback 실행
   - 이전 버전 목록 표시
   - Rollback 실행 시 영향 범위 경고

4. 테넌트별 Version Pinning 관리
   - 특정 테넌트의 스키마 버전 고정/해제
   - Pin 이유 기록

5. 충돌 해결
   - 충돌 감지 시 알림
   - 수동 승인/거부 인터페이스

→ Schema Registry는 실 서비스 환경에서 Schema Rollout 실패 시 대응을 위한 핵심 인프라이므로, 위 정책을 반드시 준수해야 합니다.

📘 PART 2
Core Platform / Industry 모듈 / Services / Hooks / core-ui / 반응형 / 모바일·태블릿 / 다크모드 / 확대보기(Zoom)

6. Core Platform Layer 상세 설계

Core Layer는 전 업종 공통 기능을 제공하며, 모든 Industry 모듈의 기반이 된다.

6-1. core-auth / core-tenancy (인증·테넌시)

1) 인증 (Supabase Auth)

[불변 규칙] 인증 로직은 core-auth 모듈에서 공통으로 관리합니다.

패키지 구조:
- packages/core/core-auth/src/login.ts: 로그인 서비스 (이메일/소셜/OTP)
- packages/core/core-auth/src/signup.ts: 회원가입 서비스 (사용자 계정 생성)
- packages/core/core-auth/src/service.ts: 기본 인증 서비스 (사용자 조회 등)

지원 인증 방식:
- 이메일/비밀번호 로그인 (loginWithEmail)
- 소셜 로그인 (Google, Kakao 등) (loginWithOAuth)
- 전화번호·OTP 로그인 (업종에 따라 활성화) (loginWithOTP)

로그인 플로우:
1. 사용자 인증 (Supabase Auth)
2. 사용자의 테넌트 목록 조회 (user_tenant_roles)
3. 테넌트 선택 (JWT claim에 tenant_id 포함)
4. 세션 새로고침 (업데이트된 JWT 받기)

회원가입 플로우:
1. 사용자 계정 생성 (Supabase Auth) - core-auth/signup.ts
2. 이메일 인증 (선택적)
3. 테넌트 생성 및 온보딩 - core-tenancy/onboarding.ts
4. 업종별 초기 데이터 시드 - Industry Layer

2) 테넌트 조인 모델

하나의 유저 → 여러 테넌트 소속 가능
(user_tenant_roles로 매핑)

user_tenant_roles
- user_id
- tenant_id
- role (owner, admin, sub_admin, manager, staff, teacher, assistant, counselor, parent, super_admin)

3) 테넌트 온보딩 (core-tenancy/onboarding.ts)

[불변 규칙] 테넌트 생성 및 초기화는 core-tenancy/onboarding.ts에서 공통으로 관리합니다.

테넌트 생성 플로우:
1. tenants 테이블에 row 생성
2. tenant_settings에 업종별 기본값 저장 (timezone, locale 등)
   - 주의: industry_type은 tenant_settings에 저장하지 않음 (SSOT-2: public.tenants.industry_type이 1차 소스)
3. tenant_features에 플랜/기능 ON/OFF 설정
   - ⚠️ 중요: AI 기능은 `tenant_features(feature_key='ai').enabled`로 관리 (Default Policy: 테넌트 생성 시 enabled=true로 설정값으로 저장)
   - SSOT: `tenant_features(feature_key='ai').enabled` (프론트 상황 신호 수집 문서 참조)
4. owner 유저를 user_tenant_roles에 연결
5. 추천인 코드 처리 (선택적, core-tenancy-referral 연동)
6. 업종별 seed 실행 (Industry Layer에서 별도 처리)

⚠️ 중요: 업종별 초기 데이터 시드(예: 학원 기본 반, 미용실 기본 서비스)는 Industry Layer에서 처리합니다.
core-tenancy/onboarding.ts는 테넌트 생성, 기본 설정, 역할 할당만 담당합니다.

4) RLS 보안 규칙

유저가 소속된 테넌트만 접근 가능

표준 RLS 패턴 템플릿 (정본, 3-2 참조):

⚠️ 중요: 표준 RLS 정책은 JWT claim 기반으로 통일합니다. current_setting 기반은 레거시/금지입니다.

**정본 (Transaction Pooling 호환, 필수):**
CREATE POLICY tenant_isolation_<table> ON public.<table>
FOR ALL TO authenticated
USING (
  tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
)
WITH CHECK (
  tenant_id = (auth.jwt() ->> 'tenant_id')::uuid
);

**레거시/금지 (Session Pooling 또는 전용 커넥션 전용, 사용 금지):**
⚠️ 레거시 예시: 더 이상 사용하지 않음, JWT claim 기반 RLS 사용 권장. 아래 패턴은 Transaction Pooling과 호환되지 않으므로 사용하지 않습니다.
-- tenant_id = NULLIF(current_setting('app.current_tenant_id', true), '')::uuid
WITH CHECK (
  tenant_id = NULLIF(current_setting('app.current_tenant_id', true), '')::uuid
);

→ 모든 RLS 정책은 위 옵션 중 하나를 선택하여 사용해야 합니다. Transaction Pooling을 사용하는 경우 반드시 옵션 1을 사용해야 합니다.

5) Service Layer 및 Hooks

[불변 규칙] Service Layer는 Core Layer를 래핑하여 제공합니다.

패키지 구조:
- packages/services/auth-service: Auth Service (Core Layer 래퍼)
- packages/hooks/use-auth: React Query 기반 인증 관리 Hook

주요 Hook:
- useLoginWithEmail: 이메일/비밀번호 로그인
- useLoginWithOAuth: 소셜 로그인
- useLoginWithOTP: OTP 로그인
- useSelectTenant: 테넌트 선택
- useLogout: 로그아웃
- useSignupWithEmail: 회원가입
- useCreateTenant: 테넌트 생성 및 온보딩
- useUserTenants: 사용자 테넌트 목록 조회

6-2. core-billing / core-metering (과금·사용량 추적)
Billing 공통 규칙

invoices / invoice_items 구조 모든 업종 공통

item_type / category로 업종별 청구항목을 분류

결제는 payments 테이블에서 provider별 통합 처리

Metering(사용량 계측)

출결 건수

문자발송 수

활성 모듈 수

사용자 수

Edge Function에서 수집하여 서버가 인보이스 생성.
배치 실행 시각은 매일 04:00 KST 고정.

6-3. core-notification (메시징/알림)

지원 채널:

- SMS (`sms`): 기본 문자 메시지 채널
- 카카오 알림톡 (`kakao_at`): 카카오 알림톡 채널 (⚠️ 중요: 저장/실행용 코드는 'kakao_at'만 허용, 'kakao' 저장 금지)
  - ⚠️ Fallback 정책: 카카오 알림톡 발송 실패 시 자동으로 SMS로 fallback
- 이메일 (`email`): 이메일 채널
- 앱 Push (`push`): 앱 푸시 알림 (선택)

Edge Function:

fns-notification-dispatch


기능:

템플릿 관리

메시지 큐 처리

재시도 정책

발송 로그 저장

6-4. core-payment (결제/알림뱅킹 Provider)

core-payment는 결제 도메인 공통 스키마/비즈니스 규칙을 제공하고, 실제 결제 API 연동 코드는 /packages/payments/* Provider 모듈에서 구현한다.

Provider 구조:

/packages/payments/
  ├─ payment-alimbank/
  ├─ payment-toss/
  ├─ payment-kg/
  └─ payment-nice/


각 Provider는 다음을 구현:

결제 요청 생성

결과 웹훅 수신 처리

응답 검증(HMAC/Signature)

멱등성 처리

invoice-status 업데이트

Edge Function:

fns-payment-alimbank-request
fns-payment-alimbank-webhook

6-5. core-config (환경설정)

tenant_settings 기반으로 업종별 세팅 제공:

예시:

출결 기준 시간
지각/결석 기준 (분 단위)
기본 청구 주기
UI 테마(light/dark)
기본 로고/브랜딩
기능 on/off


JSON 구성:

{
  "attendance": {
    "late_after": 10,
    "absent_after": 60
  },
  "billing": {
    "cycle": "monthly"
  },
  "ui": {
    "theme": "light",
    "zoom": 100
  },
  "ai": {
    // ⚠️ 중요: AI 기능 온오프는 tenant_features(feature_key='ai').enabled를 SSOT로 사용합니다.
    // tenant_settings.ai.enabled는 레거시이며, 더 이상 사용하지 않습니다.
    // SSOT: tenant_features(feature_key='ai').enabled (프론트 상황 신호 수집 문서 참조)
    "risk_score_weights": {
      "attendance_weight": 0.4,
      "counseling_weight": 0.3,
      "payment_weight": 0.2,
      "performance_weight": 0.1
    },
    "daily_briefing_time": "07:00",
    "model_retraining_schedule": "weekly_sunday_04:00",
    "pii_masking_enabled": true
  }
}

6-6. core-analytics (통계 파이프라인)
데이터 소스

출결 이벤트

결제 이벤트(invoices/payments)

수강신청/예약

로그인 기록

직원 활동

파이프라인 구조
원시 이벤트 테이블 (로그성) — 파티셔닝
↓
외부 런타임(Lambda/Cloudflare Workers) 집계 (매일 04:00 KST, Supabase cron은 트리거만 수행)
↓
analytics.daily_store_metrics (매장 단위 일별 KPI, 정본)
analytics.daily_region_metrics (지역 단위 집계 KPI, 정본)
⚠️ 중요: analytics.daily_metrics, analytics.monthly_revenue는 구버전/폐기된 네이밍이며 더 이상 사용하지 않습니다. 정본은 analytics.daily_store_metrics, analytics.daily_region_metrics만 사용합니다.
↓
뷰(Materialized View)
↓
대시보드

6-7. core-party (회원/고객 공통 모델)

⚠️ 중요: 모든 업종에서 회원/고객 개념이 필요하므로 공통 모듈로 구현합니다.

목적

모든 업종의 회원/고객 공통 모델 제공

업종별 사용:
- 학원: 학생(Student)
- 체육관: 회원(Member)
- 미용실: 고객(Customer)
- 부동산: 입주자(Resident)
- 비영리: 후원자(Donor)

데이터 모델

Core Party 테이블 (persons):

CREATE TABLE persons (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES tenants(id),
  name text NOT NULL,
  email text,
  phone text,
  address text,
  person_type text NOT NULL CHECK (person_type IN ('learner', 'student', 'customer', 'member', 'resident', 'donor', 'instructor', 'teacher')),  -- learner/instructor는 정본 키, student/teacher는 backward compatibility
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

업종별 확장 테이블 패턴:

학원(academy):
CREATE TABLE academy_students (
  person_id uuid PRIMARY KEY REFERENCES persons(id),
  grade text,
  class_name text,
  school_name text,
  ...
);

미용실(salon):
CREATE TABLE salon_customers (
  person_id uuid PRIMARY KEY REFERENCES persons(id),
  hair_type text,
  preferred_style text,
  ...
);

주요 기능

Party CRUD (persons 테이블 기반)

person_type 관리

공통 필드 관리 (name, email, phone, address 등)

업종별 확장 지원

Industry Layer 연동

Industry Layer는 core-party를 확장하여 사용:

```typescript
// Industry Layer에서 사용
import { partyService } from '@core/party/service';
import type { Person } from '@core/party';

// 학원 업종에서 학생 생성 시
const person = await partyService.createPerson(tenantId, {
  name: '홍길동',
  email: 'hong@example.com',
  person_type: 'student',
  ...
});

// 이후 academy_students 테이블에 확장 정보 저장
```

6-8. core-consultation (상담/기록 관리)

목적

모든 업종의 상담/기록 공통 관리

업종별 사용:
- 학원: 상담일지/학습일지
- 체육관: 수련 기록
- 미용실: 시술 기록
- 부동산: 상담 기록

주요 기능

상담/기록 CRUD

첨부 파일 관리 (core-storage 연동)

검색 기능 (core-search 연동)

AI 요약 연동 (향후)

데이터 모델

CREATE TABLE consultations (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES tenants(id),
  person_id uuid REFERENCES persons(id),
  consultation_type text NOT NULL,
  title text,
  content text NOT NULL,
  consultation_date date NOT NULL,
  created_by uuid REFERENCES auth.users(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

6-9. core-reviews (리뷰/평가 시스템)

목적

모든 업종의 리뷰/평가 공통 관리

업종별 사용:
- 학원: 학부모 평가
- 체육관: 회원 평가
- 미용실: 고객 리뷰
- 부동산: 입주자 평가

주요 기능

리뷰/평가 CRUD

평점 시스템 (1-5점)

댓글 기능 (core-community와 연동 가능)

사진 첨부 (core-storage 연동)

데이터 모델

CREATE TABLE reviews (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES tenants(id),
  person_id uuid REFERENCES persons(id),
  rating integer NOT NULL CHECK (rating >= 1 AND rating <= 5),
  title text,
  content text,
  is_visible boolean NOT NULL DEFAULT true,
  created_by uuid REFERENCES auth.users(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

6-10. core-coupons (쿠폰/할인 관리)

목적

모든 업종의 쿠폰/할인 관리 (고객 대상)

주요 기능

쿠폰 CRUD

할인 적용 로직

쿠폰 사용 내역

쿠폰 유효성 검증

데이터 모델

CREATE TABLE coupons (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES tenants(id),
  code text NOT NULL,
  name text NOT NULL,
  discount_type text NOT NULL CHECK (discount_type IN ('percentage', 'fixed')),
  discount_value numeric NOT NULL,
  min_purchase_amount numeric,
  max_discount_amount numeric,
  valid_from date NOT NULL,
  valid_until date NOT NULL,
  usage_limit integer,
  usage_count integer NOT NULL DEFAULT 0,
  is_active boolean NOT NULL DEFAULT true,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE coupon_usages (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES tenants(id),
  coupon_id uuid NOT NULL REFERENCES coupons(id),
  person_id uuid REFERENCES persons(id),
  invoice_id uuid REFERENCES invoices(id),
  used_at timestamptz NOT NULL DEFAULT now()
);

6-11. core-tenancy-referral (B2B 추천인 코드)

⚠️ 중요: SaaS 사용자(테넌트) 간 B2B 추천인 코드 제도입니다.

목적

SaaS 사용자(학원 운영자)가 다른 학원 원장에게 추천하는 B2B 추천인 시스템

특별 요구사항

B2B 추천인 코드 제도 필수 포함

추천인 코드 생성/사용/보상 관리

주요 기능

추천인 코드 생성 (추천인 tenant_id와 연결)

추천인 코드 검증

추천인 코드 사용 추적 (신규 가입자 tenant_id와 연결)

추천인 보상 시스템 (할인/크레딧 등)

추천인 통계 (추천 건수, 성공 건수 등)

데이터 모델

CREATE TABLE referral_codes (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  referrer_tenant_id uuid NOT NULL REFERENCES tenants(id),
  code text NOT NULL UNIQUE,
  reward_type text NOT NULL CHECK (reward_type IN ('discount', 'credit', 'free_trial')),
  reward_value numeric,
  is_active boolean NOT NULL DEFAULT true,
  expires_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE referral_usages (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  referral_code_id uuid NOT NULL REFERENCES referral_codes(id),
  new_tenant_id uuid NOT NULL REFERENCES tenants(id),
  used_at timestamptz NOT NULL DEFAULT now(),
  reward_applied boolean NOT NULL DEFAULT false,
  reward_applied_at timestamptz
);

보상 지급 로직

신규 테넌트 가입 시 추천인 코드 사용

보상 타입에 따라 할인/크레딧/무료 체험 적용

보상 지급 후 reward_applied 플래그 업데이트

6-12. core-events (이벤트/프로모션)

목적

모든 업종의 이벤트/프로모션 공통 관리

주요 기능

이벤트 CRUD

참여 관리

알림 발송 (core-notification 연동)

통계 집계

데이터 모델

CREATE TABLE events (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES tenants(id),
  title text NOT NULL,
  description text,
  event_type text NOT NULL,
  start_date date NOT NULL,
  end_date date NOT NULL,
  is_active boolean NOT NULL DEFAULT true,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE event_participants (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES tenants(id),
  event_id uuid NOT NULL REFERENCES events(id),
  person_id uuid REFERENCES persons(id),
  participated_at timestamptz NOT NULL DEFAULT now()
);

6-13. core-calendar (일정/예약/수업 스케줄)

⚠️ 중요: 자체 구현 권장 (디자인 시스템 통합, 멀티테넌트 특화)

목적

일정/예약/수업 스케줄 공통 도메인

구현 방식

자체 구현 권장:
- 디자인 시스템(@ui-core/react)과 완벽 통합
- 멀티테넌트 특화 기능 구현 용이
- 번들 크기 최적화
- Zero-Trust 아키텍처와의 통합 용이

상용화 단계에서 기본 캘린더 기능 구현 예정 (서비스 코드 완료, schedules 테이블 생성 마이그레이션 필요)

복잡한 기능은 상용화 단계에서 추가 예정

주요 기능

스케줄/예약 CRUD

반복 일정 관리

정원 관리

담당자 배정

캘린더 뷰 지원 (기본 기능)

데이터 모델

CREATE TABLE schedules (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES tenants(id),
  title text NOT NULL,
  description text,
  start_time timestamptz NOT NULL,
  end_time timestamptz NOT NULL,
  repeat_pattern text, -- 'daily', 'weekly', 'monthly', 'none'
  capacity integer,
  assigned_to uuid REFERENCES auth.users(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

6-14. core-storage (파일 업로드/권한)

목적

파일 업로드/권한/폴더 구조 공통화, Supabase Storage 래핑

주요 기능

파일 업로드/다운로드

권한 관리

폴더 구조 관리

파일 메타데이터 관리

문서 버전 관리 (문서 관리 기능 포함)

구현 방식

Supabase Storage 래핑

테넌트별 폴더 구조: `{tenant_id}/{module}/{file_id}`

RLS 기반 권한 관리

6-15. core-community (게시판/댓글/공지)

⚠️ 중요: 자체 구현 권장 (RLS 기반 테넌트 격리)

목적

공통 게시판/댓글/공지/파일 첨부 스키마 및 API

구현 방식

자체 구현 권장:
- RLS 기반 완벽한 테넌트 격리
- 디자인 시스템 통합
- Zero-Trust 아키텍처 준수
- 커스터마이징 자유도

주요 기능

게시판 CRUD

댓글 기능

공지사항 관리

파일 첨부 (core-storage 연동)

데이터 모델

CREATE TABLE posts (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES tenants(id),
  title text NOT NULL,
  content text NOT NULL,
  post_type text NOT NULL CHECK (post_type IN ('notice', 'board', 'announcement')),
  is_pinned boolean NOT NULL DEFAULT false,
  created_by uuid REFERENCES auth.users(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE comments (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES tenants(id),
  post_id uuid NOT NULL REFERENCES posts(id),
  content text NOT NULL,
  created_by uuid REFERENCES auth.users(id),
  created_at timestamptz NOT NULL DEFAULT now()
);

6-16. core-search (Full Text Search)

⚠️ 중요: 상용화 단계에서 PostgreSQL Full Text Search 구현 완료, 외부 검색 엔진(Meilisearch/Algolia)은 Phase 2+ 검토 예정.

목적

Full Text Search 공통 레이어

구현 방식

상용화 단계: PostgreSQL Full Text Search
- 추가 인프라 불필요
- RLS와 완벽 통합
- 비용 절감

상용화 단계: 외부 검색 엔진 구현 예정 (Phase 2+ 검토)
- Meilisearch, Algolia 등
- 고급 검색 기능 필요 시

주요 기능

검색 인덱싱 (PostgreSQL FTS)

검색 쿼리 처리

검색 결과 정렬

6-17. 외부 라이브러리 vs 자체 구현 정책

⚠️ 중요: Core Layer 모듈 구현 시 외부 라이브러리 사용 정책

원칙

멀티테넌트 격리와 Zero-Trust 아키텍처가 핵심 요구사항

디자인 시스템 통합이 중요

자체 구현 권장 모듈

core-calendar: 기본 기능을 상용화 단계에서 자체 구현 예정 (서비스 코드 완료, schedules 테이블 생성 마이그레이션 필요)

core-community: 게시판/댓글은 자체 구현 (RLS 기반 테넌트 격리)

core-search: 상용화 단계는 PostgreSQL Full Text Search

외부 라이브러리 고려 모듈 (상용화 단계)

고급 캘린더 기능: 필요 시 react-big-calendar 검토

고급 검색: 상용화 단계에서 Meilisearch/Algolia 구현 예정 (Phase 2+ 검토)

외부 라이브러리 사용 시 고려사항

번들 크기 증가

커스터마이징 제한

디자인 시스템과의 통합 어려움

멀티테넌트 특화 기능 추가 어려움

RLS 정책과의 통합 복잡

7. Industry Layer 설계

Industry Layer는 업종별 비즈니스 로직을 Core 위에서 확장하는 구조이다.

업종별 추가 필드는 PART 1의 4-0 (Profile 확장 전략) 섹션의 Profile 확장 모델(JSON Schema 또는 확장 테이블)에 의해 구현된다.

⚠️ 중요: Industry Layer 구조는 상용화 단계부터 적용됩니다.
- 업종별 비즈니스 로직은 `packages/industry/industry-{업종}/`에 구현됩니다.
- Service Layer는 Industry Layer를 래핑하여 제공합니다.
- Core Layer는 Industry Layer를 import하지 않습니다 (단방향 의존성).

7-1. industry-academy (학원)

구조:
```
packages/industry/industry-academy/
├── package.json
├── tsconfig.json
└── src/
    ├── index.ts          # 타입만 export (클라이언트 번들 제외)
    ├── types.ts          # 학원 전용 타입 (Student, Guardian, Consultation 등)
    └── service.ts        # 학원 전용 비즈니스 로직 (서버 전용)
```

Domain

학생(Student)

보호자(Guardian)

반(Class)

수업(Lesson)

출결(Attendance)

청구/수납(Billing)

상담(Consultation)

학습일지(Learning Report)

Billing Mapping Example
교육비
교재비
특별활동비
기타비용

출결 Hook 흐름
출석 체크 → 출결 이벤트 발생 → core-notification → 학부모 알림
→ core-metering → 사용량 기록 → core-billing → 월말 자동청구

Service Layer 연동:
- `@services/student-service`는 `@industry/academy/service`를 래핑하여 제공합니다.
- 클라이언트는 `@services/student-service`를 통해 타입을 import합니다.
- 서버는 `@industry/academy/service`를 직접 사용하거나 `@services/student-service/service`를 사용합니다.

7-2. industry-salon (미용/네일)
Domain

시술 메뉴

예약

고객

멤버십/횟수권

시술 기록

POS 매출

Billing Mapping

시술비

재료비

패키지/회원권

7-3. industry-real-estate (부동산)
Domain

매물

임대/매매 계약

중개 수수료

관리비

입주자 관리

Billing Mapping

중개 수수료

관리비

옵션비

7-4. industry-gym (체육관)
Domain

회원

수련비

도복비

심사비

출결

락커/시설 관리

Billing Mapping

수련비

도복비

심사비

시설 이용료

7-5. industry-ngo (비영리 기관)
Domain

후원자

정기/일시 후원

캠페인

영수증 발행

기부금 영수증

Billing Mapping

정기 후원금

일시 후원금

캠페인 기부금

7-6. Industry 공통 규칙

[불변 규칙] Core Layer는 Industry 모듈에 의존하지 않고, Industry 모듈이 Core를 import하는 단방향 구조(Industry → Core)를 유지한다.

[불변 규칙] Industry Layer는 `packages/industry/industry-{업종}/` 구조로 구현됩니다.

[불변 규칙] Industry Layer의 `index.ts`는 타입만 export하며, 서버 코드는 `/service` 경로에서만 import합니다.

[불변 규칙] Service Layer는 Industry Layer를 래핑하여 제공합니다. 예: `@services/student-service` → `@industry/academy/service`

[불변 규칙] Industry Layer는 Core Party 모델(`core-party`)을 확장하여 사용합니다. 예: `academy_students` 테이블은 `persons` 테이블을 참조합니다.

공통 데이터 스키마(invoices/payments/attendance 등) 사용

업종별 configuration + 템플릿으로 커스터마이징

→ Industry → Core 방향으로 의존하며, Core는 Industry를 모르면 됩니다.

→ Service Layer → Industry Layer → Core Layer 의존성 방향을 유지합니다.

8. Service Layer

React 컴포넌트는 Supabase 쿼리를 직접 실행할 수 없다.
Service Layer가 모든 DB 접근을 캡슐화한다.

⚠️ 중요: Service Layer는 Zero-Trust 아키텍처의 핵심 구성 요소입니다.

8-0. Zero-Trust와 Service Layer 관계 (Critical)

보안 책임 분담 구조:

UI Layer (React 컴포넌트):
- tenant_id를 직접 생성/수정하지 않음
- @api-sdk/core를 통해서만 데이터 요청
- 권한 추론하지 않음

API SDK Layer (@api-sdk/core):
- Context에서 tenant_id, industry_type 자동 가져오기
- 모든 요청에 tenant_id, industry_type, auth token 자동 삽입
- 권한 생성하지 않음
- 에러 처리 및 재시도 정책 관리
- 요청 캐싱 (선택적)
- Edge Function 호출 래핑

Service Layer (@services/*, @industry/*/service):
- tenant_id를 파라미터로 받아서 사용
- withTenant()를 사용하여 쿼리 필터링
- RLS 정책과 함께 2중 필터링 보장
- DB 접근 캡슐화

RLS Layer (PostgreSQL RLS):
- 최종 보안 경계
- JWT claim 기반 tenant_id 필터링
- 권한 결정 및 데이터 격리

보안 흐름:
```
UI → @api-sdk/core (Context에서 tenant_id 가져오기)
  → Service Layer (tenant_id 파라미터로 전달)
  → withTenant() (쿼리 필터링)
  → RLS (최종 보안 검증)
  → DB
```

Service Layer의 보안 책임:
- tenant_id 파라미터 검증 (null/undefined 체크)
- withTenant() 사용 강제 (SELECT/UPDATE/DELETE)
- INSERT 시 tenant_id 직접 포함
- RLS 우회 금지 (Service Role Key 사용 시에도 RLS 정책 준수)

8-1. 규칙

Service만 Supabase 쿼리를 수행

React → Hook → Service 순서

Service는 항상 tenant_id를 강제로 주입

Service는 RLS를 우회하지 않는다

복잡 쿼리는 Edge Function 사용

8-2. 예시 코드
// attendance-service
import { withTenant } from '../_db';

export const attendanceService = {
  async checkIn(tenantId, studentId) {
    // INSERT는 tenant_id를 row object에 직접 포함
    return supabase
      .from('attendance_logs')
      .insert({
        tenant_id: tenantId,
        student_id: studentId,
        occurred_at: new Date()
      });
  },

  async list(tenantId, filters) {
    // SELECT는 반드시 withTenant() 사용
    return withTenant(
      supabase
      .from('attendance_logs')
      .select('*')
        .order('occurred_at', { ascending: false }),
      tenantId
    );
  }
}

8-2-1. 서비스 공통 쿼리 가드 (Critical)

// services/_db.ts
export function withTenant<T>(q: PostgrestFilterBuilder<T>, tenantId: string) {
  return q.eq('tenant_id', tenantId);
}

// 사용 예
return withTenant(
  supabase.from('students').select('*').order('created_at', { ascending: false }),
  tenantId
);

8-2-2. Supabase 커넥션 풀링/쿼리 가드 (Critical)

테넌트/앱 수 증대 시 커넥션 고갈·큐잉 위험 방지:

pgbouncer(세션/트랜잭션 모드) 상정, Edge/Lambda 동시접속 상한치 문서화

서비스 레이어 공통 래퍼에 타임아웃 강제:

가능하면 DB 레벨 기본값으로 설정하고, 필요 시 Edge Function에서 쿼리 직전에 SET LOCAL을 쓰는 형태로 적용한다.

-- 세션 가드 (로그인 직후, 또는 서비스 커넥션 초기화 시)
-- 주의: Supabase PgBouncer 풀링 모드에서는 세션 레벨 SET이 제한될 수 있음
SET statement_timeout = '8s';
SET idle_in_transaction_session_timeout = '3s';
SET lock_timeout = '2s';

실패 시 재시도 정책(지수 백오프)과 결제/웹훅 재처리와의 중복 방지 로직 연결 (14-2-1 참조)

→ 커넥션 풀 관리 및 쿼리 타임아웃은 대규모 운영 필수

8-3. 에러 핸들링 전략 (Critical)

Service Layer 에러 분류:

ValidationError: 입력값 검증 실패 (400 Bad Request)

NotFoundError: 리소스 없음 (404 Not Found)

PermissionError: 권한 없음 (403 Forbidden)

ConflictError: 리소스 충돌 (409 Conflict)

RateLimitError: 요청 한도 초과 (429 Too Many Requests)

InternalError: 서버 내부 오류 (500 Internal Server Error)

에러 응답 표준화:

모든 Service 함수는 표준 에러 객체 반환

클라이언트에는 민감 정보 노출 금지 (예: DB 에러 메시지 숨김)

에러 로깅:

모든 에러는 audit.events에 기록 (InternalError는 즉시 알림)

에러 로그 및 audit.events에는 PII(이름, 전화번호, 이메일 등)를 직접 남기지 않는다.

필요한 경우 식별 가능한 최소 단위(ID, hash, key_version 등)만 기록한다.

PII 최소화 강제 규칙:

audit.events.meta에 PII 금지 룰 추가 (정규식 마스킹 후 삽입)

ESLint/TS Rule: logger.* 호출 시 PII 타입 경고

19-6-1. PII 마스킹 유틸리티 (Critical)

⚠️ 중요: 상용화 단계에서는 마스킹만으로 충분하며, 모든 PII 마스킹 유틸리티는 중앙 모듈에 정의되어야 합니다.

[불변 규칙] PII 마스킹 유틸리티는 packages/core/pii-utils 또는 packages/core-config/pii-utils에 정의하며, 모든 애플리케이션(academy-admin, academy-parent 등)에서 일관되게 사용합니다.

마스킹 유틸리티 위치:

packages/core/pii-utils/src/index.ts

또는

packages/core-config/pii-utils/src/index.ts

마스킹 유틸리티 정의:

export const maskPhone = (phone: string | null | undefined): string => {
  if (!phone) return '';
  // 010-1234-5678 → 010-****-5678
  return phone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
};

export const maskEmail = (email: string | null | undefined): string => {
  if (!email) return '';
  // user@example.com → u***@example.com
  return email.replace(/(^.).*(@.*$)/, '$1***$2');
};

export const maskName = (name: string | null | undefined): string => {
  if (!name) return '';
  // 홍길동 → 홍*동
  if (name.length <= 2) return name.charAt(0) + '*';
  return name.charAt(0) + '*'.repeat(name.length - 2) + name.charAt(name.length - 1);
};

export const maskPII = (data: any): any => {
  if (typeof data === 'string') {
    // 이메일 마스킹
    data = data.replace(/(^.).*(@.*$)/, '$1***$2');
    // 전화번호 마스킹
    data = data.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
  }
  return data;
};

→ 감사 로그의 PII 최소화는 법적 요구사항

재시도 정책:

재시도 가능: NetworkError, TimeoutError, RateLimitError

재시도 불가능: ValidationError, PermissionError, NotFoundError

구현 예시:

export class AppError extends Error {
  constructor(
    public code: string,
    public statusCode: number,
    message: string,
    public isRetryable: boolean = false
  ) {
    super(message);
  }
}

export const handleServiceError = (error: unknown) => {
  if (error instanceof AppError) {
    // 클라이언트용 안전한 메시지
    return { code: error.code, message: error.message };
  }
  // 예상치 못한 에러는 InternalError로 처리
  logger.error('Unexpected error', error);
  return { code: 'INTERNAL_ERROR', message: 'An error occurred' };
};

Supabase PostgREST Error 변환:

Supabase PostgREST error (code, message, details, hint)는 AppError로 변환해 statusCode · isRetryable을 명시적으로 설정해야 한다.

예시:

const mapPostgrestError = (error: PostgrestError): AppError => {
  const code = error.code;
  if (code === '23505') return new AppError('CONFLICT', 409, error.message, false);
  if (code === '23503') return new AppError('NOT_FOUND', 404, error.message, false);
  // ... 기타 에러 코드 매핑
  return new AppError('INTERNAL_ERROR', 500, error.message, false);
};


→ 실무에서 필수적인 에러 처리 전략

8-4. Service vs Edge Key 경계 명문화

Layer	허용 Key	설명
Service Layer	anon/auth	RLS 우회 금지
Edge Functions	Service Role	Webhook·배치·서명 검증용

클라이언트에서 tenant_id 전달값 신뢰 금지

⚠️ Deprecated: Edge Function에서 set_config 사용은 더 이상 권장하지 않습니다.

✅ 대신: JWT claim 기반 RLS를 사용하세요 (PART 1의 3-1-1 섹션 참조)

❌ 금지 예시:
```typescript
// ⚠️ 레거시 예시: Transaction Pooling에서는 작동하지 않음
// Edge Function에서 set_config 사용 (더 이상 사용하지 않음)
await supabase.rpc('set_config', {
  key: 'app.current_tenant_id',
  value: verified_tenant_id
});
```

✅ 권장 예시:
```typescript
// ⚠️ 중요: x-tenant-id 헤더를 넣는다고 JWT claim이 자동으로 바뀌는 것은 아닙니다.
// JWT claim은 서버/Edge Function에서 tenant 선택 시 명시적으로 재발급해야 합니다.
//
// 올바른 흐름:
// 1. tenant 선택 → 서버/Edge Function에서 JWT 재발급 (claim에 tenant_id 포함)
// 2. 세션 새로고침으로 업데이트된 JWT 받기
// 3. RLS 정책에서 auth.jwt() ->> 'tenant_id'로 자동 읽기
//
// x-tenant-id 헤더는 Middleware에서 tenant 매핑용으로만 사용하며,
// JWT claim 갱신은 별도의 인증 엔드포인트에서 처리합니다.
```

9. Hooks Layer (React Query)

각 Service 호출은 Hook으로 래핑되어 UI에서 사용한다.

예:

useAttendanceList
useCheckIn
useInvoices
useNotifications
useTenantSettings


Hook은 다음 기능 제공:

로딩 상태

캐싱

에러 핸들링

refetch 정책

10. core-ui 설계

10-1. 기본 컴포넌트

DataTable, TableCardView, SplitTableLayout 등 기본 컴포넌트는 기존 설계를 따릅니다.

10-2. 지도(Geo) 기반 UI 패턴 (상용화 단계)

⚠️ 중요: 이 섹션은 상용화 단계에서 도입하는 기능입니다.

// packages/ui-core/src/... (예시)
type MapMetricMode =
  | 'store-density'      // 매장 수
  | 'revenue-avg'        // 평균 매출
  | 'members-avg';       // 평균 회원수

interface MapViewProps {
  center?: { lat: number; lng: number };
  zoom?: number;
  metricMode: MapMetricMode;
  // region 단위 히트맵 데이터 (⚠️ 중요: 정본은 `location_code`, `region_code`는 내부 매핑용 alias)
  regionMetrics?: Array<{
    regionCode: string;
    value: number;
  }>;
  // 내 매장 위치 표시용
  myStores?: Array<{
    storeId: string;
    lat: number;
    lng: number;
  }>;
}

반응형 레이아웃:

Desktop: 지도 + 우측 KPI 카드/테이블 (Split layout)

Tablet: 지도 상단 / KPI 하단 (vertical split)

Mobile:
- 기본은 KPI 카드 리스트
- 지도는 "지도 보기" 버튼으로 풀스크린 모달로 전환

→ useResponsiveMode()와 함께 레이아웃 패턴을 명시합니다.

지도 데이터 소스:

지도에서 사용하는 색상/히트맵 값은 analytics.daily_region_metrics의 최근 N일 평균 혹은 선택 기간 평균.

매장 위치 마커는 core_stores.latitude/longitude.

// services/analytics-service.ts
export const analyticsService = {
  async getRegionHeatmap(industryType: string, dateKst: string) {
    // ⚠️ 중요: 정본은 `location_code`, `region_code`는 내부 매핑용 alias
    return supabase
      .from('analytics.daily_region_metrics')
      .select('region_level, region_code, revenue_avg, active_members_avg, store_count')
      .eq('industry_type', industryType)
      .eq('date_kst', dateKst)
      .eq('region_level', 'dong'); // or 'gu_gun', 'si', etc
  },
};
⚠️ 중요: UI/UX 규약(반응형, 다크모드, Zoom, 접근성 등)의 정식 출처는 〈UI/UX Technical Architecture〉 문서입니다.

→ 상세 규칙은 UI/UX 문서의 "6. Responsive UX — Enterprise Version" 섹션을 참조하세요.

주요 컴포넌트 (core-ui 패키지):

DataTable

TableCardView (모바일 전용)

SplitTableLayout (태블릿 전용)

FormField

Drawer / Modal

⚠️ 중요: 모달 사용 규칙 (Critical)

[불변 규칙] 모든 알림/경고/확인 대화상자는 커스텀 모달을 사용해야 합니다.

❌ 금지:
- window.alert()
- window.confirm()
- window.prompt()

✅ 허용:
- useModal().showAlert(message, title?, type?)
- useModal().showConfirm(message, title?)
- 커스텀 Modal 컴포넌트

이유:
1. 일관된 UX: 모든 알림이 동일한 디자인 시스템 사용
2. 접근성: 커스텀 모달은 접근성 개선 가능
3. 모바일 최적화: 모바일에서 네이티브 alert는 부자연스러움
4. 테마 지원: 다크모드, 테넌트 테마 적용 가능
5. i18n 지원: 다국어 메시지 지원

모달 vs 페이지 선택 기준:
- 모달: 간단한 수정 작업, 목록에서 빠른 액션, 확인/알림 메시지, 모바일 환경
- 페이지: 복잡한 작업, 독립적인 작업 흐름, 상세 정보 조회, URL 공유 필요

→ 상세 가이드라인은 `docu/전체 유아이문서.txt`의 "6-2. 모달 vs 페이지 선택 기준" 섹션 참조

AppShellLayout

SearchBar

ActionHeader

11. 반응형 UX 전략 (요약)

⚠️ 중요: 반응형 UX 상세 규칙은 〈UI/UX Technical Architecture〉 문서의 "6. Responsive UX — Enterprise Version" 섹션을 참조하세요.

11-0. 반응형 브레이크포인트 표준 (Critical)

⚠️ 중요: 모든 반응형 구현은 다음 브레이크포인트 숫자 체계를 사용합니다 (⚠️ 참고: "Tailwind"는 브레이크포인트 숫자 체계의 개념적 참조이며, Tailwind 클래스 문자열 직접 사용은 금지):

브레이크포인트 수치 (고정 값):

| 브레이크포인트 | 최소 너비 | 용도 |
|--------------|----------|------|
| xs (기본) | 0px | 모바일 (기본) |
| sm | 640px | 큰 모바일 / 작은 태블릿 |
| md | 768px | 태블릿 |
| lg | 1024px | 작은 데스크톱 |
| xl | 1280px | 큰 데스크톱 |

→ 이 브레이크포인트 수치는 디자인팀/프론트엔드팀/백엔드팀 간 일관성을 보장하기 위한 표준입니다.

핵심 원칙:

useResponsiveMode() 훅 사용 필수

기기별 테이블 전략:
- 휴대폰 (xs, sm): TableCardView (행 → 카드)
- 태블릿 (md): compact table or SplitTableLayout
- PC (lg, xl): DataTable (고정 헤더 + 수평 스크롤)

터치 타깃 최소 44px 보장 (확대 125% 이상 시에도 적용)

다크모드 및 UI 확대(Zoom) 지원 필수

→ 상세 규칙은 UI/UX 문서 참조

→ 모바일 UX 성능 및 가독성 보장

11-3. 태블릿 SplitTableLayout

좌측: 테이블/카드 목록
우측: 상세 패널(고정, 최소 폭 ≥ 360px)

키보드/펜 입력 포커스 유지 정책 명시

→ 아이패드/태블릿 UX 최적화

12. 다크모드
ThemeProvider 제공

light/dark 테마 토큰 사용

OS 설정 자동 감지

사용자 override 가능

CSS 변수 예 (⚠️ Tailwind 클래스 문자열 직접 사용 금지):
- var(--color-background)
- var(--color-foreground)
- var(--color-border)
- var(--color-card)
- ⚠️ 참고: 위는 CSS 변수 예시이며, 실제 Tailwind 클래스 문자열(예: `bg-background`, `text-foreground`)은 문서 예시에서 사용하지 않습니다.

13. UI 확대(Zoom)

ZoomContext에서 확대값 제공:

100%

110%

125%

150%

모든 컴포넌트는 px 값 직접 지정 금지
→ 토큰 기반으로 비율 자동 적용

확대 125% 이상 시:

행 높이/아이콘 터치 타깃 44px 보장

텍스트 가독성 유지 (최소 폰트 크기 14px)

→ 접근성 요구사항 준수

📘 PART 3
결제·알림뱅킹 / Public Gateway / Analytics / 배치(04:00 KST) / 통계
14. 결제 & 알림뱅킹 흐름
14-1. payment-alimbank 모듈

효성FMS 알림뱅킹과의 연동은 다음 역할을 수행하는 Provider 모듈에서 담당한다.

결제 요청 Payload 생성

알림뱅킹/PG URL 또는 QR 코드 생성

응답 검증(서명·HMAC 검증)

상태 매핑 (성공/실패/취소)

멱등성 보장(Idempotency Key)

오류/지연에 대한 재시도 정책

14-1-1. 결제/알림뱅킹 Provider Retry Matrix (Critical)

PG사·효성FMS의 API 실패/지연/타임아웃에 대한 표준 Retry 정책:

Failure Type	처리 방식	재시도 횟수	백오프 전략
Timeout	재시도	3회	5초, 15초, 30초 (지수 백오프)
Signature mismatch	즉시 중단	0회	재시도 불가 (보안 위반)
PG internal error (5xx)	재시도	3회	5초, 30초, 120초 (지수 백오프)
Duplicate payment	멱등성 키로 차단	0회	재시도 불가 (이미 처리됨)
Network error (ECONNRESET 등)	재시도	3회	즉시, 5초, 15초
Rate limit (429)	재시도	2회	60초, 120초 (고정 대기)
Invalid request (4xx, 서명 제외)	즉시 중단	0회	재시도 불가 (클라이언트 오류)

구현 예시:

```typescript
async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries: number,
  backoffMs: number[]
): Promise<T> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (isNonRetryableError(error)) throw error;
      if (i < maxRetries - 1) {
        await sleep(backoffMs[i] || backoffMs[backoffMs.length - 1]);
      }
    }
  }
  throw new Error('Max retries exceeded');
}
```

구조 예시:

// packages/payments/payment-alimbank/index.ts

export const alimbankProvider = {
  async createPaymentRequest(invoice) { ... },
  async verifyWebhookSignature(headers, rawBody) { ... },
  async mapStatus(alimbankStatus) { ... }
}

14-2. Edge Function 연동 (Server Side)
fns-payment-alimbank-request

역할

invoice_id 기반으로 결제 요청 생성

알림뱅킹 API 호출

PG URL/QR 반환

상태 Pending 설정

흐름

클라이언트에서 /pay/:invoice_id 호출

Edge Function에서 invoice 조회 (tenant_id 포함)

alimbankProvider로 결제 요청 생성

요청 성공 시:

payments 테이블 Pending 상태 row 생성

클라이언트로 결제 URL/QR 반환

fns-payment-alimbank-webhook

역할

알림뱅킹/PG에서 보내는 결제 결과 수신

서명 검증 + 멱등성 처리

payments 상태 업데이트

invoices 상태 업데이트

core-notification 트리거

analytics 집계용 이벤트 기록

보안/멱등성 조건

x-signature, x-timestamp, idempotency-key 헤더 필수

타임스탬프는 KST 기준 ±5분 윈도우 안이어야 유효

idempotency-key 단위로 중복 처리 방지

14-2-1. Webhook 멱등성 인덱스 및 재시도 표준화

audit.webhook_events 테이블 정의:

CREATE TABLE audit.webhook_events (
  id bigserial primary key,
  provider text not null,
  idempotency_key text not null,
  status text not null,            -- 'success','failed','retrying' 등
  payload jsonb,
  event_timestamp timestamptz,       -- 웹훅에서 받은 원본 타임스탬프
  received_at timestamptz default now(),  -- 우리 시스템에서 받은 시각
  created_at timestamptz default now()
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_webhook_idem
  ON audit.webhook_events(provider, idempotency_key);

CREATE INDEX idx_webhook_timestamp
  ON audit.webhook_events(provider, event_timestamp);

재시도 백오프 : 5s → 30s → 2m → 10m → 30m (최대 5회)

대시보드 지표 : 실패율 / 멱등충돌률 / 지연 P95

14-2-1-1. 결제/알림뱅킹 운영 정책 (핀테크 수준 필수)

⚠️ 중요: SaaS Billing에서 가장 중요한 "실운영 안정성"을 보장하기 위한 핵심 정책입니다.

1. Webhook Idempotency 강화:

[불변 규칙] 모든 webhook 이벤트는 반드시 idempotency_key 기반 중복 처리 방지를 수행합니다.

중복 이벤트 처리 로직:
```typescript
async function processWebhook(provider: string, idempotencyKey: string, event: WebhookEvent) {
  // 1. 중복 체크 (트랜잭션 내에서)
  const existing = await db.findWebhookEvent(provider, idempotencyKey);
  if (existing && existing.status === 'success') {
    return { status: 'duplicate', event: existing }; // 이미 처리된 이벤트
  }

  // 2. 동시 처리 방지 (SELECT FOR UPDATE)
  const locked = await db.lockWebhookEvent(provider, idempotencyKey);
  if (!locked) {
    throw new Error('Event is being processed by another worker');
  }

  // 3. 이벤트 처리
  try {
    await processPaymentEvent(event);
    await db.updateWebhookEvent(provider, idempotencyKey, 'success');
  } catch (error) {
    await db.updateWebhookEvent(provider, idempotencyKey, 'failed');
    throw error;
  }
}
```

2. Duplicate Event 처리:

[불변 규칙] 동일 idempotency_key로 수신된 이벤트는 첫 번째 이벤트만 처리하고, 이후 이벤트는 무시합니다.

Duplicate 감지 기준:
- idempotency_key 동일
- provider 동일
- event_timestamp 차이 ±5분 이내

Duplicate 처리 정책:
- 첫 번째 이벤트: 정상 처리
- 이후 이벤트: audit.webhook_events에 'duplicate' 상태로 기록, 처리하지 않음

3. Settlement Mismatch Reconciliation (정산 불일치 조정):

[불변 규칙] 결제/알림뱅킹 webhook과 실제 정산 데이터 간 불일치가 발생하면 자동으로 감지하고 수동 조정 UI를 제공합니다.

⚠️ 중요: 정산 불일치 조정 상세 정책은 아래 "5. 회계적 정합성 검증" 및 "6. 수동 조정 UI 요구사항" 섹션을 참조하세요.

정산 불일치 감지:
```sql
-- 일별 정산 불일치 조회
SELECT
  DATE(event_timestamp) as settlement_date,
  provider,
  SUM(CASE WHEN status = 'success' THEN amount ELSE 0 END) as webhook_total,
  (SELECT SUM(amount) FROM settlement_records
   WHERE provider = w.provider AND date = DATE(w.event_timestamp)) as settlement_total,
  ABS(webhook_total - settlement_total) as mismatch_amount
FROM audit.webhook_events w
WHERE event_timestamp >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY DATE(event_timestamp), provider
HAVING ABS(webhook_total - settlement_total) > 0.01; -- 1원 이상 차이
```

자동 조정 정책:
- 불일치 금액 < 1,000원: 자동 조정 (로그 기록)
- 불일치 금액 ≥ 1,000원: 수동 조정 UI에서 승인 필요

4. 결제 실패 자동 재시도:

[불변 규칙] 결제 실패 시 지수 백오프 패턴으로 자동 재시도하며, 최대 재시도 횟수와 재시도 간격을 명확히 정의합니다.

재시도 정책:
- 재시도 횟수: 최대 5회
- 재시도 간격: 5s → 30s → 2m → 10m → 30m
- 재시도 조건: 네트워크 오류, 타임아웃, 일시적 서버 오류만 재시도
- 재시도 제외: 인증 실패, 잔액 부족, 카드 정지 등 영구적 오류는 즉시 실패 처리

재시도 로직:
```typescript
async function retryPayment(paymentId: string, attempt: number = 1) {
  const maxAttempts = 5;
  const backoff = [5000, 30000, 120000, 600000, 1800000]; // ms

  try {
    const result = await processPayment(paymentId);
    return result;
  } catch (error) {
    if (isRetryableError(error) && attempt < maxAttempts) {
      await sleep(backoff[attempt - 1]);
      return retryPayment(paymentId, attempt + 1);
    }
    throw error;
  }
}
```

5. 회계적 정합성 검증 (정산 불일치 조정 정책 통합):

[불변 규칙] 모든 결제/수납/환불 거래는 회계적 정합성을 검증하며, 불일치 시 즉시 알림을 발송합니다.

정합성 검증 항목:
- 입금액 = 출금액 (거래 총합)
- 미정산 금액 = 정산 예정 금액
- 환불 금액 ≤ 원거래 금액
- 중복 결제 없음

검증 주기:
- 실시간 검증: 모든 거래 처리 시
- 일별 검증: 매일 04:00 KST
- 월별 검증: 매월 1일 04:00 KST

정산 불일치 감지 및 조정:
- 위 "3. Settlement Mismatch Reconciliation" 섹션 참조

6. 수동 조정 UI 요구사항:

[불변 규칙] 운영팀이 결제/정산 불일치를 수동으로 조정할 수 있는 UI를 제공합니다.

수동 조정 UI 기능:
- 정산 불일치 목록 조회 (날짜별, 업체별 필터)
- 불일치 상세 내역 확인 (webhook 이벤트 vs 정산 데이터 비교)
- 수동 조정 승인/거부 (승인 시 audit.events에 기록)
- 조정 이력 조회 (누가, 언제, 무엇을 조정했는지)

수동 조정 권한:
- Super Admin만 수동 조정 가능
- 모든 조정 작업은 audit.events에 기록
- 조정 전후 금액 비교 리포트 생성

7. 실시간 모니터링:

[불변 규칙] 결제/알림뱅킹 시스템의 실시간 상태를 모니터링하고, 이상 징후 시 즉시 알림을 발송합니다.

모니터링 지표:
- Webhook 수신 지연률 (P95, P99)
- Webhook 실패율 (5분 이동평균)
- 정산 불일치 건수 (일별)
- 재시도율 (전체 요청 대비)
- 중복 이벤트율

알림 임계값:
- Webhook 실패율 > 5%: 즉시 알림
- 정산 불일치 금액 > 10,000원: 즉시 알림
- 재시도율 > 20%: 경고 알림
- 중복 이벤트율 > 1%: 경고 알림

8. 부분 실패 보정 로직:

[불변 규칙] 결제/알림뱅킹 처리 중 일부 단계만 실패한 경우, 완료된 단계는 롤백하지 않고 부분 성공 상태로 기록하며, 실패한 단계만 재시도합니다.

부분 실패 시나리오:
- Webhook 수신 성공 → DB 저장 실패: Webhook은 재수신 불가하므로 DB 저장만 재시도
- 결제 처리 성공 → 알림 발송 실패: 결제는 유지하고 알림만 재시도
- 정산 기록 성공 → 리포트 생성 실패: 정산은 유지하고 리포트만 재시도

부분 실패 처리 로직:
```typescript
async function processPaymentWithPartialFailure(paymentId: string) {
  const steps = [
    { name: 'webhook_received', fn: () => saveWebhookEvent(paymentId) },
    { name: 'payment_processed', fn: () => processPayment(paymentId) },
    { name: 'notification_sent', fn: () => sendNotification(paymentId) },
    { name: 'settlement_recorded', fn: () => recordSettlement(paymentId) },
  ];

  const completedSteps = [];
  const failedSteps = [];

  for (const step of steps) {
    try {
      await step.fn();
      completedSteps.push(step.name);
    } catch (error) {
      failedSteps.push({ step: step.name, error });
      // 부분 실패 상태로 기록
      await recordPartialFailure(paymentId, completedSteps, failedSteps);
      break; // 실패한 단계에서 중단
    }
  }

  // 실패한 단계만 재시도
  if (failedSteps.length > 0) {
    await retryFailedSteps(paymentId, failedSteps);
  }
}
```

9. 결제 취소 / 재요청 정책:

[불변 규칙] 결제 취소는 원거래와 연결하여 처리하며, 재요청은 멱등성 키를 재사용하여 중복 결제를 방지합니다.

결제 취소 정책:
- 취소 가능 기간: 결제 완료 후 7일 이내 (업체별 정책에 따라 조정)
- 취소 처리: 원거래와 연결하여 환불 처리, audit.events에 취소 사유 기록
- 부분 취소: 지원하지 않음 (전액 취소만 가능)

결제 재요청 정책:
- 재요청 시 동일 idempotency_key 사용: 중복 결제 방지
- 재요청 가능 횟수: 최대 3회
- 재요청 간격: 최소 1분 (스팸 방지)

재요청 로직:
```typescript
async function retryPaymentRequest(paymentId: string, reason: string) {
  const originalPayment = await getPayment(paymentId);

  // 동일 idempotency_key로 재요청
  const retryPayment = await createPayment({
    ...originalPayment,
    idempotency_key: originalPayment.idempotency_key, // 재사용
    retry_count: originalPayment.retry_count + 1,
    retry_reason: reason,
  });

  if (retryPayment.retry_count > 3) {
    throw new Error('Maximum retry count exceeded');
  }

  return retryPayment;
}
```

10. 알림뱅킹 장애 대비 Fallback 처리:

[불변 규칙] 알림뱅킹 서비스 장애 시 자동으로 대체 채널(SMS)로 전환하거나, 장애 복구 후 재시도 큐에 추가합니다.

Fallback 전략:
- 1차: 알림뱅킹 API 호출
- 2차 (장애 시): SMS 발송 (core-notification 모듈)
- 최종 (모든 채널 실패): 재시도 큐에 추가 (최대 24시간 보관)

Fallback 처리 로직:
```typescript
async function sendNotificationWithFallback(userId: string, message: string) {
  const channels = [
    { name: 'alimbank', fn: () => sendAlimbankNotification(userId, message) },
    { name: 'sms', fn: () => sendSMS(userId, message) },
  ];

  for (const channel of channels) {
    try {
      await channel.fn();
      await recordNotificationSuccess(userId, channel.name);
      return { success: true, channel: channel.name };
    } catch (error) {
      await recordNotificationFailure(userId, channel.name, error);
      // 다음 채널로 Fallback
      continue;
    }
  }

  // 모든 채널 실패 시 재시도 큐에 추가
  await addToRetryQueue(userId, message, { maxRetries: 5, ttl: 24 * 60 * 60 * 1000 });
  return { success: false, queued: true };
}
```

장애 감지 기준:
- 알림뱅킹 API 응답 시간 > 5초: 장애로 간주
- 알림뱅킹 API 에러율 > 10% (5분 이동평균): 장애로 간주
- 알림뱅킹 API 5xx 에러: 즉시 Fallback

장애 복구 감지:
- 알림뱅킹 API 정상 응답 3회 연속: 장애 복구로 간주
- Fallback 모드 해제 후 재시도 큐 처리 시작

14-2-2. Webhook 이벤트 순서 보장 (상용화 단계 선택적)

⚠️ 중요: 이 섹션은 상용화 단계에서 선택적으로 도입하는 기능입니다.

상용화 단계에서는 멱등성 처리를 기본으로 하며, 실제 필요성이 확인된 경우에만 순서 보장을 도입합니다.

핀테크 프로젝트에서는 Idempotency + Ordering Guarantee(순서 보장) 모두 필요하지만, "학원관리 SaaS에서 알림뱅킹만 지원"하는 경우 멱등성 + 서명 검증만으로 충분합니다.

Ordering Guarantee가 필요한 경우 (상용화 단계):

문제: retry 때문에 success → pending 같은 순서로 도착할 수 있음

해결책:

상태 전이 규칙 정의(State transition machine):

pending → success (허용)

success → pending (거부, late event drop)

success → cancelled (허용)

cancelled → success (거부, late event drop)

timestamp 비교:

event_timestamp가 기존 상태의 event_timestamp보다 이전이면 late event로 간주하여 무시

late event drop 로직:

```typescript
async function processWebhook(provider: string, idempotencyKey: string, event: WebhookEvent) {
  const existing = await db.findWebhookEvent(provider, idempotencyKey);

  if (existing) {
    // 순서 보장 검증 (상용화 단계 선택적)
    if (event.timestamp < existing.event_timestamp) {
      // late event, 무시
      return { status: 'ignored', reason: 'late_event' };
    }

    // 상태 전이 규칙 검증
    if (!isValidTransition(existing.status, event.status)) {
      return { status: 'rejected', reason: 'invalid_transition' };
    }
  }

  // 처리 진행...
}
```

→ 상용화 단계에서는 멱등성 처리를 기본으로 하며, Ordering Guarantee는 실제 필요성이 확인된 후 도입합니다.

14-3. Public Gateway UX

apps/public-gateway/는 로그인 없이 접근 가능한 공개 페이지 집합이다.

주요 시나리오

청구서 조회(링크/QR)

결제 진행

결제 결과 안내

키오스크/데스크용 출결 화면 (숫자패드, QR체크 등)

보안 원칙

Public Gateway 보안 정책은 14-3-1 (Verification Gateway Pattern) 및 19-8 (Public Gateway/키오스크 보안) 섹션을 참조한다.

invoice_id를 URL에 직접 노출하지 않고 서명 토큰 기반으로 식별

signed token 기반 invoice 접근 (Critical)

Public Gateway 접근 시 다음을 반드시 추가:

1) Signed token 기반 invoice 접근

예시: /invoice/:signed_token (친구에게 링크 공유해도 유출 불가)

토큰 스펙 (JWT/HMAC):

알고리즘: HMAC-SHA256

만료 시간: 10분 (KST 기준)

클레임 구조:

{
  "iss": "dearsaas",
  "aud": "public-gateway",
  "sub": "invoice:<uuid>",
  "tenant_id": "<uuid>",
  "scope": ["invoice.read","payment.create"],
  "exp": <unix_KST_plus_600s>,
  "jti": "<random-uuid>"
}

토큰 생성: HMAC-SHA256(invoice_id + tenant_id + timestamp, secret_key)

토큰 검증: Edge Function에서 서명 검증 후 invoice_id 추출

시계 드리프트 허용: ±120s

2) URL 만료 정책

상용화 단계: 만료 시간 10분으로 짧게 설정하여 재사용 방지 (만료 시간으로 현실적으로 커버)

상용화 단계: Edge KV / audit.public_tokens 기반 재사용 방지 및 rate-limit 도입

→ Edge KV / audit.public_tokens 기반 재사용 방지와 rate-limit는 상용화 단계에서 도입 가능합니다. 만료시간 짧은 signed token만으로도 리스크를 수용합니다.

14-3-2. Public Gateway Token 회수 정책 (Critical, 상용화 단계 고도화)

⚠️ 중요: 이 섹션의 고급 기능은 상용화 단계에서 도입합니다.

상용화 단계: 만료 시간 10분으로 짧게 설정하여 재사용 방지 (만료 시간으로 현실적으로 커버)

상용화 단계: Used Token의 즉시 폐기

사용된 토큰은 DB 또는 KV에 즉시 기록하여 재사용 차단

잠재 중복 공격 패턴 분석:

같은 jti로 짧은 시간 내 다수 요청 시 차단

같은 invoice_id에 대한 토큰 재사용 시도 감지

단일 invoice 조회 시 rate-limit 필요:

같은 invoice_id에 대한 조회는 1분당 최대 10회 제한

IP 기반 rate-limit: 1분당 최대 30회

→ 상용화 단계에서는 서명 검증 + exp(만료) + jti만 적용하고, 재사용 방지는 짧은 만료 시간(10분)으로 현실적으로 커버합니다.

구현 예시:

```typescript
async function verifyPublicToken(token: string, invoiceId: string) {
  // 1. 토큰 검증
  const payload = await verifyToken(token);

  // 2. 사용 여부 확인
  const used = await kv.get(`token:${payload.jti}`);
  if (used) {
    throw new Error('Token already used');
  }

  // 3. Rate limit 확인
  const rateLimitKey = `rate:invoice:${invoiceId}`;
  const count = await kv.incr(rateLimitKey);
  if (count === 1) {
    await kv.expire(rateLimitKey, 60); // 1분 TTL
  }
  if (count > 10) {
    throw new Error('Rate limit exceeded');
  }

  // 4. 토큰 사용 기록
  await kv.set(`token:${payload.jti}`, 'used', { ex: 600 });

  return payload;
}
```

저장소 정책 (표준):

기본 저장소: Edge KV (Redis 기반) - 빠른 조회, TTL 자동 관리 (권장)

선택 저장소: audit.public_tokens 테이블 - 영구 기록, 감사 추적 필요 시에만 사용

→ 기본은 Edge KV로 통일하고, audit 테이블은 "선택적 + 감사용"으로 사용

audit.public_tokens 테이블 정의 (옵션 2 사용 시):

CREATE TABLE audit.public_tokens (
  id bigserial primary key,
  token_jti text not null,           -- JWT jti 또는 토큰 해시
  tenant_id uuid,
  resource_type text,                  -- 'invoice', 'kiosk', 'qr' 등
  resource_id text,
  used_at timestamptz,
  created_at timestamptz default now(),
  expires_at timestamptz
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_public_tokens_jti
  ON audit.public_tokens(token_jti);

CREATE INDEX IF NOT EXISTS idx_public_tokens_expires
  ON audit.public_tokens(expires_at);

옵션 3: JWT jti 기반 revoke 리스트 - JWT 사용 시

14-3-1. Verification Gateway Pattern (Critical)

모든 Public Gateway 요청은 fns-public-gateway-verify를 통해 서명 검증 후 내부 API로 전달하는 단일 진입점 구조(Verification Gateway Pattern)를 사용한다.

구조:

/invoice/:token → fns-public-gateway-verify → 검증 성공 시 invoice_id 반환 → 내부 API 호출

/kiosk/:token → fns-public-gateway-verify → 검증 성공 시 tenant_id 반환 → 내부 API 호출

/qr/:token → fns-public-gateway-verify → 검증 성공 시 resource_id 반환 → 내부 API 호출


장점:

각 페이지마다 개별 검증 로직을 넣을 필요 없음 (실수 발생 확률 감소)

보안의 "최종 관문"이 단일 지점에 집중

프록시 패턴으로 보안 사고 가능성 크게 감소

주의사항:

Verification Gateway는 Public Gateway의 단일 진입점이므로, 장애 시 전체 Public UX에 영향이 갈 수 있다.

완화 전략:

다중 배포/헬스체크/자동 롤백 전략 필수 적용

읽기 전용 페이지는 CDN으로 바로 제공하고, 토큰 검증이 필요한 엔드포인트만 이 Gateway를 거치도록 구분

RLS 우회 권한:

Verification Gateway는 Public Gateway의 단일 진입점이므로, 토큰 검증 후 내부 API 호출 시 적절한 DB Role을 사용해야 한다.

일반적으로 public_gateway_role 또는 verification_role을 사용하며, 해당 Role은 필요한 테이블(invoices, payments 등)에 대한 최소 권한만 부여한다.

→ Public Gateway 특성상 거의 필수적 아키텍처 패턴이지만, 단일 장애점(SPOF) 완화 전략 필수

CSRF 방어 (POST 요청 시 토큰)

Clickjacking 방지(X-Frame-Options, CSP)

Referrer 최소화(Referrer-Policy: no-referrer)

시간 표시 정책:

상세 KST 표준은 PART 5의 '19-1. 타임존(KST) 표준' 섹션 규칙을 따른다.

청구일, 납부기한, 결제시간 등 Public Gateway에 노출되는 시간은 모두 KST 기준으로 표기한다.

→ 결제/청구 시스템에서 매우 중요한 보안 요소

14-4. 키오스크 모드 (태블릿/모바일)

UI는 core-ui의 KioskLayout 컴포넌트 사용

기능 예:

번호 입력 후 출결 체크

QR/바코드 스캔 (브라우저 카메라 API)

결제용 QR 노출

자동 로그아웃/세션 만료 타이머 (예: 10분 무입력 시 자동 잠금, KST 기준 세션 관리)

15. Analytics & 통계

15-0. Analytics UI 구성 규약 (Critical)

⚠️ 중요: Analytics UI 구성 규약은 디자인팀/프론트엔드팀 간 일관성을 보장하기 위한 표준입니다.

15-0-1. 차트 표준

도넛 차트 (Donut Chart):
- 용도: 비율 표시 (예: 결제 수단 비율, 업종별 분포)
- 색상: Theme Token의 `colors.chart.*` 사용
- 최소 섹션 크기: 3% (3% 미만은 "기타"로 통합)
- 호버 시 툴팁: 값, 비율, 라벨 표시
- 접근성: ARIA label 필수, 키보드 네비게이션 지원

바 차트 (Bar Chart):
- 용도: 비교 표시 (예: 일별 매출, 지역별 비교)
- 색상: Theme Token의 `colors.chart.*` 사용
- 축 레이블: 최대 10자, 초과 시 말줄임표
- 그리드 라인: 연한 회색 (colors.border)
- 호버 시 툴팁: 정확한 값 표시

15-0-2. 색상 토큰 기준

차트 색상은 Theme Token의 `colors.chart.*`를 사용합니다:

```typescript
// packages/design-system/tokens/chart-colors.ts
export const chartColors = {
  primary: 'var(--color-chart-primary)',
  secondary: 'var(--color-chart-secondary)',
  success: 'var(--color-chart-success)',
  warning: 'var(--color-chart-warning)',
  error: 'var(--color-chart-error)',
  info: 'var(--color-chart-info)',
  // ... 추가 색상
};
```

색상 사용 규칙:
- 시리즈가 5개 이하: 각 시리즈마다 고유 색상 할당
- 시리즈가 6개 이상: 색상 순환 사용 (동일 색상 재사용)
- 다크모드: 자동으로 다크모드 색상 토큰 사용
- 접근성: WCAG 2.1 AA 대비율 준수 (4.5:1 이상)

15-0-3. 지도 줌/패닝 UX

지도 줌 레벨 ↔ 지역 레벨 자동 전환:
- 줌 레벨 1-5: 시/도 레벨 (region_level = 'sido')
- 줌 레벨 6-8: 시/군/구 레벨 (region_level = 'sigungu')
- 줌 레벨 9-11: 읍/면/동 레벨 (region_level = 'eupmyeondong')
- 줌 레벨 12+: 법정동 레벨 (region_level = 'beopjeongdong')

→ 상세 매핑 규칙은 "15-6-0-3. 지도 줌 레벨 ↔ 지역 레벨 자동 전환" 섹션 참조

패닝 UX:
- 드래그로 지도 이동
- 이동 시 자동으로 해당 지역 레벨 데이터 로드
- 로딩 중 스켈레톤 UI 표시
- 데이터 로드 실패 시 에러 메시지 표시

15-0-4. KPI 카드 규격

KPI 카드 표준 구조:

```
┌─────────────────────────┐
│ [아이콘] KPI 이름        │
│                         │
│      주요 값            │
│   (큰 폰트, 강조)       │
│                         │
│ 전월 대비: +10% ↑       │
│ (또는 전년 동월 대비)   │
└─────────────────────────┘
```

KPI 카드 규격:
- 최소 너비: 200px (모바일), 250px (태블릿), 300px (데스크톱)
- 최대 너비: 400px
- 패딩: 16px (모바일), 20px (태블릿), 24px (데스크톱)
- 테두리: 1px solid colors.border
- 배경: colors.card
- 호버 효과: 그림자 증가 (elevation 증가)

KPI 카드 레이아웃:
- 그리드: 반응형 그리드 (xs: 1열, sm: 2열, md: 3열, lg: 4열, xl: 5열)
- 간격: 16px (모바일), 20px (태블릿), 24px (데스크톱)

KPI 값 표시 규칙:
- 숫자: 천 단위 콤마 표시 (예: 1,234,567)
- 통화: 원화 기호 표시 (예: ₩1,234,567)
- 비율: 소수점 1자리까지 표시 (예: 12.5%)
- 증감률: 색상으로 구분 (증가: colors.success, 감소: colors.error)
- 증감 아이콘: ↑ (증가), ↓ (감소)

15-0-5. Analytics 대시보드 레이아웃

표준 레이아웃 구조:

```
┌─────────────────────────────────────────┐
│ [KPI 카드 그리드]                        │
│ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐        │
│ │ KPI │ │ KPI │ │ KPI │ │ KPI │        │
│ └─────┘ └─────┘ └─────┘ └─────┘        │
├─────────────────────────────────────────┤
│ [차트 섹션]                              │
│ ┌──────────────────┐ ┌────────────────┐ │
│ │   도넛 차트      │ │   바 차트      │ │
│ └──────────────────┘ └────────────────┘ │
├─────────────────────────────────────────┤
│ [지도 섹션] (선택)                       │
│ ┌─────────────────────────────────────┐ │
│ │         지도 시각화                  │ │
│ └─────────────────────────────────────┘ │
├─────────────────────────────────────────┤
│ [테이블 섹션]                            │
│ ┌─────────────────────────────────────┐ │
│ │         데이터 테이블                │ │
│ └─────────────────────────────────────┘ │
└─────────────────────────────────────────┘
```

반응형 레이아웃:
- 모바일 (xs, sm): 세로 스택 (KPI → 차트 → 지도 → 테이블)
- 태블릿 (md): 2열 그리드 (KPI 그리드, 차트 2열)
- 데스크톱 (lg, xl): 3-4열 그리드 (KPI 그리드, 차트 2-3열, 지도 풀폭)

15-0-6. 데이터 시각화 우선순위

데이터 시각화 우선순위:
1. 숫자 카드 (KPI 카드) - 가장 중요
2. 차트 (도넛/바) - 비교/비율 표시
3. 지도 - 지역 분포 시각화
4. 테이블 - 상세 데이터

→ 모든 Analytics 화면은 위 우선순위를 따릅니다.

15-1. Analytics 파이프라인 설계 원칙 (Critical)

⚠️ 중요: Analytics Layer는 실시간성과 정확성 사이의 트레이드오프를 명확히 정의해야 합니다.

📌 파이프라인 구조:

원시 이벤트 테이블 (로그성) — 파티셔닝
↓
외부 런타임(Lambda/Cloudflare Workers) 집계 (매일 04:00 KST, Supabase cron은 트리거만 수행)
↓
analytics.daily_store_metrics (매장 단위 일별 KPI, 정본)
- 주요 컬럼: tenant_id, store_id, student_count, revenue, attendance_rate, new_enrollments, late_rate, absent_rate, active_student_count, inactive_student_count, avg_students_per_class, avg_capacity_rate, arpu, date_kst
analytics.daily_region_metrics (지역 단위 집계 KPI, 정본)
⚠️ 중요: analytics.daily_metrics, analytics.monthly_revenue는 구버전/폐기된 네이밍이며 더 이상 사용하지 않습니다. 정본은 analytics.daily_store_metrics, analytics.daily_region_metrics만 사용합니다.
↓
뷰(Materialized View)
- public.daily_store_metrics: PostgREST 노출을 위한 VIEW (underlying table: analytics.daily_store_metrics)
- public.daily_region_metrics: PostgREST 노출을 위한 VIEW (underlying table: analytics.daily_region_metrics)
- RLS 정책은 underlying table의 RLS에 의해 보호됨
↓
대시보드

📌 이벤트 스키마 구조:

analytics.events 테이블 구조:
- id: bigserial (전역 유니크)
- tenant_id: uuid (필수, RLS 기반 필터링)
- user_id: uuid (선택적, 사용자 추적용)
- event_type: text (필수, 업종별 이벤트 타입)
  - ⚠️ 참고: analytics.events.event_type은 자동화 카탈로그의 event_type과 다른 도메인 값입니다. analytics.events.event_type은 시스템 이벤트 타입(예: 'attendance.check_in', 'payment_webhook')이며, 자동화 카탈로그의 event_type은 자동화 시나리오 키(예: 'overdue_outstanding_over_limit', 'payment_due_reminder')입니다.
- occurred_at: timestamptz (필수, UTC 저장)
- payload: jsonb (업종별 확장 데이터)
- store_id: uuid (상용화 단계, 지역 벤치마킹용)
- region_id: uuid (상용화 단계, 지역 벤치마킹용)
- industry_type: text (상용화 단계, 지역 벤치마킹용)
- event_date_kst: date (상용화 단계, KST 기준 일자)

📌 ETL 규칙:

1. 이벤트 수집 (실시간):
   - Edge Function 또는 서버 코드에서 즉시 analytics.events에 INSERT
   - occurred_at는 UTC로 저장, event_date_kst는 서버 코드에서 toKST()로 계산하여 함께 저장
   - 상용화 단계에서는 store_id, region_id, industry_type을 함께 저장

2. 일별 집계 (배치):
   - 매일 04:00 KST에 외부 Worker(Lambda/Cloudflare Workers)가 전날 데이터 집계
   - analytics.events에서 event_date_kst 기준으로 그룹핑하여 analytics.daily_store_metrics에 upsert (정본)
   - 집계 지표: student_count, revenue, attendance_rate, new_enrollments, late_rate, absent_rate, active_student_count, inactive_student_count, avg_students_per_class, avg_capacity_rate, arpu
   - 지역별 집계는 analytics.daily_region_metrics에 upsert (정본)
   - 업종별 KPI는 Industry Layer의 Mapper를 사용하여 계산

⚠️ 중요: analytics.daily_metrics, analytics.monthly_revenue는 구버전/폐기된 네이밍이며 더 이상 사용하지 않습니다. 정본은 analytics.daily_store_metrics, analytics.daily_region_metrics만 사용합니다.

📌 지연 허용 시간(SLA):

- 실시간 이벤트 수집: 즉시 저장 (지연 없음)
- 일별 집계: 매일 04:00 KST 기준, 최대 1시간 지연 허용 (04:00~05:00 KST 완료 목표)
- 월별 집계: 매월 1일 04:00 KST 기준, 최대 2시간 지연 허용 (04:00~06:00 KST 완료 목표)
- 대시보드 조회: 집계 완료된 데이터만 표시 (최신 데이터는 "집계 중" 표시)

📌 실시간 vs 배치 분리 기준:

실시간 처리 (Edge Function):
- 이벤트 수집: analytics.events에 즉시 INSERT
- 단일 테넌트 조회: 최신 이벤트 조회 (analytics.events 직접 조회)
- 실시간 알림: 이벤트 발생 즉시 처리

배치 처리 (외부 Worker):
- 일별/월별 집계: 대량 데이터 집계는 외부 Worker에서 수행
- 통계/리포트 생성: heavy query는 배치로 처리
- 백필(Backfill): 과거 데이터 재집계는 배치로 처리

📌 인덱스 설계:

필수 인덱스:
- (tenant_id, occurred_at DESC): 테넌트별 최신 이벤트 조회
- (tenant_id, store_id, occurred_at DESC): 상용화 단계, 매장별 이벤트 조회
- (industry_type, region_id, event_date_kst): 상용화 단계, 지역별 집계
- (event_date_kst, industry_type, region_id): 상용화 단계, 날짜 기준 집계
