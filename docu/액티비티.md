📘 Execution Audit (Run/Step) System (SSOT)

**버전**: 1.0.4
**최종 업데이트**: 2026-01-10
**상태**: ✅ 정본 (정밀 검증 반영본)

0. SSOT 선언 및 범위
0.1 목적

Execution Audit 시스템은 서비스 내에서 발생한 모든 "실행 결과"(AI 여부 무관) 를 기록하고, 운영자가 "무슨 일이 실제로 일어났는지" 를 단일 진실(Source of Truth)로 확인할 수 있게 한다.

⚠️ 용어 참고: 본 시스템은 챗봇.md에서 "Activity 시스템"으로도 언급되며, 두 문서는 동일한 시스템을 가리킵니다. 챗봇.md는 사용자 대화창 관점에서 "Activity"로 표현하고, 본 문서는 운영 감사 관점에서 "Execution Audit"로 표현합니다.

⚠️ 중요: automation_actions(챗봇.md 정본)와 execution_audit_runs(본 문서 정본)의 관계
- automation_actions: 워크플로우 이벤트 기록(승인요청/실행 이벤트, 챗봇.md 6.3.2 참조)
- execution_audit_runs: 실행 결과 기록(실제 실행 결과, 본 문서 정본)
- automation_actions 기록 후 execution_audit_runs도 생성되어야 함(챗봇.md 642줄: "Execution Audit 시스템에 실행 결과 기록" 참조)
- automation_actions.request_id와 execution_audit_runs.reference.request_id는 동일한 형식을 사용(챗봇.md 6.3.1 참조)

본 문서는 "사용자 타임라인/피드" 성격의 core-activity(활동 피드) 와 다르다.
core-activity는 UX/피드 목적, 본 문서는 운영 추적/감사(Audit) 목적이다.
따라서 본 문서의 데이터/탭/권한/보관 정책은 core-activity와 절대 혼용하지 않는다.

0.2 정본 분리 원칙

AI(ChatOps) 문서는 "의도 해석/조회/계획/승인 요청" 정본이다.
- automation_actions 테이블: 워크플로우 이벤트 기록(승인요청/실행 이벤트)의 정본(챗봇.md 6.3.2)

Execution Audit 문서(본 문서) 는 "실행 결과/감사/운영 로그" 정본이다.
- execution_audit_runs 테이블: 실행 결과 기록의 정본(본 문서)

두 시스템은 UI에서 같은 패널(탭)로 보여줄 수 있으나, 책임·데이터·표현은 반드시 분리한다.
- automation_actions 기록 후 execution_audit_runs도 생성되어야 함(챗봇.md 642줄: "Execution Audit 시스템에 실행 결과 기록" 참조)

0.3 불변 규칙 (P0)
Execution is the source of truth

"문자 발송 완료" 같은 결과 진술의 근거는 Execution Audit 뿐이다.

AI는 Execution Audit를 생성/판정하지 않는다

AI는 Execution Audit를 "조회/요약(읽기 전용)"만 할 수 있다.

Fail-Closed

기록/조회/필터가 애매한 상황에서는 "조용히 누락"이 아니라 명확히 실패 상태로 기록하거나 권한 차단으로 기록한다.

Zero-Trust UI

UI는 테넌트/권한을 "믿지 않고", API/SDK에서 주입되는 컨텍스트 기반으로만 동작한다.

Policy 경로/자동화 구성 SSOT 불변

Execution Audit는 정책 시스템을 대체하지 않으며, 자동화 정책의 진실은 SSOT에서 정의된 Policy 경로가 가진다.
Execution Audit는 "정책 평가 결과/차단 결과"만 사실로 기록한다.

Correlation Key 없는 Run 금지 (DB/서버 이중 강제)

correlation key가 전혀 없는 Run은 금지(P0) 이다.
이 규칙은 문서 선언에 그치지 않고 서버 Insert Gate + DB 제약으로 이중 강제한다.

details PII 유입 금지 (정책/저장 책임 고정)

details는 allowlist 기반으로만 저장한다.
allowlist 적용 책임은 서버 Insert Layer가 최종 책임이며, 가능하면 DB 트리거로 2중 방어한다.

Fail-Closed "거부" vs "기록" 경계 고정 (P1 포함하되 정책은 불변 수준으로 문서에 명시)

운영 판단에 영향을 주는 실패(권한/정책/조건/미등록 operation/no-op/외부오류/시스템 보호)는 반드시 Run(필요 시 Run-only)로 기록한다.
단, 개발/통합 단계의 명백한 클라이언트 입력 오류(예: 필수 파라미터 누락, 타입 불일치)로 운영 판단에 영향이 없고 재현이 불필요한 경우에 한해, 서버는 4xx로 거부하고 Run을 생성하지 않을 수 있다.

0.4 업종 중립성 (Industry Neutrality)

Execution Audit 시스템은 **완전히 업종 중립적(Industry Neutral)**으로 구현되어 있습니다.

**업종 중립적 구현:**
- Execution Audit 시스템은 공통 테이블만 사용합니다:
  - `execution_audit_runs`: 모든 실행 결과 기록 (업종 무관)
  - `execution_audit_steps`: 실행 세부 단계 기록 (업종 무관)
  - `meta.operation_registry`: operation_type 매핑 레지스트리 (업종 무관)
- 업종별 테이블명을 사용하지 않으며, Industry Adapter가 필요하지 않습니다.
- 모든 업종(Academy, Salon, Real Estate, Gym, NGO 등)에서 동일한 테이블과 로직을 공통으로 사용합니다.

**테넌트 추가 시 공통 활용:**
- 새로운 테넌트 추가 시 Execution Audit 시스템은 **코드 수정 없이 즉시 사용 가능**합니다.
- 업종이 추가되어도 Execution Audit 시스템은 변경할 필요가 없습니다.
- `execution_audit_runs`와 `execution_audit_steps` 테이블은 모든 업종에서 공통으로 사용됩니다.

**관련 규칙:**
- Automation & AI Industry-Neutral Rule ([Industry_Neutrality.md](./Industry_Neutrality.md)) 준수
- Execution Audit는 Core Platform 공통 로직으로, 업종별 분기 없이 동작합니다.

1. 개념 정의 (용어 고정)
1.1 Execution Audit

시스템이 실제로 실행했거나, 실행을 시도했고, 그 결과가 운영 판단에 영향을 미치는 사실의 기록

1.2 Run (상위 실행 단위)

“한 번의 실행 요청/실행 흐름”을 대표하는 레코드
예) “미결제 안내 문자 발송” 한 번

1.3 Step (하위 실행 단위)

Run 내부에서 실제로 수행된 세부 결과
예) 수신자별 발송 결과, 레코드별 업데이트 결과

1.4 Source vs Actor (책임 소재 분리)

source: 실행이 "어디서 유래했는가" (ai/automation/scheduler/manual/webhook)

actor: 실행을 "누가/무엇이 수행했는가" (user/system/external)

1.5 Partial 상태의 의미

partial 상태의 상세 정의는 5.1 Run 상태를 참조한다.

요약: Run 내부에서 일부 Step은 성공하고 일부 Step은 실패한 상태이며, Step이 2개 이상인 경우에만 발생한다. Step이 1개인 경우는 partial이 될 수 없으며, success 또는 failed 중 하나만 허용된다.

1.6 “No-op(대상 0건)”의 의미 (P1 고정)

대상 0건으로 인해 실행이 수행되지 않은 경우(예: 발송 대상 0명)는 운영 판단에 영향을 주므로 Run으로 기록한다.
본 정본에서는 이를 “조용한 성공”으로 보지 않고 failed + 명시 사유로 고정한다.

status = failed

error_code = no_targets

error_summary = “대상 없음(0건)으로 실행되지 않음” 등

2. Execution Audit가 아닌 것 (금지 범위, P0)

아래는 어떤 경우에도 Execution Audit에 저장하지 않는다.

AI 프롬프트, 추론 과정, 내부 reasoning

승인 전 계획(Plan), TaskCard 미승인 상태

UI 이벤트(클릭, 페이지 이동)

사용자 대화 전문(채팅 로그)

문자/알림 “원문 전문” 저장
(필요 시 별도 메시지 시스템에 보관하고 Execution Audit에는 참조키만)

3. 필수 기록 대상 (What Must Be Logged) — 확장판 정본
3.1 기록 원칙 (General Rule, P0)

시스템이 실제로 실행했거나, 실행을 시도했으며
그 결과가 운영 판단에 영향을 미치는 경우
반드시 Execution Audit에 기록한다.

또한,

“실행됨”뿐 아니라 차단/중단/부분실패/재시도까지 운영 판단에 영향을 주므로 기록 대상이다.

반대로 “의도/계획/추론”은 절대 기록하지 않는다.

3.2 실행 결과 자체 (Execution Result)

필수:

문자/알림 발송 결과

출결 처리 결과

상태 변경(update) 결과

청구/결제/정산 생성 결과

자동화/배치/스케줄러 실행 결과

외부 API 호출 결과(성공/실패/타임아웃 포함)

사용자에게 노출되는 결과물 생성(리포트/집계/발송)
예: 리포트 생성, 대시보드 데이터 생성, 통계 계산, 집계 작업 실행

판정 기준:

Step 생성 기준은 4.1 Run(상위) / Step(하위) 구조를 참조한다. 요약: DB 커밋/외부 전송/외부 응답 중 하나라도 발생했다면 기록한다.

3.3 데이터 변경(Data Mutation) 이벤트

필수:

레코드 생성/수정/비활성화

상태 전이(pending→paid 등)

관계 변경(학생-반 이동, 담당자 변경)

규칙:

트랜잭션이 커밋되면 반드시 기록한다(사용자가 UI에서 “실행”을 인지하지 못해도 기록).

3.4 외부 연동(External Integration) 결과

필수:

SMS/알림 벤더의 요청/응답(성공/실패/타임아웃)

PG 승인/거절

webhook 수신 처리 결과

목적:

“우리 문제 vs 외부 문제”를 분리하기 위한 최소 사실 기록

3.5 자동화 조건 평가 결과 (Automation Condition Evaluation)

필수:

조건 충족 → 실행됨

조건 미충족 → 실행 안 됨(요약 기록)

금지:

룰 정의 전체, 표현식 전체 저장

허용:

“조건 미충족 사유 코드/요약” 정도의 최소 기록
예) rule_not_met: unpaid_days < 3

3.6 정책/권한 차단(Fail-Closed) 이벤트

필수:

permission_denied

policy_disabled

validation_error

unknown_operation (허용되지 않은 operation_type)

tenant_scope_violation (테넌트 범위 위반)

목적:

“왜 실행이 안 됐는지”를 운영자가 사실로 확인 가능해야 함

3.7 부분 성공(Partial) 및 실패 사유 분류

필수:

Run status: success / failed / partial

Step status: success / failed

실패 사유 code(기계) + summary(사람)

성공/실패 카운트(특히 메시지 발송류)

partial 판정:

상세 규칙은 5.1 Run 상태를 참조한다. 요약: 성공과 실패가 혼재하면 무조건 partial이며, Step이 2개 이상인 경우에만 발생한다.

3.8 실행 중단/비정상 종료(Interrupted Execution)

필수:

실행 시작 후 중단(수동/오류/타임아웃)

제외:

실행 시작 전 취소(계획 단계 취소는 Execution Audit 아님)

3.9 재시도/보정(Retry & Compensation)

필수:

자동 재시도 발생 여부/횟수

수동 재시도 결과

보정 실행 결과(실패 건 재발송 등)

규칙:

원본 Run과 반드시 연관(correlation key)되어야 함

**재시도 연관 규칙:**
- 재시도 Run의 reference 필드에 `retry_of_run_id` 키를 추가하여 원본 Run과 연관
- 재시도 체인 추적: 여러 번 재시도된 경우, 각 재시도 Run이 이전 Run의 run_id를 `retry_of_run_id`로 참조하여 체인 형성
- 예: `reference: { "retry_of_run_id": "<원본_run_id>", "request_id": "...", ... }`

3.10 시스템 보호 동작(System Safeguard) (사실상 필수)

rate_limit_triggered

circuit_breaker_open

bulk_operation_throttled

대규모 자동화 운영에서 장애 분석에 직접 필요하므로, "권장"이 아니라 운영 단계에서는 사실상 필수가 된다.

4. 실행 모델 (Run/Step 구조)
4.1 Run(상위) / Step(하위) 구조

1 Run : 0..N Step 규칙을 적용한다.

Step은 "관찰 가능한 실행 결과 단위"가 발생했을 때 생성한다.
관찰 가능한 결과 단위란 다음 중 하나 이상이다:

DB 커밋 발생

외부 전송(요청) 발생

외부 응답 수신(성공/실패 포함)

타임아웃/중단 등으로 "실행이 시작된 후 종료"가 발생

정책 차단/조건 미충족/검증 실패/unknown_operation 등으로 실행이 시작되지 않은 경우 Run만 남길 수 있다.

**다건 실행에서의 Step 생성 전략:**
- 기본 전략: 수신자별 Step 생성 (각 수신자별 발송 결과를 개별 Step으로 기록, 상세 추적 가능)
  - 운영 판단에 필요한 상세 추적이 우선인 경우 사용
- 배치 단위 Step 생성: Step 수가 1000건 이상으로 예상되는 경우, 배치 전체 결과를 1개 Step으로 기록 (성능 우선, 상세도 감소)
  - 대량 실행(예: 1000건 이상)에서 성능이 우선인 경우 사용
  - ⚠️ 기준 근거: Step 1000건 이상 조회 시 응답 시간이 2초를 초과하는 경우가 빈번하므로, 성능 우선 전략 사용 권장
- 선택 기준: Step 수 예상치가 1000건 미만이면 기본 전략(수신자별), 1000건 이상이면 배치 단위 전략 사용
  - ⚠️ 참고: 1000건 기준은 초기 기준이며, 운영 데이터 기반으로 조정 가능 (예: 응답 시간 임계값 변경 시 기준 조정)

No-op(대상 0건)으로 실행이 수행되지 않은 경우:

Run만 남길 수 있다.

status=failed, error_code=no_targets로 명시한다.

4.2 UI 기본은 Run, 상세에서 Step

UI 목록 조회는 Run 중심으로 수행한다.

Run 상세 조회 시 Step 목록을 지연 로딩한다.

Step을 Run 목록과 함께 조회하지 않는다 (성능 보호).

⚠️ 성능 고려: 대량 Step(수천 건) 조회 시에도 cursor 기반 페이징 필수 적용 (10.2 참조).

5. 상태 정의
5.1 Run 상태

Run status는 다음 세 가지 중 하나만 허용한다:

success: 모든 Step이 성공한 경우 (Step이 1개 이상인 경우)

failed: 모든 Step이 실패한 경우 또는 Step이 없는 경우

partial: 성공과 실패가 혼재한 경우 (필수, Step이 2개 이상인 경우)

⚠️ 중요: Step이 1개인 경우는 partial이 될 수 없으며, success 또는 failed 중 하나만 허용된다. partial은 반드시 Step이 2개 이상이고 성공과 실패가 혼재할 때만 발생한다.

Step이 없는 경우(status=failed) 판정 규칙:

정책 차단/조건 미충족/검증 실패로 실행이 시작되지 않은 경우:
error_code에 policy_disabled, permission_denied, validation_error, unknown_operation 등이 기록된다.

No-op(대상 0건)인 경우:
error_code=no_targets, error_summary로 사유를 명시한다.

실행 시도는 했으나 실제 관찰 가능한 실행 결과 단위가 발생하지 않은 경우:
error_code와 error_summary로 사유를 명시한다.

5.2 Step 상태

Step status는 다음 두 가지 중 하나만 허용한다:

success: 해당 Step이 성공한 경우

failed: 해당 Step이 실패한 경우

6. 실행 주체 및 트리거
6.1 Source (실행 유래)

source는 다음 중 하나여야 한다:

ai: AI(ChatOps) 승인 실행
- ⚠️ 참고: 챗봇.md의 approve-and-execute 실행 시 source='ai'로 기록
- automation_actions.action_type='approve-and-execute'와 execution_audit_runs.source='ai'는 동일 실행을 나타냄
- automation_actions 기록 후 execution_audit_runs도 생성되어야 함(챗봇.md 642줄: "Execution Audit 시스템에 실행 결과 기록" 참조)

automation: 자동화 엔진 실행

scheduler: 스케줄러 실행

manual: 수동 실행(관리자 액션)

webhook: 웹훅 수신 처리

⚠️ 확장 규칙: source 확장 시 6.4 공통 확장 절차를 참조한다.

6.2 Actor (실행 수행자)

actor_type은 다음 중 하나여야 한다:

user: 사용자가 수행

system: 내부 시스템이 수행

external: 외부 서비스/벤더가 수행

actor_id 타입 고정 (P1 타입 안정성)

actor_id는 text 단일 타입으로 고정한다. (uuid/text 혼용 금지)

표기 규칙(예시):

user: user:<uuid>

system: svc:edge:automation-runner

external: vendor:twilio, vendor:kakao-alimtalk

⚠️ 확장 규칙: actor_type 확장 시 6.4 공통 확장 절차를 참조한다.

6.3 Source와 Actor 분리 원칙

source와 actor는 반드시 분리하여 기록한다.

source는 "왜 실행됐는지"를 나타내고, actor는 "누가/무엇이 실행했는지"를 나타낸다.

6.4 source/actor_type 확장 절차 (공통)

source(6.1) 또는 actor_type(6.2) 확장 시 다음 절차를 공통으로 적용한다:

**확장 절차 (체크리스트):**
1. registry(또는 별도 카탈로그)에 값 등록
   - source 또는 actor_type 값: 형식 규칙 준수 (소문자, 하이픈 사용 가능)
   - description: 설명
2. SSOT 문서에 값 추가 및 사용 예시 기록
   - source 확장: 6.1 섹션에 추가
   - actor_type 확장: 6.2 섹션에 추가
3. 테스트: Run 생성 시 검증 테스트
4. 문서화: SSOT 문서에 값 추가 및 사용 예시 기록

7. 연관 관계(Correlation)
7.1 reference 필드 규칙

reference 필드는 "왜 실행됐는지" 추적 가능성을 보장하기 위해 필수로 기록한다.

모든 Run은 최소 1개 이상의 correlation key를 포함해야 한다.

7.2 Correlation Key 우선순위

correlation key는 다음 우선순위로 기록한다:

1순위: request_id (실행 요청 식별자, 존재하는 경우 최우선 기록)
- ⚠️ 중요: request_id 형식은 챗봇.md 6.3.1에 정의된 형식을 사용: `{task_id}:{action}:{attempt_window}`
  - action 값: `request-approval` 또는 `approve-and-execute` (챗봇.md 6.3.1 참조)
- automation_actions.request_id와 execution_audit_runs.reference.request_id는 동일한 형식 사용
- attempt_window: 5분 버킷 (floor(now_utc / 5min))
- automation_actions 테이블에서 request_id 유니크 제약으로 멱등 강제(챗봇.md 6.3.1 참조)

2순위: task_id | automation_id | job_id (업무/자동화/배치 연관)

3순위: entity_type + entity_id (대상 엔티티 연관)

4순위: source_event_id 또는 diagnostic_id (위가 모두 없을 때 필수, 시스템 보호 동작/차단/외부 실패 등)

5순위: retry_of_run_id (재시도 연관, 3.9 참조)
- 재시도 Run의 reference 필드에 `retry_of_run_id` 키를 추가하여 원본 Run과 연관
- 재시도 체인 추적: 여러 번 재시도된 경우, 각 재시도 Run이 이전 Run의 run_id를 `retry_of_run_id`로 참조하여 체인 형성
- 예: `reference: { "retry_of_run_id": "<원본_run_id>", "request_id": "...", ... }`
- ⚠️ 참고: retry_of_run_id는 재시도 연관 전용이며, 최소 correlation key 요구사항(7.3)을 충족하지 않습니다. retry_of_run_id만 있는 경우는 허용되지 않으며, 1-4순위 키 중 최소 1개와 함께 사용해야 합니다.

7.3 Correlation Key 없는 Run 금지 (P0)

correlation key가 전혀 없는 Run은 금지한다.

최소한 request_id, source_event_id, diagnostic_id 중 하나는 반드시 기록한다.

7.4 강제 방법 (Server Gate + DB Constraint, P0)

서버 Insert Gate:

운영 판단에 영향을 주는 실패는 반드시 Run(필요 시 Run-only)로 기록한다.

단, 운영 판단에 영향이 없고 재현이 불필요한 명백한 클라이언트 입력 오류는 4xx로 거부하고 Run 미생성을 허용할 수 있다(0.3의 경계 규칙 준수).

DB Constraint/Trigger:

서버 버그/우회 삽입을 대비하여 DB 레벨에서도 correlation key 최소 1개 존재를 강제한다.

8. 데이터 모델 (정본 스키마 명세)

아래 스키마는 Execution Audit 시스템 구현을 위한 정본 명세다.
(기존 테이블이 없으므로 신규 도입이 필요)

중요(명칭 충돌 방지, P0):
기존 “core-activity(피드)”와 혼동을 막기 위해 테이블은 activity_* 접두어를 쓰지 않고 execution_audit_ 접두어를 사용한다.

8.1 테이블: execution_audit_runs

목적: 실행 1회를 대표 (Run)

필수 컬럼:

id (uuid, PK)

tenant_id (uuid, indexed) — 멀티테넌트 필수

occurred_at (timestamptz, indexed) — 실행 시간

operation_type (text, indexed) — 예: send-sms / update-attendance
⚠️ P0 규칙: 표기 규칙은 kebab-case(하이픈) 로 고정한다.
허용되는 operation_type은 operation registry(카탈로그) 에 등록된 값만 사용한다 (미등록 금지).

(선택) 도메인 prefix 사용 권장: messaging.send-sms, attendance.update-attendance 등
단, prefix를 사용하더라도 마지막 토큰은 kebab-case를 유지한다.
또한 prefix 포함 형식은 아래 “형식 강제(정규식)”에 의해 제한된다.

status (text, indexed) — success/failed/partial

source (text, indexed) — ai/automation/scheduler/manual/webhook

actor_type (text) — user/system/external

actor_id (text nullable) — user:<uuid> / svc:<name> / vendor:<name>

summary (text) — 사람이 읽는 요약

details (jsonb) — 구조화 데이터(확장)

reference (jsonb) — 상관관계 키 묶음

예:

{ "request_id": "...", "task_id": "...", "automation_id": "...", "job_id": "...", "entity_type": "student", "entity_id": "...", "source_event_id": "..." }

⚠️ 참고: request_id 형식은 챗봇.md 6.3.1 참조 (`{task_id}:{action}:{attempt_window}`, automation_actions.request_id와 동일 형식)

correlation key는 7.2 우선순위에 따라 최소 1개 이상 포함해야 한다.

counts (jsonb, nullable) — 성공/실패 카운트 (다건 실행에서만 사용)
예:

{ "success": 11, "failed": 1 }

**사용 규칙:**
- Step이 10개 미만인 경우: counts 생략 가능 (Step 목록에서 직접 집계)
  - ⚠️ 기준 근거: Step 10개 미만 조회 시 집계 연산 비용이 낮아 counts 필드 없이도 성능 영향이 미미함
- Step이 10개 이상인 경우: counts 필드 필수 (성능 최적화)
  - ⚠️ 기준 근거: Step 10개 이상 조회 시 집계 연산 비용이 증가하므로, 사전 계산된 counts 필드 사용으로 조회 성능 최적화
  - counts 필드가 없으면 Step 목록 조회 시 성능 저하 가능
  - 서버에서 Step 목록을 집계하여 counts를 동적으로 생성하는 것도 가능하나, 사전 계산된 counts 사용 권장
- 단건 실행 또는 Step이 없는 경우: null 또는 생략 가능
  - ⚠️ 참고: 10개 기준은 초기 기준이며, 운영 데이터 기반으로 조정 가능 (예: 집계 연산 비용 분석 결과에 따라 기준 조정)

error_code (text nullable)

error_summary (text nullable)

duration_ms (int nullable)

version (text nullable) — 실행 서비스 버전(장애 분석용)
- 형식: Semver (예: "1.2.3")
- 기록 주체: 서버에서 자동 기록 (Edge Function / API Server에서 실행 시점의 서비스 버전 기록)
- 검증 규칙 (선택): Semver 형식 검증을 위한 CHECK 제약 추가 가능
  ```sql
  -- 선택적 CHECK 제약 예시 (Semver 형식 검증)
  ALTER TABLE execution_audit_runs
  ADD CONSTRAINT execution_audit_runs_version_semver_chk
  CHECK (
    version IS NULL
    OR version ~ '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*)?(\+[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*)?$'
  );
  ```
  - 위 CHECK 제약은 선택적이며, 서버 레벨에서 Semver 형식을 보장하는 경우 생략 가능

created_at (timestamptz default now())

details 저장 규칙 (PII/컴플라이언스, P0)

details는 allowlist 기반으로만 저장한다.
즉, “허용 키 목록”에 없는 키는 저장 금지 또는 서버에서 제거한다.

문자/알림 원문 전문, 전화번호, 주소 등 직접 식별 PII는 details 저장 금지.
필요한 경우 별도 메시지/벤더 로그 시스템에 저장하고, Execution Audit에는 message_id / vendor_message_id 같은 참조키만 저장한다.

details allowlist 적용 책임 (P0)

최종 책임: 서버 Insert Layer(Edge Function / API Server)

Run/Step 생성 시점에 operation_type별 allowlist를 적용하여 details에서 불허 키를 제거/거부한다.

2중 방어(권장): DB Trigger

서버 구현 실수/우회 삽입을 대비하여 DB에서도 최소한의 방어(불허 키가 존재하면 예외 또는 제거)를 적용한다.

권장 인덱스:

(tenant_id, occurred_at desc, id) — cursor 페이징 최적화용 복합 인덱스

(tenant_id, operation_type, occurred_at desc)

(tenant_id, status, occurred_at desc)

(tenant_id, source, occurred_at desc) — source 필터 조합 최적화용 (선택)

**reference 필드 조회용 인덱스 (초기 전략):**
- 초기 권장: reference 필드의 주요 키(request_id, task_id)를 별도 컬럼으로 추출하여 B-tree 인덱스 생성 (정규화 방식, 성능 우선)
- 확장 전략: 조회 패턴이 확정되고 reference의 request_id/task_id 조회가 빈번한 경우(예: 일일 조회 빈도 > 1000회), GIN index on reference 고려
- 전환 기준: 다음 조건을 모두 만족하는 경우 확장 전략으로 전환 고려
  - reference의 request_id/task_id 조회가 일일 1000회 이상 발생
  - 별도 컬럼 추출 방식의 인덱스 유지보수 비용이 높음
  - GIN 인덱스 추가로 인한 저장 공간 증가와 쓰기 성능 영향이 허용 범위 내
- 주의: GIN 인덱스는 저장 공간과 쓰기 성능에 영향을 주므로, 조회 패턴이 확정된 후 적용 권장

GIN index on reference / details (조회 패턴이 확정되면 선택)

8.2 테이블: execution_audit_steps

목적: Run 내부 세부 실행 결과 (Step)

필수 컬럼:

id (uuid, PK)

tenant_id (uuid, indexed)

run_id (uuid, indexed, FK → execution_audit_runs.id, on delete cascade)

occurred_at (timestamptz, indexed)

status (text) — success/failed

target_type (text) — recipient / entity / record 등

target_id (text) — 대상 식별자 (타입 혼용 방지: text 단일 고정)

예: person:<uuid>, record:<uuid>, recipient:<id>

summary (text)

details (jsonb)

error_code (text nullable)

error_summary (text nullable)

created_at (timestamptz default now())

details 저장 규칙 (PII, P0):

run.details와 동일하게 allowlist 기반을 적용한다.

⚠️ 중요: Step details의 allowlist는 Run details와 동일한 규칙을 적용한다. operation_type별 allowed_details_keys는 Run과 Step 모두에 동일하게 적용되며, Step 전용 추가 키는 허용하지 않는다 (일관성 유지).

수신자 식별이 필요한 경우에도 직접 PII 대신 내부 키(예: recipient_id, person_id)를 우선 사용한다.

권장 인덱스:

(tenant_id, run_id)

(tenant_id, occurred_at desc)

(tenant_id, status, occurred_at desc)

8.3 (선택) 테이블: execution_audit_idempotency

⚠️ 중요: automation_actions 테이블에 request_id 유니크 제약이 이미 존재하므로, execution_audit_idempotency 테이블은 중복 기능입니다.

**권장 해결책:**
- execution_audit_idempotency 테이블은 제거하고, automation_actions.request_id를 직접 참조하는 방식 사용
- automation_actions.request_id는 챗봇.md 6.3.1에 정의된 형식(`{task_id}:{action}:{attempt_window}`)을 사용하며, automation_actions 테이블에서 (tenant_id, request_id) 유니크 제약으로 멱등성이 이미 보장됩니다
- execution_audit_runs.reference.request_id는 automation_actions.request_id와 동일한 형식을 사용하므로, execution_audit_runs에서 automation_actions를 조인하여 멱등성을 확인할 수 있습니다

**대안 (execution_audit_idempotency 테이블이 필요한 경우):**
- execution_audit_idempotency.request_id는 automation_actions.request_id를 참조하는 FK로 정의
- 또는 execution_audit_idempotency 테이블을 제거하고, execution_audit_runs.reference.request_id를 통해 automation_actions와 조인하여 멱등성 확인

8.A Operation Registry (카탈로그) — 정본 (P0)

operation registry는 “허용 operation_type”과 “details allowlist”를 강제하는 정본 데이터다.
registry가 없으면 “등록 필수” 규칙은 강제 불가능하므로, 본 문서는 registry의 위치/형식/최소 필드까지 SSOT로 고정한다.

8.A.1 정본 위치(택1 고정)

옵션 1 (DB 정본 권장): meta.operation_registry 테이블이 정본

옵션 2 (파일 정본): policy/operation_registry.json (빌드/배포에 포함)

단, 런타임 변경이 필요하면 DB 정본으로 전환한다.

본 정본에서는 기본을 옵션 1(DB 정본) 으로 권장한다.

8.A.2 최소 스키마

(권장) 테이블: meta.operation_registry

tenant_scope: global (기본)
(테넌트별 커스텀 operation 허용이 필요하면 별도 테이블로 분리하거나 tenant_id 컬럼 추가)

필수 필드:

operation_type (text, PK) — (선택) prefix 포함, 최종 토큰 kebab-case 고정
- ⚠️ 참고: automation_actions.action_type('request-approval', 'approve-and-execute')와 execution_audit_runs.operation_type의 매핑 규칙
- automation_actions.action_type='approve-and-execute' 실행 시 execution_audit_runs.operation_type은 실제 실행된 작업(예: 'messaging.send-sms')으로 기록
- automation_actions는 워크플로우 이벤트, execution_audit_runs는 실제 실행 결과를 나타냄

intent_key (text, nullable, indexed) — Intent Registry의 intent_key와 매핑 (매핑 규칙 참조)
- ⚠️ 중요: automation_actions.action_type='approve-and-execute' 실행 시 intent_key → operation_type 매핑에 사용
- intent_key가 있는 경우: intent_key를 키로 하여 operation_type을 조회 (매핑 규칙 2단계 참조)
- intent_key가 없는 경우: operation_type을 직접 사용 (자동화 엔진/스케줄러 등에서 직접 실행)
- UNIQUE 제약 권장: (intent_key) WHERE intent_key IS NOT NULL (intent_key와 operation_type의 1:1 매핑 보장)

**매핑 규칙 (단계별):**
1. automation_actions.action_type='approve-and-execute'인 경우, TaskCard.suggested_action에서 intent_key를 추출
2. meta.operation_registry 테이블에서 intent_key를 키로 하여 operation_type을 조회
   - ⚠️ 중요: meta.operation_registry 테이블에는 intent_key 컬럼이 필수로 포함되어야 하며, intent_key와 operation_type의 1:1 매핑을 보장한다
   - 매핑 방식: `SELECT operation_type FROM meta.operation_registry WHERE intent_key = ?` 쿼리로 조회
   - Intent Registry(챗봇.md 8.2 참조)는 intent_key 정의 및 검증용이며, operation_type 매핑은 meta.operation_registry 테이블이 SSOT이다
3. 매핑 성공 시: execution_audit_runs.operation_type에 실제 실행 작업의 operation_type 기록
4. 매핑 실패 처리: operation_type 매핑에 실패하거나 registry에 등록되지 않은 경우
   - status=failed
   - error_code=unknown_operation
   - Step은 생성하지 않음 (Run-only)

description (text)

pii_risk (text) — low/medium/high

default_summary_template (text) — UI/로그 요약 템플릿

allowed_details_keys (jsonb object) — details allowlist "셋(set)"
예:

{ "message_id": true, "vendor_message_id": true, "template_id": true }


allowed_reference_keys (jsonb object, optional) — reference 확장 키 제한(필요 시)

is_enabled (bool) — 운영 중 비활성화 가능(정책과 별개로 "운영 차단"도 가능)

created_at, updated_at

8.A.3 강제 규칙

Run 생성 시:

operation_type이 registry에 없으면 unknown_operation 으로 기록

status=failed

Step은 생성하지 않는다 (Run-only)

details는 registry의 allowed_details_keys만 허용한다.

operation_type은 형식 강제 규칙(8.B.2)에 의해 제한된다.

**operation_type 확장 절차 (체크리스트):**
1. meta.operation_registry 테이블에 operation_type 등록
   - operation_type (PK): 형식 강제 규칙 준수 (8.B.2 참조)
   - description: 작업 설명
   - pii_risk: low/medium/high 평가
   - allowed_details_keys: details allowlist 정의 (jsonb)
   - default_summary_template: UI 요약 템플릿
2. details allowlist 정의: PII 저장 금지 규칙 준수 (8.1 details 저장 규칙 참조)
3. 테스트: Run 생성 시 operation_type 검증 및 details allowlist 적용 테스트
4. 문서화: SSOT 문서에 operation_type 추가 및 사용 예시 기록

8.B DB 강제(권장 구현) — Correlation/PII/형식 (P0)

아래는 “문서 규칙을 DB가 실제로 강제”하기 위한 권장 제약 예시다.
(프로젝트 표준/마이그레이션 체계에 맞게 반영)

8.B.1 correlation key 최소 1개 강제 (CHECK 예시)
-- reference에는 최소한 request_id / source_event_id / diagnostic_id 중 하나가 존재해야 함
-- ⚠️ 참고: request_id는 automation_actions.request_id와 동일한 형식 사용(챗봇.md 6.3.1 참조)
ALTER TABLE execution_audit_runs
ADD CONSTRAINT execution_audit_runs_reference_min_key_chk
CHECK (
  (reference ? 'request_id')
  OR (reference ? 'source_event_id')
  OR (reference ? 'diagnostic_id')
);


⚠️ 정합성: 위 CHECK 제약은 7.2 우선순위의 최소 요구사항(request_id/source_event_id/diagnostic_id 중 1개)을 강제한다.

**확장 가능한 CHECK 제약 (선택):**
우선순위 2-3순위 키(task_id, automation_id, job_id, entity_type+entity_id)를 포함한 더 강한 체크도 가능하다:
```sql
CHECK (
  (reference ? 'request_id')
  OR (reference ? 'source_event_id')
  OR (reference ? 'diagnostic_id')
  OR (reference ? 'task_id')
  OR (reference ? 'automation_id')
  OR (reference ? 'job_id')
  OR ((reference ? 'entity_type') AND (reference ? 'entity_id'))
);
```
다만 "최소 1개 강제"는 반드시 유지한다. 위 확장 CHECK를 사용하면 우선순위 2-3순위 키만 있어도 통과 가능하지만, 7.2 우선순위에 따라 가능한 경우 1-4순위 키를 우선 사용하는 것을 권장한다.

8.B.2 operation_type 형식 강제 (prefix + kebab-case 고정)

본 정본은 operation_type에 대해 다음 형식을 허용한다:

prefix가 없는 경우: kebab-case
예) send-sms

prefix가 있는 경우: segment(.segment)*.kebab-case
예) messaging.send-sms, attendance.update-attendance

여기서:

prefix segment는 [a-z0-9]+ 로 구성

마지막 토큰은 반드시 kebab-case (하이픈 포함 가능)

권장 CHECK 예시:

```sql
ALTER TABLE execution_audit_runs
ADD CONSTRAINT execution_audit_runs_operation_type_format_chk
CHECK (
  -- prefix가 있는 경우: segment(.segment)*.kebab-case
  -- 예: messaging.send-sms, attendance.update-attendance
  operation_type ~ '^[a-z0-9]+(\.[a-z0-9]+)*\.[a-z0-9]+(-[a-z0-9]+)*$'
  OR
  -- prefix가 없는 경우: kebab-case
  -- 예: send-sms, update-attendance
  operation_type ~ '^[a-z0-9]+(-[a-z0-9]+)*$'
);
```

⚠️ 정합성: 위 정규식은 prefix 형식(`messaging.send-sms`)과 prefix 없는 형식(`send-sms`) 모두를 허용한다.
- prefix segment는 [a-z0-9]+로 구성되며, 마지막 토큰은 kebab-case(하이픈 포함 가능) 또는 단일 단어(하이픈 없음) 허용이다.
- 단일 토큰 형식(`send-sms`, `send`)은 prefix 없는 형식으로 분류된다.
- prefix가 있는 경우 최소 2개 토큰(prefix + 마지막 토큰)이 필요하다.

8.B.3 details allowlist는 "서버 최종 책임" + DB는 최소 방어(트리거 권장)

**성능 고려사항 (P0):**
- 서버 레벨 캐싱 필수: operation_registry의 allowed_details_keys를 서버에서 캐싱하여 매 INSERT마다 DB 조회를 최소화
  - 캐싱 전략: operation_registry 전체를 메모리에 로드하여 캐시 유지
  - 캐시 갱신: operation_registry 변경 시 캐시 무효화 및 재로드
  - 캐시 미스 시에만 DB 조회 수행
- DB 트리거는 2차 방어로만 사용: 서버 구현 실수/우회 삽입을 대비한 최소 방어
  - 서버 레벨 캐싱으로 대부분의 allowlist 검증을 수행하므로, DB 트리거는 예외적인 경우에만 동작
  - 트리거는 서버 레벨 검증을 우회한 직접 DB 삽입 시에만 동작하도록 설계

DB가 operation_type별 allowlist를 완전 강제하려면 registry 조회가 필요하므로 트리거가 적합하다.

CREATE OR REPLACE FUNCTION enforce_execution_audit_details_allowlist()
RETURNS trigger AS $$
DECLARE
  allowed jsonb;
  k text;
BEGIN
  -- registry 조회 (DB 정본일 때)
  SELECT allowed_details_keys INTO allowed
  FROM meta.operation_registry
  WHERE operation_type = NEW.operation_type;

  IF allowed IS NULL THEN
    -- registry 미등록이면 DB에서도 방어 (서버에서도 동일 정책 적용)
    RAISE EXCEPTION 'unknown_operation: %', NEW.operation_type;
  END IF;

  -- allowlist에 없는 키가 있으면 예외(또는 제거)
  FOR k IN SELECT jsonb_object_keys(COALESCE(NEW.details, '{}'::jsonb))
  LOOP
    IF NOT (allowed ? k) THEN
      RAISE EXCEPTION 'details key not allowed: %', k;
    END IF;
  END LOOP;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_enforce_execution_audit_details_allowlist ON execution_audit_runs;
CREATE TRIGGER trg_enforce_execution_audit_details_allowlist
BEFORE INSERT OR UPDATE ON execution_audit_runs
FOR EACH ROW EXECUTE FUNCTION enforce_execution_audit_details_allowlist();


운영에서 “예외 대신 제거” 정책을 원하면, 트리거에서 불허 키를 제거하고 남긴 뒤 저장하도록 바꿀 수 있다.
단, Fail-Closed 철학상 불허 키가 들어오면 예외가 더 명확하다.

9. RLS / 보안 (P0)
9.1 RLS 원칙

execution_audit_runs, execution_audit_steps는 tenant_id 기반 RLS를 강제한다.

UI는 tenant_id를 직접 전달하지 않는다(Zero-Trust).
SDK/서버에서 컨텍스트로 주입한다.

9.2 접근 권한 (Role Scope 고정, P0/P1)

기본:

tenant 범위에서 owner/admin(운영자/관리자) 만 조회 가능

확장(권장):

super-admin(플랫폼 운영) 은 cross-tenant 조회 가능
(별도 정책 경로로 통제 + 별도 API route/guard 권장)

민감 필드(details)는 역할에 따라 마스킹 가능(정책으로).

9.3 Fail-Closed

권한이 불명확하면 “빈 결과”로 조용히 실패하지 말고,

조회는 permission_denied로 에러 또는 안전한 403 응답을 반환한다

실행 차단은 Execution Audit에 기록(3.6)

10. API/SDK 계약 (정합성/성능 핵심)

모든 조회는 api-sdk를 통해서만 수행한다(불변).
UI가 임의 SQL/직접 REST를 호출하지 않는다.

10.1 목록 조회

GET /execution-audit/runs?from=&to=&status=&operation_type=&source=&q=

기본 정렬: occurred_at desc

페이징 필수(cursor 기반 권장)

**cursor 기반 페이징 구현 가이드:**
- cursor 파라미터: `?cursor={last_occurred_at}:{last_id}` 형식 (타임스탬프:UUID 조합)
- 응답: `{ items: [...], next_cursor?: string, has_more: boolean }`
  - `has_more`와 `next_cursor` 동시 사용 시: `has_more`는 현재 페이지에 더 많은 항목이 있는지 여부, `next_cursor`는 다음 페이지 조회용 cursor
  - `next_cursor`가 null이면 `has_more=false`로 간주
- cursor가 없으면 첫 페이지, cursor가 있으면 해당 시점 이후 조회
- occurred_at desc 정렬 기준으로 cursor 생성
- 동일 시각 처리: occurred_at이 동일한 경우 id를 추가 정렬 기준으로 사용하여 cursor 생성 (예: `{occurred_at}:{id}` 형식)
- 페이지 크기: 기본 20건, 최대 100건 (쿼리 파라미터로 조정 가능)

10.2 상세 조회

GET /execution-audit/runs/{run_id}
GET /execution-audit/runs/{run_id}/steps?cursor=...

⚠️ 성능 고려: Step 조회는 대량 Step(수천 건)을 고려하여 cursor 기반 페이징 필수 적용 (10.1 cursor 기반 페이징 구현 가이드 참조).
- 페이지 크기 제한: 기본 20건, 최대 100건 (쿼리 파라미터로 조정 가능)
- Step 수가 많은 Run(예: 1000건 이상)에 대한 경고: UI에서 "Step이 많아 조회 시간이 걸릴 수 있습니다" 메시지 표시 권장

**대량 Step 처리 전략:**
- Step 수가 1000건 이상인 Run의 경우:
  - 집계 모드 제공: counts 필드(8.1 참조)를 활용하여 Step 목록 조회 없이 성공/실패 카운트만 표시
  - 또는 Step 조회 시 경고 메시지 표시 및 사용자 확인 후 조회 진행
  - counts 필드가 없는 경우, 서버에서 집계하여 counts를 동적으로 생성하여 반환 가능

10.3 검색(q)

q는 summary, error_summary, reference의 일부 키만 대상으로 제한한다.

허용 키(정본, P2지만 강제 권장):

request_id

task_id

automation_id

job_id

entity_id

source_event_id

diagnostic_id

기본 전략: 정확 일치 키 검색 우선 적용, 실패 시 prefix match 적용.

**구현 예시:**
- reference JSONB 검색: `reference->>'request_id' = q OR reference->>'task_id' = q` (정확 일치)
- prefix match: `reference->>'request_id' LIKE q || '%' OR reference->>'task_id' LIKE q || '%'` (prefix match)
- summary/error_summary 검색: `summary ILIKE '%' || q || '%' OR error_summary ILIKE '%' || q || '%'` (제한적 부분일치, 인덱스 기반)

무제한 부분일치(partial LIKE) 검색은 금지한다 (P0 성능).

11. UI 표현 원칙 (AI와의 분리, P0)
11.1 레이아웃

AI 패널 내부를 탭 2개로 분리하는 것을 권장한다:

탭 A: AI 대화

탭 B: Execution Audit

**업종별 공통 사용:**
- ExecutionAuditPanel 컴포넌트(`packages/ui-core/src/components/ExecutionAuditPanel.tsx`)는 모든 업종에서 공통으로 사용 가능합니다.
- AILayerMenu 컴포넌트(`packages/ui-core/src/components/AILayerMenu.tsx`)는 ChatOps와 Execution Audit를 탭 구조로 통합한 전역 AI 우측 레이어 메뉴입니다.
- 업종별 차이는 prop을 통한 확장 포인트로 처리되며, 업종별 하드코딩은 금지됩니다.
- Automation & AI Industry-Neutral Rule ([Industry_Neutrality.md](./Industry_Neutrality.md))을 준수합니다.

**Execution Audit 시스템의 업종 중립성:**
- Execution Audit 시스템 자체는 완전히 업종 중립적으로 구현되어 있습니다 (본 문서 0.4 섹션 참조).
- `execution_audit_runs`, `execution_audit_steps`, `meta.operation_registry` 테이블은 모든 업종에서 공통으로 사용됩니다.
- 새로운 테넌트 추가 시 코드 수정 없이 즉시 사용 가능합니다.

11.2 Execution Audit UI는 채팅이 아니다

타임라인/리스트 기반

Run 중심 → 클릭 시 Step 확장

필터(최소):

기간(오늘/이번주/커스텀)

상태(success/failed/partial)

operation_type

source

실패만 보기 토글

11.3 AI에서 Execution Audit로 연결

AI가 실행 요청을 제출하면 AI 탭에는:

"요청 접수됨(run_id/request_id)"까지만 표시
- ⚠️ 참고: run_id는 execution_audit_runs.id를 의미
- request_id는 automation_actions.request_id와 execution_audit_runs.reference.request_id 모두 동일한 형식 사용(챗봇.md 6.3.1 참조)
- automation_actions 기록 후 execution_audit_runs도 생성되어야 하므로, 두 테이블 모두 참조 가능

"Execution Audit에서 보기" 버튼으로 해당 run_id 필터 프리셋 이동

금지: AI 스트림에 "발송 완료" 같은 결과 문장 출력

12. 이벤트 생성 지점 (중요: 누락 방지)

Execution Audit Run을 생성하는 주체:

AI 승인 실행(서버)
- ⚠️ 중요: automation_actions 기록 후 execution_audit_runs도 생성되어야 함(챗봇.md 642줄: "Execution Audit 시스템에 실행 결과 기록" 참조)
- automation_actions.action_type='approve-and-execute' 실행 시 execution_audit_runs도 함께 생성
- automation_actions.request_id를 execution_audit_runs.reference.request_id로 전달

자동화 엔진 실행(서버/스케줄러)

배치/집계 작업(서버)

수동 실행(관리자 액션, 서버)

웹훅 수신 처리(서버)

규칙:
"실행 결과가 존재하는데 Run이 없다"는 상태를 금지한다.
(P0: 운영 추적 붕괴)

13. 성능/확장성/유지보수성 설계 검증 (문서 내장 체크)
13.1 성능 (P0 방지)

Run/Step 분리로 대량 실행(수천 건)에도 리스트는 가볍게 유지

목록은 summary 중심, details는 지연 로딩

필터 쿼리는 인덱스 기반으로만 동작하도록 설계

무제한 검색/와일드카드 남발 금지

13.2 확장성 (P1 방지)

operation_type은 텍스트 확장 가능(새 기능 추가 시 스키마 변경 최소)

details/reference/counts jsonb로 안전 확장

source/actor 확장 가능

13.3 유지보수성 (P1/P2 방지)

실행 결과의 진실은 Execution Audit 한 곳

AI/자동화/스케줄러 변경 시 Execution Audit 계약만 유지하면 UI/CS가 안정

실패 사유 code 표준화로 운영 매뉴얼/CS 스크립트 자동화 가능

14. 오류/리스크 사전 차단 목록 (P0/P1/P2)
P0 (절대 발생 금지)

AI가 결과를 단정해 출력(“발송 완료”)
→ 무조건 Execution Audit로만

partial 없는 실패 모델
→ 운영/CS 붕괴

tenant 스코프 누락/혼선
→ 데이터 유출

목록 조회에 step를 같이 실어 대량 payload
→ 성능 붕괴

correlation key 없는 고아 로그 다량 발생
→ 추적 불가 (7.3, 7.4 참조: 서버+DB 이중 강제)

details/jsonb에 원문 전문/PII가 유입
→ 컴플라이언스/보관/유출 리스크
→ allowlist 기반 강제 + 서버 책임 고정 + DB 2중 방어(8.1, 8.B)

registry 없는 “등록 필수” 선언
→ 강제 불가능한 규칙(허언)
→ operation registry 정본 위치/형식 고정(8.A)

P1 (운영 단계에서 크게 터짐)

operation_type 난립(표준 없이 임의 문자열)
→ 필터/통계/CS 불가능
→ 해결: kebab-case 고정 및 operation registry 등록 필수 (8.1, 8.A)

Step=0 케이스의 의미 혼선
→ 운영 판단 흔들림
→ 해결: No-op(대상 0건)은 failed + no_targets로 고정(1.6, 4.1, 5.1)

actor_id 타입 혼용(uuid/text)
→ 타입 안정성/SDK/프론트 분기 지옥
→ 해결: actor_id text 단일 규칙(6.2)

P2 (품질 저하)

summary 문구 스타일 제각각
→ 검색/가독성 저하
→ 해결: summary 템플릿 규칙 문서화(8.A registry의 default_summary_template 활용)

failure code 미표준
→ 자동 재시도/CS 분류 불가
→ 해결: error_code 코드북(부록) 고정

15. AI(챗봇) 문서에 들어갈 "위임 선언" (필수 연결 문구)

AI(ChatOps) 정본 문서에는 반드시 아래 문장을 포함한다:

AI 대화창은 실행 결과를 직접 출력하거나 판정하지 않는다.
모든 실행 결과(성공/실패/부분실패/차단/중단)는 Execution Audit 시스템에 기록되며,
사용자는 Execution Audit 영역에서 실행 결과를 확인한다.
Execution Audit의 상세 구조·상태 정의·운영 규칙은 Execution Audit SSOT 문서를 정본으로 한다.

⚠️ 참고: automation_actions와 execution_audit_runs의 관계
- automation_actions(챗봇.md 정본): 워크플로우 이벤트 기록(승인요청/실행 이벤트)
- execution_audit_runs(본 문서 정본): 실행 결과 기록(실제 실행 결과)
- automation_actions 기록 후 execution_audit_runs도 생성되어야 함(챗봇.md 642줄: "Execution Audit 시스템에 실행 결과 기록" 참조)
- automation_actions.request_id와 execution_audit_runs.reference.request_id는 동일한 형식 사용(챗봇.md 6.3.1 참조)

16. 부록 A — error_code 코드북 (정본 권장)

본 부록은 운영/CS 자동화를 위해 권장되며, 가능하면 정본으로 고정한다.
(최소한 아래 키워드는 error_code로 유지)

**error_code 네이밍 규칙:**
- 형식: snake_case (소문자 + 언더스코어)
- 도메인 prefix 권장: `{domain}_{error_type}` (예: `vendor_timeout`, `policy_disabled`)
- 확장 시: 새 error_code 추가는 SSOT 문서에 등록 필수, 코드북에 추가 및 사용 예시 기록

**error_code 확장 절차 (체크리스트):**
1. 코드북(본 부록 16.A)에 error_code 추가
   - error_code 값: 네이밍 규칙 준수 (snake_case, 도메인 prefix 권장)
   - description: 에러 설명
   - 사용 예시: 언제 이 error_code를 사용하는지 명시
   - 적절한 카테고리(16.A.1~16.A.5)에 추가하거나, 새 카테고리 생성
2. SSOT 문서(본 문서)에 error_code 추가 및 사용 예시 기록
   - 코드북(16.A)에 추가한 error_code를 본 문서에도 반영
3. 테스트: Run 생성 시 error_code 검증 테스트
4. 문서화: 코드북(16.A)과 SSOT 문서(본 문서) 모두에 error_code 추가 및 사용 예시 기록
   - 코드북은 운영/CS 자동화를 위한 참조 자료
   - SSOT 문서는 구현 규칙 및 확장 절차를 정의하는 정본

16.A.1 정책/권한/검증

permission_denied

policy_disabled

validation_error

tenant_scope_violation

16.A.2 미등록/미허용

unknown_operation

16.A.3 No-op

no_targets

16.A.4 외부 연동

vendor_timeout

vendor_rejected

vendor_error

webhook_invalid_signature (필요 시)

16.A.5 시스템 보호

rate_limit_triggered

circuit_breaker_open

bulk_operation_throttled

17. 변경 이력
v1.0.0

Activity Execution & Audit System SSOT 최초 확정

v1.0.1

정합성/일관성/P0 차단 수정

P0-1: Run-Step 관계 모순 수정 (1 Run : 0..N Step, Step=0 케이스 명시)

P0-2: reference 규칙을 correlation key 필수로 재정의 (request_id/source_event_id/diagnostic_id 추가)

P1-1: 3.2 집계/리포트 항목 중복 제거

P1-2: actor_type 정리 (user/system/external)

P1-3: action_type 난립 방지 규칙 강화 (표기 규칙 고정, registry 등록 필수)

P2-1: counts를 optional로 명시 (다건 실행에서만 사용)

P2-2: q 검색 제한 강화 (prefix match/정확 일치 우선)

v1.0.2

core-activity 충돌 방지 및 구현 리스크(P0/P1) 제거

P0-3: “Activity(core-activity 피드)”와 혼동 방지를 위해 시스템 명칭을 Execution Audit로 고정

P0-4: 테이블 접두어를 activity_* → execution_audit_* 로 변경(명칭 충돌 방지)

P0-5: action_type 용어 충돌 방지: activity_runs.action_type → execution_audit_runs.operation_type 로 변경

P0-6: operation_type 표기 규칙을 kebab-case(하이픈)로 고정 + registry 등록 필수

P0-7: details/jsonb PII 유입 차단: allowlist 기반 저장 규칙을 정본에 명시

P1-4: Step 생성 기준을 “관찰 가능한 결과 단위”로 구체화(외부요청/응답/커밋/타임아웃 포함)

P1-5: 조회 권한 스코프를 tenant-admin vs super-admin 계층으로 고정(정책 경로로 통제)

v1.0.3

강제 불가능 규칙 제거(강제 메커니즘 SSOT화) + 운영 판정 안정화

P0-8: correlation key 필수 규칙을 “서버 Insert Gate + DB Constraint” 이중 강제로 SSOT화

P0-9: operation registry(카탈로그) 정본 위치/형식/최소 필드를 문서에 포함(강제 가능화)

P0-10: details allowlist 책임 주체를 서버 Insert Layer로 고정 + DB 2중 방어 권장

v1.0.4

정밀 검증 반영 및 정합성/일관성 개선

P0-11: 챗봇.md와의 용어 불일치 해결 ("Activity 시스템" vs "Execution Audit 시스템" 명시)
P0-12: execution_audit_idempotency 테이블 중복 기능 해결 (automation_actions.request_id와의 관계 명확화)
P0-13: operation_type 매핑 규칙 명확화 (단계별 매핑 절차 명시)
P0-14: 재시도 연관 규칙과 correlation key 우선순위 정리 (retry_of_run_id를 5순위로 명시)

P1-8: partial 상태 정의 통일 (5.1을 정본으로 하고 1.5, 3.7은 참조로 변경)
P1-9: Step 생성 기준 통일 (4.1을 정본으로 하고 3.2는 참조로 변경)
P1-10: 8.B.1 CHECK 제약과 7.2 우선순위 일치 (확장 CHECK 제약 예시 추가)

P2-5: reference 필드 인덱스 전략 전환 기준 명시 (일일 조회 빈도 > 1000회)
P2-6: source/actor_type 확장 절차 통합 (6.4 공통 확장 절차 섹션 추가)
P2-7: error_code 확장 절차와 코드북 관계 명확화 (코드북과 SSOT 문서의 역할 구분)

성능-1: Step 조회 시 대량 데이터 처리 전략 보강 (집계 모드 제공)
성능-2: details allowlist 트리거 성능 고려 보강 (서버 레벨 캐싱 필수 명시)

설계-1: counts 필드 사용 규칙 명확화 (Step 10개 미만/이상 기준 명시)
설계-2: Step 생성 전략의 선택 기준 명확화 (1000건 기준 명시)

확장성-1: operation_type 형식 정규식 주석 보강 (예시 및 설명 추가)
확장성-2: version 필드 형식 검증 규칙 추가 (선택적 CHECK 제약 예시) �
