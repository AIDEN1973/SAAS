# 📘 DearSSam Multi-Tenant Academy SaaS — Technical Architecture v3.3

(Zero-Management · SDUI · AI-Driven · Multi-Tenant · Regional Analytics)

## 0. 개요(Overview)

### 0.1 문서 목적

**⚠️ 2-1: 문서 목적 명확화 (상위 개요 + 참조 허브):**

본 문서는 디어쌤 학원관리 프로그램의 주요 기능 요구사항(SRS)과 상위 레벨 기술 아키텍처를 통합 정리하고, 상세 스키마/모듈/UX 규약은 각각의 전용 문서를 정식 출처로 참조한다:

- **상세 DB 스키마 / 모듈별 구현 가이드**: 전체 기술문서 참조 (T1, T3 등)
- **SDUI/컴포넌트/반응형/다크모드 규약**: UI/UX Technical Architecture 참조 (U6)
- **Schema Registry/Editor/Meta-Schema**: 스키마엔진 문서 참조 (S3)
- **Regional Analytics SRS/알고리즘 상세**: 통계문서 참조 (RA1)

본 문서는 **"마스터 개요 + Cross-Reference 허브"** 역할을 수행하며, 각 도메인별 상세 스펙은 위 전용 문서를 정본으로 따른다.

**AI 코드 생성 규약:**
- AI 코드/SQL 생성 시 적용되는 규칙은 AI_자동검증_프로세스 문서를 따른다.

**참조 번호 사용법은 0.8 참조 문서 매핑표를 참조하세요.**

### 0.2 대상 범위

- 전체 시스템 개요
- 사용자 유형 및 권한
- 핵심 도메인 SRS
- 지역 기반 통계 SRS
- 메시지/알림 SRS
- AI 분석 기능 SRS
- 기술 아키텍처 (Multi-Tenant / RLS / SDUI / Zero-Trust / API SDK)

### 0.3 핵심 철학 — Zero-Management Platform

디어쌤은 "Zero-Management(관리 필요 없음)"을 목표로 설계된 AI 기반 학원 운영 자동화 플랫폼이다.

사용자가 어떤 기능을 찾아서 조작하기보다, 시스템이 먼저 판단·추천·자동 실행하며, 필요한 경우에만 사용자가 승인·확인하도록 한다.

즉, 학원 원장/선생님은 로그인하지 않아도 운영이 돌아가는 시스템을 경험하게 된다.

### 0.4 시스템 특성

디어쌤 학원관리 시스템은 출결버스 + 결제버스 + 지역통계 + AI 분석이 결합된 한국 최초의 엔터프라이즈 멀티테넌트 학원 SaaS이다.

또한 Multi-SaaS 플랫폼으로 학원/미용실/부동산 등 여러 업종을 단일 코드베이스에서 운영한다.

**⚠️ 본 문서의 범위:**

본 문서는 Multi-SaaS Monorepo 중 '학원 업종(Academy)'에 해당하는 DearSSam 앱군(academy-admin / academy-parent)을 기준으로 작성하되, Core Platform / Event Engine / Payment / Notification / Regional Analytics / AI 구조는 다른 업종(Salon, Real Estate 등)에서도 동일하게 재사용되는 것을 전제로 한다.

**핵심 특징:**

- 출결버스 기반 기능을 완전 상위 호환
- 매출·학생 수·출석률 등을 지역 단위로 비교하는 지역 기반 통계 탑재
- 결제(카드/계좌/간편결제) 완전 통합
- 학생/반/출결/수납/메시지 전 기능 통합
- 반응형 완전 지원
- SDUI 기반 화면 자동 생성
- RLS 기반 완전한 데이터 격리
- AI 기반 상담일지 분석, 출결 이상 탐지, 운영 리포트 생성
- 초기 사용자도 즉시 사용할 수 있는 단순 UI 기반, 고급 기능은 숨겨진 Advanced Panel에서만 제공

### 0.5 도메인 구성도

아래 7개가 메인 도메인이다:

1. 학생관리(Student Management)
2. 반/강사 관리(Class & Teacher Management)
3. 출결 관리(Attendance Management)
4. 수납/청구 관리(Billing & Payment)
5. 메시지/공지(Notification System)
6. 지역 기반 통계(Regional Analytics)
7. AI 분석 기능(AI Insights)

### 0.6 용어정의(Glossary)

- **Zero-Management**: 관리 필요 없음, 시스템이 자동으로 운영
- **SDUI**: Schema-Driven UI, 스키마 기반 화면 자동 생성
- **RLS**: Row Level Security, 행 단위 보안 정책
- **Multi-Tenant**: 멀티테넌트, 단일 인스턴스에서 여러 고객 격리
- **Regional Analytics**: 지역 기반 통계, 지역 단위 비교 분석
- **Auto-Billing**: 자동 청구 생성 및 발송
- **Partial Payment**: 부분납부, 청구 금액의 일부만 납부
- **Early Payment**: 조기납부, 기간 내 조기 납부 시 할인
- **StudentTaskCard**: 학생 업무 카드, AI가 자동 생성하는 업무 목록

### 0.7 문서 버전 히스토리

- v3.0: 기술 아키텍처 기본 구조 정리 (Multi-Tenant / SDUI / AI / Regional Analytics 초안)
- v3.1: 출결버스·알림뱅크 매뉴얼 완전 반영, Event Engine/Quota/Abuse 정책, Early/Partial Payment, Regional Analytics Pipeline v1.0, AI Override/Undo/Feedback 구조 추가
- v3.2: 15개 Critical/High 이슈 해결 (industry_type enum 통일, 카드 규칙 통합, QR State Machine, Priority 단순화, Notification Retry 통합, 출결 설정 섹션 분리, 설정 UI 위치 통일 등)
- v3.3: Critical 3건, High 9건, Medium 17건 이슈 해결 (industry_type enum 완전 통일, 출결 설정 JSON 단일 정본 확정, Notification Retry 규칙 통합, 홈 대시보드 Priority Table 통일, Billing Home 우선순위 충돌 해결, Payment Webhook 전략 우선순위 명확화, 출결 Anti-Abuse Fingerprint 설명 통일, QR 토큰 만료 규칙 중복 제거, 클래스 도메인 Industry Layer 분리 규칙 추가, Regional Analytics 비교 그룹 로직 단일 정본 확정, AI Risk Weight 업종별 가중치 일관성 확보, AI Undo 규칙 권한 매트릭스 충돌 해결 등)

### 0.8 참조 문서 매핑표 (Reference Map)

본 문서는 상위 레벨 아키텍처와 주요 기능 요구사항을 다루며, 상세 스펙은 아래 전용 문서를 참조합니다.

**⚠️ 중요: 본 문서에서 다른 문서를 참조할 때는 아래 참조 번호를 사용합니다.**

| 참조 번호 | 문서명 | 실제 파일 | 역할 |
|---------|--------|---------|------|
| **T1** | 전체 기술문서 PART 1 | 전체 기술문서.txt | 전체 아키텍처/Monorepo/멀티테넌트/DB 모델 (RLS 정책: 3-1 섹션) |
| **T3** | 전체 기술문서 PART 3 | 전체 기술문서.txt | 결제·알림뱅킹/Public Gateway/Analytics/배치/통계 (결제 정책: 14-2-1-1 섹션, 출결 DB: PART 1 참조, AI 모델: 15 섹션) |
| **T6** | 전체 기술문서 PART 6 | 전체 기술문서.txt | Monorepo 구조 상세 정본 |
| **T7** | 전체 기술문서 PART 7 | 전체 기술문서.txt | Custom Domain 운영 가이드 정본 |
| **T18** | 전체 기술문서 PART 18 | 전체 기술문서.txt | Auth/RLS 매핑 정본 |
| **R1.1** | rules.md 1-1 | rules.md | Monorepo 구조 정본 |
| **R7.4** | rules.md 7-4 | rules.md | 결제/알림뱅킹 운영 정책 정본 |
| **S3** | 스키마엔진 v2.1 | 스키마엔진.txt | SDUI 구조 정본 (Schema Registry, Meta-Schema, Condition Rule, Action Engine 포함) |
| **U6** | UI/UX Technical Architecture v6.0 | UI/UX Technical Architecture v6.0 | 모바일 레이아웃/반응형 UX 정본 |
| **RA1** | 통계문서 v1.0 | 디어쌤 통계문서.txt | Regional Analytics 정본 |

**참조 표현 규칙:**
- 본 문서 내 참조: "본 문서 X.X 섹션 참조"
- 다른 문서 참조: 참조 번호 사용 예시
  - "전체 기술문서 PART 18 참조" → "T18 참조"
  - "rules.md 1-1절 기준" → "R1.1 기준"
  - "스키마엔진 문서 참조" → "S3 참조"
  - "통계문서 참조" → "RA1 참조"

## 1. 플랫폼 전체 아키텍처 (Platform Architecture)

### 1.1 Multi-SaaS Monorepo 구조

디어쌤은 단일 코드베이스에서 여러 업종 SaaS를 운영하는 Multi-SaaS 플랫폼이다.

**⚠️ 1-1: Monorepo 구조 vs rules.md 구조 정합성 확보:**

**Monorepo 구조 (개념적 레이어):**

실제 Monorepo 디렉터리 구조와 네이밍 규칙은 R1.1을 정본으로 따르며,
이 문서의 `/core-platform`, `/ui-core`, `/industry-*` 표기는 개념적 레이어 이름이다.

구현 시에는 다음과 같이 매핑한다 (개념 레이어명과 실제 패키지명 구분):

- `/core-platform` → `packages/core/*` (core-auth, core-tenancy, core-billing 등)
- `/ui-core`(개념) → `packages/ui-core` (실제 UI 패키지, `@ui-core/react`)
- `/industry-academy` → `packages/industry/industry-academy`
- `/industry-salon` → `packages/industry/industry-salon`
- `/industry-real-estate` → `packages/industry/industry-real-estate`
- `/schema-engine` → `packages/schema-engine` (SDUI 엔진)

**실제 Monorepo 디렉터리 구조 (R1.1 정본):**

**⚠️ 중요: 아래 구조는 공식 최종 Monorepo 구조입니다. 실제 패키지 이름/폴더 구조는 R1.1 및 T6을 정본으로 따릅니다.**

```
/packages
  /core/*                 # 업종 공통 Core Platform Layer
    /core-auth
    /core-tenancy
    /core-billing
    /core-notification
    /core-payment
    /core-analytics
    /core-config
  /industry/*             # 업종별 전용 레이어
    /industry-academy
    /industry-salon
    /industry-real-estate
  /ui-core                # UI Composition 계층 (실제 패키지)
  /design-system          # Theme/Tokens (ui-core가 소비하는 토큰 레이어)
  /theme-engine           # Theme Token / Tenant Theme Override 엔진
  /schema-engine          # SDUI 엔진
  /services/*             # 공통 서비스 레이어
  /hooks/*                # 공통 React Hooks
  /lib/*                  # 공통 유틸리티
  /env-registry/*         # 환경 변수 레지스트리

/apps
  /academy-admin          # 학원 관리자 앱
  /academy-parent         # 학부모 앱
  /super-admin            # Super Admin 앱 (전체 테넌트 관리)
  /public-gateway         # 공개 게이트웨이
```

**⚠️ 1-3: UI 계층 이름과 실제 UI 문서 계층 명시:**

`/ui-core`는 UI/UX Technical Architecture v6.0에 정의된
core-ui / design-system / theme-engine 계층을 포함하는 공통 UI 레이어를 의미한다.

UI 계층 구조:
- schema-engine → core-ui → design-system → theme-engine
- 스키마엔진의 실제 UI 의존성은 `schema-engine → @ui-core/react`이며, theme/tokens는 CSS 변수로 적용된다.

### 1.2 Core / Industry / App Layer 구조

**SDUI 우선순위 규칙:**

1. tenant override (테넌트별 커스텀 스키마)
2. industry override (업종별 스키마)
3. core default (공통 기본 스키마)

**Schema Registry의 industry_type:**

- 모든 스키마는 industry_type 필드로 업종 구분
- RLS 정책에서 industry_type 기반 접근 제어
- 업종별 독립적인 스키마 버전 관리

### 1.3 Supabase 기반 멀티테넌트 구조

**RLS(Row Level Security) 정책의 실제 테이블 단위 정의:**

**RLS 정책 3종:**

① tenant_id = auth.jwt().tenant_id
- 테넌트별 데이터 완전 격리
- 모든 테이블에 기본 적용

② industry_type = auth.jwt().industry_type
- 업종별 데이터 격리
- 업종 간 데이터 접근 차단

③ admin override 가능 여부
- 관리자 권한으로 특정 정책 우회 가능 여부
- Super Admin은 모든 테넌트 데이터 접근 가능

**⚠️ 2-3: RLS 예시 템플릿 (전체 기술문서와 형식 통일):**

**표준 RLS 템플릿 (FOR ALL + USING/WITH CHECK, JWT claim 기반):**

```sql
CREATE POLICY tenant_isolation_students ON public.students
FOR ALL TO authenticated
USING (
  tenant_id = (auth.jwt() -> 'tenant_id')::uuid
)
WITH CHECK (
  tenant_id = (auth.jwt() -> 'tenant_id')::uuid
);
```

**업종 격리 정책 예시:**

```sql
CREATE POLICY industry_isolation_students ON public.students
FOR ALL TO authenticated
USING (
  industry_type = (auth.jwt() -> 'industry_type')::text
)
WITH CHECK (
  industry_type = (auth.jwt() -> 'industry_type')::text
);
```

**관리자 우회 정책 예시:**

```sql
CREATE POLICY admin_override_students ON public.students
FOR ALL TO authenticated
USING (
  (auth.jwt() -> 'role')::text = 'super_admin'
  OR tenant_id = (auth.jwt() -> 'tenant_id')::uuid
)
WITH CHECK (
  (auth.jwt() -> 'role')::text = 'super_admin'
  OR tenant_id = (auth.jwt() -> 'tenant_id')::uuid
);
```

**참고:** 상세 설명과 변형(옵션2: 세션 변수 기반)은 전체 기술문서 3-2-2 참고

**⚠️ 2-1: RLS에서 role 사용 방식 명시 강화:**

`auth.jwt()->>'role'` 값은 Supabase Auth의 커스텀 클레임으로 주입되며,
실제 소스는 `auth.users` 테이블의 `metadata`에 있는 `role` 필드를 기준으로 한다.
(정확한 매핑 로직은 T18 참조)

**Zero-Trust 원칙:**

- Edge Function 내부에서 tenant_id를 절대 UI에서 받아오면 안 됨
- insert 시 tenant_id는 서버가 JWT에서 추출하여 삽입
- UI는 tenant_id를 직접 전달하지 않음
- 모든 데이터 접근은 RLS 정책을 통해서만 가능

**보안 감사 준수:**

- 모든 테이블에 RLS 정책 필수 적용
- RLS 정책 없이는 데이터 접근 불가
- 정책 변경 이력 추적 및 로그 보관

**RBAC 업종별 분리:**

- 역할(Role)은 업종별로 독립적으로 정의
- core-ui와 industry-ui의 역할 구분 명확화
- 업종 간 권한 격리 보장

**⚠️ RLS 정책 세부 규약:**

RLS 정책 이름 규칙과 세부 변형(옵션2: 세션 변수 기반 등)은 전체 기술문서 PART 18(T18) 및 rules.md 7장(R7.x)을 정본으로 따른다.

### 1.4 Zero-Trust Security Model

**Zero-Trust 원칙:**

- Edge Function 내부에서 tenant_id를 절대 UI에서 받아오면 안 됨
- insert 시 tenant_id는 서버가 JWT에서 추출하여 삽입
- UI는 tenant_id를 직접 전달하지 않음
- 모든 데이터 접근은 RLS 정책을 통해서만 가능

**AI 판단 히스토리 로그:**

- AI가 자율적으로 실행한 모든 의사결정은 다음을 로그로 보관:
  - 시간
  - 입력 데이터
  - 판단 근거
  - 실행 결과
  - 사용자 보정 여부
- Zero-Trust UI 규칙과 맞물려 모든 AI 행동 추적 가능

### 1.5 Event-Driven Architecture(EA) 개요

디어쌤의 모든 자동화는 아래 4가지 Event Source에 의해 실행된다:

**Time-based Events (시간 기반 배치)**
- 04:00 자동 청구 생성
- 월말 자동 리포트 생성
- 매일 아침 AI 데일리 브리핑 생성 (07:00)

**Behavior-based Events (사용자 행동 기반)**
- 학생 등원/하원 이벤트 발생 시 출결 메시지 자동 발송
- 상담일지 저장 시 AI 자동 요약
- 결제 완료 시 영수증 자동 발송

**Pattern-based Events (AI 감지 기반)**
- 결석 패턴 이상 탐지
- 반별 출석률 저하 감지
- 학습·성적 기반 이탈 위험 감지
- 출결 패턴 변화 감지

**External Events (외부 시스템 + 센서)**
- QR 스캔
- 태블릿/키오스크 감지
- 결제 Webhook (알림뱅크)
- 날씨 API 변화 감지 (폭우 → 안내 문구 제안)

### 1.6 SDUI(Schema-Driven UI) 기반 화면 자동 생성

SDUI(Schema-Driven UI)는 디어쌤의 핵심 기술로, 화면 자동 생성 및 업종 간 재사용을 담당한다.

**도메인별 SDUI 적용 범위:**

| 도메인 | SDUI 기반 여부 | 커스텀 필요 여부 | 비고 |
|--------|---------------|-----------------|------|
| 학생 등록/수정 Form | 100% SDUI | 없음 | Form Schema로 완전 자동 생성 |
| 상담일지 작성 | 70% SDUI (Form) | 요약 결과 UI만 Custom | Form은 SDUI, AI 요약 결과는 Custom Widget |
| 반 생성 Form | 100% SDUI | 없음 | Form Schema로 완전 자동 생성 |
| 출결 화면 | SDUI 사용 ❌ | 완전 커스텀 | 실시간성 및 특수 UX 요구로 직접 구현 |
| 수납/청구 상세 | 50% SDUI (Table/Detail) | 결제 패널 Custom | Table/Detail은 SDUI, 결제 연동은 Custom Widget |
| 지역통계 | SDUI 사용 ❌ | 전용 Dashboard | 복잡한 차트/히트맵으로 전용 구현 |
| AI 인사이트 | 30% SDUI (Card/Widget) | 분석 결과 Custom | 카드 레이아웃은 SDUI, AI 결과는 Custom |

**SDUI 적용 원칙:**

- Form/Table/Detail/Filter는 가능한 한 SDUI로 생성
- 실시간성/특수 UX가 필요한 화면은 Custom 구현
- Custom Widget은 SDUI 내에서 동적 로딩 가능

### 1.7 AI-First Workflow 정의

사용자가 무엇을 해야 할지 고민하기 전에 AI가 먼저 분석·판단·제안·요약한다.

**예:**
- "오늘 결석생 3명 중 2명은 최근 1주간 상태가 좋지 않습니다. 연락을 추천합니다."
- "이번 주 수업 중 수학A반 출결률이 지역 평균 대비 12% 낮습니다. 원인을 분석할까요?"
- "이번 달 청구서가 자동 발송되었습니다. 예상 수납률은 92%입니다."

**AI Action Level 정의 (3단계):**

**Level 1 — AI Insight Only (해석만 제공)**
- 사용자가 판단할 수 있도록 설명·요약·분석을 제공
- 예: "지역 대비 출석률 +4% 상승"

**Level 2 — AI Suggestion (추천 + 초안 제공)**
- 행동은 사용자가 결정
- 예:
  - "안부 문자 초안 준비됨 → 발송하시겠습니까?"
  - "이번 반 출석률 저조 → 원인을 분석할까요?"

**Level 3 — AI Auto-Action (자동 실행)**
- 사용자 개입 없이 시스템 자체 실행
- 예:
  - 자동 청구 생성 및 발송
  - 자동 미납 알림
  - 자동 결제 재시도

### 1.8 반응형·기기별 적응형 UI 아키텍처(Adaptive UI)

UI는 동일하게 고정된 형태가 아니라, 사용자의 역할 / 시간대 / 상황 / 업무 흐름에 따라 자동으로 변한다.

**예:**
- 수업 시작 10분 전 → 자동으로 해당 반 출석부가 열린다
- 수업 종료 후 → 상담일지 작성 화면을 자동 추천
- 월말 → 청구 요약 카드가 자동 상단에 노출
- 비가 많이 오는 날 → AI가 하원 안전 안내문 자동 생성

**⚠️ C1: 반응형 규칙(PC/Tablet/Mobile) 구체화:**

**기기별 규칙 (Figma-Level 구체화):**

**PC (> 1024px)**
- 관리/정산/통계 등의 복잡한 기능 제공
- 데이터 밀도가 높은 대시보드
- 상세 분석과 편집 작업 중심
- **레이아웃 규칙:**
  - 학생 리스트: 테이블 형태 (컬럼: 이름, 학년, 반, 상태, 연락처, 액션)
  - 반 그리드: 4열 그리드 형태 (반 카드 4개씩 표시)
  - 확장 패널: 사이드바 또는 하단 패널로 상세 정보 표시
  - 대시보드: 2-3열 그리드 (카드형 레이아웃)

**Tablet (768px ~ 1024px, 특히 학원 태블릿)**
- 출결 모드가 기본 (자동 실행)
- QR 코드 표시 또는 학생 감지 기능
- 상담/학생관리 화면은 최소화
- 키오스크 모드(큰 번호 패드 + 등원/하원 버튼)
- **레이아웃 규칙:**
  - 학생 리스트: 카드 형태 (2열 그리드, 카드당 학생 정보 요약)
  - 반 그리드: 2열 그리드 형태 (반 카드 2개씩 표시)
  - 출결 화면: 큰 터치 버튼 중심 (등원/하원 버튼 최소 80px × 80px)
  - 키오스크 모드: 전체 화면, 큰 폰트 (최소 24px), 최소 터치 영역 44px × 44px

**Mobile (< 768px, 선생님·학부모)**
- 상황 기반 자동 화면이 기본:
  - 수업 시작 → 출석부
  - 수업 종료 → 상담일지 추천
  - 등원 발생 → 출결 히스토리 자동 갱신
- 메뉴보다 "오늘 해야 할 일"이 최상단
- **레이아웃 규칙:**
  - 학생 리스트: 카드 형태 (1열, 세로 스크롤, 카드당 학생 정보 요약)
  - 반 그리드: 1열 리스트 형태 (반 카드 세로 나열)
  - 출결 화면: 스와이프 가능한 카드 형태 (학생당 1카드, 좌우 스와이프로 다음 학생)
  - 홈 화면: 카드 스택 형태 (최대 8개 카드, 세로 스크롤)

**모바일/태블릿 자동 전환 조건:**

viewport width 기준:
- 모바일: < 768px
- 태블릿: 768px ~ 1024px
- 데스크톱: > 1024px

user agent 기준:
- 태블릿 디바이스 감지 시 키오스크 모드 옵션 제공
- 특정 태블릿 모델은 자동 키오스크 모드 활성화

## 2. 사용자/권한 구조 (RBAC Architecture)

### 2.1 사용자 유형(Role) 정의

**역할별 권한 요약**

| 역할 | 권한 요약 |
|------|----------|
| 원장(Admin) | 모든 기능 접근, 결제/수납/정산, 설정 |
| 실장(Sub Admin) | 학생/반/출결/수납 일부 접근 |
| 선생님(Teacher) | 출결, 학생 조회, 상담일지 |
| 보조선생님(Assistant) | 출결 입력 |
| 상담직원(Counselor) | 상담 기록, 등록 처리 |
| 학부모(Parent) | 등·하원 알림, 공지 조회, 수납 내역 |

### 2.2 역할별 권한 매트릭스

**Automation Permission Matrix (자동화 권한 행렬)**

자동 기능은 권한에 따라 실행 범위가 제한된다.

| 자동 기능 | Admin | Sub Admin | Teacher | Assistant | Parent |
|----------|-------|-----------|---------|-----------|--------|
| 자동 청구 생성 | 실행 + 보기 | 보기 | X | X | X |
| 미납 자동 알림 | 실행 + 보기 | 보기 | X | X | 수신 |
| 출결 자동 감지 | 보기 | 보기 | 보기 | 보기 | 수신 |
| AI 리포트 생성 | 보기 | 보기 | 요약만 | X | X |
| 자동 상담 요약 | 실행 | 실행 | 실행 | X | X |

**중요 원칙:**

- 자동 메시지 발송, 자동 수납 알림, 자동 청구 등은 원장(Admin) 권한 범위
- 선생님/보조교사에게는 자동화가 표시되기만 하고 실행 권한을 가지면 안 됨
- 상담직원, 실장 등 중간 권한에게 어떤 자동화가 적용되는지 명확히 정의

**AI Override 권한 매트릭스:**

| AI 기능 | Admin | Sub Admin | Teacher | Assistant |
|---------|-------|-----------|---------|-----------|
| Insight Override | 가능 | 가능 | 제한적 | 불가 |
| Suggestion Override | 가능 | 가능 | 가능 | 불가 |
| Auto-Action Undo | 가능 | 제한적 | 불가 | 불가 |
| 미납 관련 AI Override | 가능 | 불가 | 불가 | 불가 |

### 2.3 메뉴 접근 제어 규칙

**역할별 UI 단순화 원칙**

각 역할별 UI는 복잡한 메뉴를 모두 숨기며, 역할별로 필요한 핵심 기능만 노출한다.

**보조선생님(Assistant):**
- 출결 버튼만 노출
- 학생 검색 및 출결 체크만 가능
- **출결 수정 권한 없음**: 출결 기록 생성만 가능하며 수정 권한은 없다

**선생님(Teacher):**
- 오늘의 반 + 학생 리스트 + 출결 체크만 노출
- 상담일지 작성 기능 포함
- 통계/AI 요약 카드는 대시보드에서 확인 가능
- 고급 설정 메뉴 숨김
- **출결 수정 권한 있음**: 출결 입력 및 수정 모두 가능

**출결 수정 권한 명시:**

출결버스 기반 권한 규칙:

| 역할 | 출결 입력 | 출결 수정 |
|------|----------|----------|
| Teacher | ✅ 가능 | ✅ 가능 |
| Assistant | ✅ 가능 | ❌ 불가 |

**Assistant 출결 수정 제한:**
- Assistant는 출결 기록 생성만 가능
- 기존 출결 기록 수정 권한 없음
- 출결 수정이 필요한 경우 Teacher 또는 Admin에게 요청
- 출결 수정 시도 시 권한 오류 메시지 표시

**원장(Admin):**
- 전체 메뉴 노출
- 고급 기능 접근 가능
- 설정 및 정산 기능 포함

### 2.4 페이지/라우팅 접근 제어 (Frontend RBAC)

**권한별 라우팅 규칙**

권한에 따라 URL 접근을 제한하는 라우팅 규칙:

**Admin → 전체 접근 가능**
- 모든 URL 접근 가능
- /billing/**, /classes/**, /analytics/** 등 전체

**Sub Admin → billing 일부 제한**
- /billing/create, /billing/settings 접근 제한
- /billing/view, /billing/history 접근 가능
- /classes/**, /students/** 접근 가능
- /analytics/** 접근 가능

**Teacher → 출결/학생/AI 요약만**
- /attendance/** 접근 가능
- /students/view 접근 가능 (수정 제한)
- /ai/insights/summary 접근 가능 (상세 분석 제한)
- /billing/** 접근 금지
- /classes/schedule 접근 가능
- /analytics/region 접근 금지 (요약만 제공)

**Assistant → 출결만**
- /attendance/** 접근 가능
- /students/view 접근 가능 (읽기 전용)
- /billing/** 접근 금지
- /classes/** 접근 금지
- /analytics/** 접근 금지

**Parent → public-gateway API only**
- /public-gateway/payment/** 접근 가능
- /public-gateway/attendance/notifications 접근 가능
- /public-gateway/billing/history 접근 가능
- Admin 앱의 모든 URL 접근 금지

**라우팅 규칙 적용:**

- 프론트엔드 라우터에서 권한 체크 후 접근 제한
- 백엔드 RLS 정책과 일치하도록 설계
- 권한 없는 URL 접근 시 403 Forbidden 반환
- 권한 부족 시 자동으로 허용된 메뉴로 리다이렉트

**라우팅 충돌 방지:**

- 프론트엔드 라우터와 백엔드 RLS가 동일한 권한 규칙 사용
- 권한 변경 시 라우터와 RLS 정책 동시 업데이트
- 권한 테스트 시 프론트엔드/백엔드 모두 검증

**모바일/태블릿 기본 라우팅 규칙:**

모바일 및 태블릿에서는 역할별로 기본 진입 화면이 다르다:

```typescript
mobile_default_route_role_map = {
  teacher: '/attendance/today',      // 선생님은 출결 화면
  parent: '/public-gateway/home',    // 학부모는 공개 게이트웨이
  assistant: '/attendance/today',   // 보조선생님은 출결 화면
  admin: '/home',                    // 원장은 홈 대시보드
  sub_admin: '/home'                 // 실장은 홈 대시보드
}
```

**⚠️ Role 이름 표기 통일:**

- 문서 내 표/매트릭스의 한글 라벨: 원장(Admin), 실장(Sub Admin), 선생님(Teacher), 보조선생님(Assistant), 학부모(Parent)
- 실제 시스템 role 값(enum/문자열): 소문자 snake_case 사용 (`admin`, `sub_admin`, `teacher`, `assistant`, `parent`)

**모바일/태블릿 라우팅 일관성 규칙:**
- 모바일 접속 시 역할별 기본 화면으로 자동 리다이렉트
- 태블릿 접속 시 키오스크 모드 활성화 시 `/attendance/today`로 고정
- 역할 변경 시 기본 라우트도 자동 업데이트

### 2.5 Supabase RLS 정책 구조

(본 문서 1.3 섹션 참조)

### 2.6 Multi-Industry RBAC 확장

**Industry Layer 데이터 필드 템플릿 규칙**

업종별 스키마 차별화를 위한 규칙:

**Core Entity 확장 규칙:**

- Core Platform의 공통 엔티티(persons, parties 등)를 기반으로 확장
- 업종별 필드는 industry_* 접두사 사용
- 예:
  - academy_student { grade, subject_group, parents }
  - salon_customer { last_visit_at, preferred_style }
  - real_estate_tenant { contract_end_date, rent_cycle }

**업종별 필드 추가 규칙:**

- Schema Registry에 industry_type별 필드 정의
- 업종별 필드는 JSONB 또는 별도 테이블로 확장 가능
- RLS 정책에서 industry_type 기반 필드 접근 제어

**업종별 메뉴 숨김/노출 규칙:**

- SDUI 스키마에서 industry_type 조건으로 메뉴 표시 제어
- 예: academy는 "반 관리" 메뉴, salon은 "예약 관리" 메뉴
- Schema Engine이 industry_type에 따라 자동 필터링

**업종별 통계/AI 모델 분리 규칙:**

- 통계 집계 시 industry_type별로 별도 Materialized View 생성
- AI 모델도 업종별로 분리 학습 및 적용
- 업종 간 데이터 혼합 방지

**데이터 필드 템플릿 예시:**

**Academy (학원):**
- student: grade, subject_group, parents, class_id
- class: schedule, capacity, teacher_id
- attendance: check_in_time, check_out_time

**Salon (미용실):**
- customer: last_visit_at, preferred_style, stylist_id
- appointment: service_type, duration, price
- visit_history: service_date, stylist_feedback

**Real Estate (부동산):**
- tenant: contract_end_date, rent_cycle, property_id
- property: address, size, rent_amount
- contract: start_date, end_date, deposit

### 2.7 Parent App(학부모 앱) 권한 모델

**Parent UX (학부모 경험) 정의**

학원 원장은 1%의 시간만 쓰고, 학부모가 99%의 결제를 수행함.

**학부모 앱에서 자동 청구 알림 + 자동 결제 링크 제공**
- 청구서 생성 시 즉시 알림 발송
- 알림 클릭 시 결제 화면으로 자동 이동

**결제 성공 시 영수증 자동 발송**
- 결제 완료 즉시 영수증 자동 생성 및 발송
- SMS/앱 내 알림으로 제공

**자동 결제 실패 시 다음 시도 일정 안내**
- 실패 원인 및 재시도 일정 명확히 안내
- 추가 조치 필요 시 안내 메시지 제공

**자녀별 결제 내역 자동 정리**
- 자녀별로 결제 내역 분리 표시
- 결제 이력 및 미납 현황 한눈에 확인

## 3. 도메인 요구사항 (Domain SRS)

### 3.1 학생(Student) 도메인

#### 3.1.1 학생 관리 홈(Home) — 오늘의 학생 업무 카드

**라우팅 및 화면 구조**

학생 메뉴 첫 진입 시 라우트는 `/students/home`이며, 기본 화면은 항상 오늘의 학생 업무 카드(StudentTaskCard)이다.

전체 학생 목록은 `/students/list`로 분리되며, 홈 화면에서는 별도의 "전체 학생 보기" 버튼으로만 진입 가능하다.

**업무 중심 + AI 중심 방식**

학생관리 첫 화면은 리스트가 아니라 "오늘의 학생 업무 카드(자동 생성)"를 노출한다.

**기본 화면 구성 (업무 카드 중심)**

**[상담 필요 학생 2명]**
- AI가 상담일지 패턴 분석으로 자동 식별
- 카드 클릭 시 해당 학생 상세 + 상담일지 작성 화면으로 자동 이동

**[최근 3일 결석 학생 1명 – 부모 연락 필요]**
- AI가 결석 패턴 분석으로 자동 식별
- 카드 클릭 시 학부모 연락 화면 + AI 추천 메시지 초안 제공

**[성적/패턴 기반 이탈 위험 학생 1명]**
- AI가 출결·성적·상담 패턴 종합 분석
- 카드 클릭 시 이탈 위험 상세 분석 + 대응 방안 제시

**[신규 등록 학생 확인]**
- 최근 등록 학생 자동 표시
- 환영 메시지 발송 및 초기 설정 안내

각 카드를 누르면 필요한 화면으로 자동 이동하며, 화면이 곧 "해야 할 일 목록" 역할을 한다.

#### 3.1.2 "오늘의 학생 업무 카드" UI 스펙

**Data Model:**

```typescript
StudentTaskCard {
  task_type: 'risk' | 'absence' | 'counseling' | 'new_signup'
  student_id: UUID
  priority: number (1-100)
  title: string
  description: string
  action_url: string
  created_at: timestamp
  expires_at: timestamp (필수, 카드 만료 시점)
}
```

**UI Layout:**

카드 구조:
- 헤더: task_type 아이콘 + 우선순위 배지
- 제목: title (최대 2줄)
- 설명: description (최대 3줄)
- 액션 버튼: "처리하기" (action_url로 이동)
- 메타 정보: 학생 이름, 생성 시간

**필드 정의:**

task_type별 필드:
- risk: risk_level, risk_reason, recommended_action
- absence: absence_days, last_attendance_date, parent_contact_needed
- counseling: counseling_type, urgency, scheduled_date
- new_signup: signup_date, welcome_message_sent, initial_setup_needed

**task_type → URL 매핑 규칙:**

카드의 `action_url`은 `task_type`에 따라 아래 규칙으로 자동 생성된다:

```typescript
task_type_url_map = {
  counseling: `/students/${student_id}/counsel`,
  absence: `/students/${student_id}/attendance`,
  risk: `/students/${student_id}/risk`,
  new_signup: `/students/${student_id}/welcome`
}
```

**URL 생성 규칙:**
- `student_id`는 카드의 `student_id` 필드 값으로 치환
- 카드 클릭 시 해당 URL로 라우팅
- URL이 존재하지 않으면 404 에러 처리

**⚠️ 라우팅 공식 스펙 필요:**

현재 규칙은 유니버셜하나 실제 App Router 구조가 불명확:
- 상담일지는 `/students/{id}/notes/{noteId}`일 가능성 높음
- 출결 상세는 `/attendance/student/{id}` 가능성도 있음

**해결: "디어쌤 라우팅 공식 스펙 v1.0"을 별도 문서로 정의해야 함.**

**우선순위 계산:**
- 긴급도 (1-40) + 시간대 (1-30) + 담당 반/학생 (1-30)
- 최종 priority = 긴급도 + 시간대 + 담당 반/학생

#### 3.1.3 학생업무카드(StudentTaskCard) 생성 규칙

**카드 생성 시점 및 만료 규칙:**

**Generation Timing:**

**Daily batch at 06:00 (신규 카드 생성)**
- 매일 새벽 6시에 배치 작업 실행
- 전날 데이터 기반으로 새 카드 생성
- 기존 만료된 카드 정리

**Real-time generation triggered by:**
- 결석 이벤트: 학생 결석 발생 시 즉시 카드 생성
- 상담일지 저장: 상담일지 저장 시 상담 필요 카드 생성
- 이탈 위험 감지: AI가 이탈 위험 감지 시 즉시 카드 생성
- 신규 등록: 학생 등록 시 환영 카드 생성

**⚠️ M1: StudentTaskCard 만료 규칙(expires_at) 통일 (v3.3 확정):**

**카드 만료 로직 (단일 정본):**

**expires_at 설정 규칙 (필수 필드):**
- 상담 관련: 당일 자정 (23:59:59)
- 결석 관련: 3일 후 자정
- 신규등록: 7일 후 자정
- 이탈 위험: 5일 후 자정

**Stale 카드 삭제 규칙:**
- expires_at이 지난 카드는 자동 삭제
- 배치 작업에서 만료 카드 정리 (매일 06:00)
- 사용자가 처리 완료한 카드는 즉시 삭제

**⚠️ 다른 섹션에서 StudentTaskCard 만료 규칙을 언급할 때:**
- "3.1.3 학생업무카드 생성 규칙의 expires_at 설정 규칙 참조" 형태로만 언급
- 중복된 규칙 정의 제거

**카드 우선순위 재계산:**
- 실시간 이벤트 발생 시 우선순위 재계산
- 배치 작업에서 전체 카드 우선순위 재정렬

**학생업무카드 중복 생성 방지 규칙:**

동일한 카드가 중복 생성되는 것을 방지하기 위한 규칙:

```typescript
student_task_card_dedup = {
  // 동일 task_type + 동일 student_id + 동일 날짜 → 1장만 생성
  same_task_same_student_same_day: {
    condition: 'same task_type + same student_id + same day',
    action: 'keep_existing',
    update_priority: true
  }
}
```

**중복 방지 적용:**
- 같은 날 동일 학생에 대해 동일 task_type 카드는 1장만 유지
- 새 이벤트 발생 시 기존 카드의 우선순위만 업데이트
- 카드 내용이 변경된 경우 기존 카드 업데이트 (새 카드 생성 안 함)

**학생 업무 카드 우선순위 규칙:**

1순위: 위험/이상 상황
- 이탈 위험
- 출결 이상
- 긴급한 상담 필요

2순위: 당일 일정
- 오늘 상담 예정
- 신규 등록 처리

3순위: 주간 관리
- 3일 연속 결석
- 성취도 저하 패턴 감지

정렬 기준: 긴급도 → 시간대 → 담당 반/학생

#### 3.1.4 전체 학생 목록(List View) — 검색 및 상세

**역할 및 진입 경로**

이 화면은 업무 홈이 아닌 "고급/상세 조회 기능"이며, 기본 진입 동선은 학생 홈(TaskCard)에서 "전체 학생 보기" 버튼 또는 상단 탭 전환을 통해서만 가능하다.

**라우팅:** `/students/list`

**학생 기본 정보 조회**
- 이름, 학부모, 연락처, 대표반만 표시
- 학생 검색 및 기본 필터(학년, 반, 상태)

**학생 등록/수정**
- 최소 입력으로 학생 등록 가능
- 학부모 정보 관리
- 학생 상태(재원/휴원/퇴원) 변경

**반 배정 및 이동**
- 기본 반 배정 기능
- 반 이동 기능

**상담일지/학습일지 관리**
- 상담일지 작성 및 조회
- 학습일지 관리

#### 3.1.5 상담/학습일지 AI 요약

**기능 개요**

상담일지/학습일지 상세 화면에 "AI 요약" 버튼 추가.

입력된 텍스트를 기반으로:
- 요약 한 줄
- 핵심 키워드
- 행동 권장사항(선택)

**동작 방식**

1. 프런트에서 note_id와 원문 일부를 포함한 요청을 Edge Function에 전달
2. Edge Function이 LLM API 호출
3. 결과를 note_ai_summary 테이블에 저장(캐싱 용)

**⚠️ 상담일지 요약 시 개인정보 마스킹 규칙 (PII Masking):**

민감정보(학생 실명/전화번호 등)를 모델에 그대로 보내지 않도록 사전 마스킹 필수:

```typescript
pii_masking_rule = {
  // 마스킹 대상 정보
  masking_targets: {
    // 학생 실명
    student_name: {
      pattern: /[가-힣]{2,4}/g,
      replacement: '[학생]',
      preserve_length: false
    },

    // 전화번호
    phone_number: {
      pattern: /(\d{3})-(\d{4})-(\d{4})/g,
      replacement: '010-****-****',
      preserve_length: true
    },

    // 학원명 (⚠️ M6: 학원명 마스킹 패턴 조정)
    academy_name: {
      // 지나치게 광범위한 패턴 대신, 명시적 학원명만 마스킹
      pattern: /([가-힣]+학원|([가-힣]+(학원|아카데미|교육원)))/g,
      replacement: '[학원명]',
      preserve_length: false,
      // 학원명은 컨텍스트에 따라 선택적 마스킹 (필요한 경우만)
      conditional_masking: true
    },

    // 주소
    address: {
      pattern: /[가-힣]+시[가-힣]+구[가-힣]+동/g,
      replacement: '[주소]',
      preserve_length: false
    }
  },

  // 마스킹 적용 규칙
  masking_application: {
    // AI 요약 생성 전 자동 마스킹
    before_ai_processing: true,

    // 원본 데이터는 그대로 보관 (마스킹된 버전만 AI에 전달)
    preserve_original: true,

    // 마스킹 로그 기록
    log_masking: true
  }
}
```

**주의사항:**
- 민감정보(학생 실명/전화번호 등)를 모델에 그대로 보내지 않도록 사전 마스킹 필수
- 요약은 관리자/선생님 전용 화면에만 노출(학부모용 앱에는 기본 비노출)
- 원본 데이터는 보관하되, AI 처리 시에는 마스킹된 버전만 사용

#### 3.1.6 학생 태그 시스템 (고급 기능)

**테이블 구조(예시)**

```
tags:
- id, tenant_id, name, color, category(optional), active

student_tags:
- student_id, tag_id, created_at
```

**사용 예시**

"집중관리", "고위험 이탈", "성장 빠름", "수학강화", "영어회화" 등

**UI 요구**

- 학생 리스트에서 태그 칩(chip) 표시 (고급 옵션 활성화 시)
- 필터 패널에서 태그로 검색 가능 (고급 옵션 활성화 시)
- 태그 색상은 테넌트별 커스터마이징 허용

#### 3.1.7 다중 반 소속(멀티 클래스) (고급 기능)

**데이터 모델**

```
classes (기존)

student_classes (N:N):
- student_id, class_id, primary(bool), joined_at, left_at
```

**기능**

- 한 학생이 여러 반에 동시에 등록 가능
- "대표 반(primary class)" 개념을 도입하여 리스트 기본 표시에 사용
- 출결/청구/통계에서 class_id 기준 집계를 안전하게 처리

**UI 요구사항:**

- 학생관리 기본 화면에는 최소 정보(이름·학부모·연락처·대표반)만 표시하며,
- 태그·일괄등록·다중반 관리 등 고급 기능은 '고급 옵션(Advanced)' 버튼 클릭 시 나타난다.

### 3.2 반/강사(Class & Teacher) 도메인

#### 3.2.1 Today-First 기준

**신규 기본 화면 = "오늘 수업 있는 반"**

현재 시간 기준으로 곧 시작할 반이 상단 고정
- 반별 총원/출석/지각 간단 표시
- AI가 자동 강조:
  - "출석률 저조 반"
  - "강사 일정 충돌 가능성 있음"

**⚠️ H6: 클래스 도메인 Industry Layer 분리 규칙:**

**Core vs Industry 구분:**

클래스 도메인 기능은 Core Platform과 Industry Layer로 분리됩니다:

**Core Platform (업종 공통):**
- 반 기본 정보 (이름, 시간표, 강사 배정)
- 학생-반 다중 소속 관리
- 시간표 충돌 감지 (기본 로직)

**Industry Layer (업종별 차별화):**
- 반 자동 색상 태깅 (학원: 과목별, 미용실: 서비스별)
- 부담임 설정 (학원 전용)
- 반별 지각 기준 설정 (학원 전용)
- 반별 수업료 설정 (학원 전용)

**⚠️ M3-2: 클래스 도메인 Core vs Industry 구분 표:**

나중에 Schema/폴더 구조 잡을 때 바로 쓸 수 있게, 기능별 Layer 구분:

| 기능 | Layer |
|------|-------|
| class 기본 엔티티(이름/시간표) | core-platform |
| student_classes N:N | core-platform |
| 시간표 충돌 감지 (기본 로직) | core-platform |
| 반 자동 색상 태깅 | industry-academy |
| 부담임 설정 | industry-academy |
| 반별 지각 기준 (class_specific_late_rules) | industry-academy |
| 반별 수업료 설정 | industry-academy |

**⚠️ 모든 Class 기능에 대해 "Core vs Industry" 구분 주석이 필요합니다.**

#### 3.2.2 Schedule Conflict Detection (시간표 충돌 감지)

자동 출석부 표시 전에 아래 검증을 수행한다.

**충돌 감지 항목:**
- 담당 강사의 시간표 중복 여부
- 학생의 대표반/서브반 충돌 여부
- 교실 자원 중복 여부

**충돌 시나리오:**
- 선생님이 동시에 두 반을 맡고 있는 경우
- 동일 학생이 이중 배정된 경우
- 반 시간 일부가 겹치는 경우
- 교실이 중복 사용 중인 경우

**충돌 시 UI 처리:**
- "시간표 충돌 감지됨" 알림 표시
- "어떤 반을 우선할지 선택하십시오" 선택 화면 제공
- "AI 추천 반: 출석률 저조 반" 추천 정보 제공
- 충돌 해결 전까지 자동 출석부 열림 방지

#### 3.2.3 기본 기능

**오늘 수업 있는 반 목록**
- 오늘 수업이 있는 반만 기본적으로 표시
- 반별 학생 수 및 출결 현황 간단 표시
- 수업 시작 10분 전 자동으로 해당 반 출석부 열림 (Adaptive UI)

**⚠️ M5: 반 생성 최소 입력 조건 통일 (v3.3 확정):**

**반 생성 (최소 입력) - 단일 정본:**
- 반 이름만 입력해도 생성 가능
- 시간·요일·정원·색상 등은 고급 옵션에서 수정

**기본 강사 배정**
- 반별 강사 지정 (최소 정보만)

#### 3.2.4 고급 기능 (Advanced 옵션에서만 제공)

**전체 반/강사 관리**
- 모든 반 목록 조회 및 관리
- 반 상세 정보 수정

**반 편성표(Calendar-like)**
- 캘린더 뷰로 반 일정 확인
- 요일/시간별 반 편성표

**반 자동 색상 태깅**
- 반별 색상 자동 할당 및 커스터마이징
- **⚠️ Industry Layer에 위치:** `industry-academy` 레이어에 구현

**부담임 설정**
- 부담임 배정 및 관리
- **⚠️ Industry Layer에 위치:** `industry-academy` 레이어에 구현

**⚠️ 반/강사 도메인 Industry Layer 분리:**

"부담임 설정", "반 자동 색상 태깅"은 Industry Layer에 위치해야 함:
- Core Platform의 "class entity 확장"으로 OR
- `industry-academy` 레이어에 위치
- 현재 문서에는 학생·반 도메인의 일부로 보이지만, 실제 구현 시 Industry Layer로 분리 필요

**반별 상세 통계**
- 출결률/정원률/지각률 상세 표시
- 반별 성과 분석

**UI 요구사항:**

- 반 생성 시 최소 입력(반 이름만)으로도 생성 가능하며,
- 시간·요일·정원·색상 등은 고급 옵션에서 수정한다.
- 반 목록은 기본적으로 "오늘 수업 있는 반"만 표시하며,
- 전체 반 관리 및 편성표는 Advanced 영역으로 이동한다.

### 3.3 출결(Attendance) 도메인

#### 3.3.1 핵심 원칙

출결 기능은 실사용 빈도가 가장 높으므로 최소한의 조작으로 출결이 가능해야 한다.
출결 메인 화면은 "오늘 출결하기"와 "QR 출결 실행(학생용)" 두 개만 있어야 한다.

#### 3.3.2 자동 동작 기반 출결 (Zero-Interaction Principle)

**⚠️ AI 출석 예측값 적용 범위 원칙:**

AI 출석 예측값은 초기 상태에서만 기본 체크로 적용되며, Teacher의 모든 수동 입력은 AI 예측값을 즉시 override한다.

**신규 기능 반영**

**QR 감지 시 자동 등원 처리**
- QR 스캔 시 자동 등원 처리 (사용자 확인 최소화)

**고정 장치(태블릿)에서 학생 감지 시 자동 체크**
- 학생 인식 시 자동 출결 처리
- 선생님 화면에는 "입실 완료"만 표시

**AI가 출석을 "예측"하여 기본값 설정**
- 과거 출결 패턴 기반으로 오늘 출석 예상 학생 자동 체크
- 선생님이 확인/수정만 하면 됨

**⚠️ AI 출석 예측값 적용 범위 명확화:**

AI 예측 출석 체크는 teacher가 수동으로 언제든 수정 가능하며, AI 기본값 설정은 "초기 상태"에만 적용되고, 사용자 입력이 발생하면 AI 데이터는 override 된다.

```typescript
ai_attendance_prediction_rule = {
  // AI 예측값은 초기 상태에만 적용
  initial_state_only: true,

  // 사용자 입력 발생 시 AI 데이터 override
  user_input_overrides_ai: true,

  // Teacher는 언제든 수정 가능
  teacher_can_modify: true,

  // AI 예측 실패 시 fallback
  fallback_on_prediction_failure: {
    action: 'show_all_students_unchecked',
    allow_manual_check: true
  }
}
```

**적용 범위:**
- AI 예측값은 화면 초기 로드 시에만 기본값으로 설정
- Teacher가 출석 체크를 변경하면 AI 예측값은 무시됨
- AI 예측 실패 시 모든 학생을 미체크 상태로 표시
- 사용자가 수동으로 체크 가능
- AI 예측값은 100% 자동 체크가 아닌 "초기 추천값" 역할만 수행

**검색 없이 "오늘 수업 학생만" 기본 노출**
- 반별 오늘 수업 학생만 자동 필터링
- 불필요한 검색 과정 제거

#### 3.3.3 기본 UI (매일 사용하는 기능)

**⚠️ C2: 출결 화면의 실제 컴포넌트 구조:**

**출결 화면 컴포넌트 트리:**

```
AttendanceScreen (출결 화면)
├─ AttendanceHeader (헤더)
│  ├─ 반 선택 드롭다운
│  ├─ 날짜 선택
│  └─ 검색 입력
│
├─ AttendanceStudentList (학생 리스트)
│  ├─ StudentCard (학생 카드) × N
│  │  ├─ StudentInfo (학생 정보)
│  │  │  ├─ 이름
│  │  │  ├─ 학년/반
│  │  │  └─ 사진 (선택)
│  │  │
│  │  ├─ AttendanceStatus (출결 상태)
│  │  │  ├─ 등원 체크박스
│  │  │  ├─ 하원 체크박스
│  │  │  ├─ 지각/결석 배지
│  │  │  └─ AI 예측 표시 (선택)
│  │  │
│  │  └─ ActionButtons (액션 버튼)
│  │     ├─ 등원 버튼
│  │     ├─ 하원 버튼
│  │     └─ 상세 보기 버튼
│  │
│  └─ EmptyState (학생 없음)
│     └─ "오늘 수업 학생이 없습니다" 메시지
│
├─ AttendanceSummary (출결 요약)
│  ├─ 총원
│  ├─ 출석 수
│  ├─ 지각 수
│  └─ 결석 수
│
└─ AttendanceActions (출결 액션)
   ├─ 일괄 등원 버튼
   ├─ 일괄 하원 버튼
   └─ 저장 버튼
```

**출결 화면 상태 변환 (State Machine):**

```typescript
attendance_screen_state_machine = {
  initial: 'loading',
  states: {
    loading: {
      on: {
        DATA_LOADED: 'ready',
        ERROR: 'error'
      }
    },
    ready: {
      on: {
        STUDENT_SELECTED: 'editing',
        BULK_ACTION: 'bulk_processing',
        SAVE_CLICKED: 'saving'
      }
    },
    editing: {
      on: {
        SAVE: 'saving',
        CANCEL: 'ready'
      }
    },
    bulk_processing: {
      on: {
        BULK_COMPLETE: 'ready',
        BULK_ERROR: 'ready'
      }
    },
    saving: {
      on: {
        SAVE_SUCCESS: 'success',
        SAVE_ERROR: 'error'
      }
    },
    success: {
      on: {
        CONTINUE: 'ready',
        AUTO_CLOSE: 'ready'  // 2초 후 자동으로 ready로 전환
      }
    },
    error: {
      on: {
        RETRY: 'loading',
        DISMISS: 'ready'
      }
    }
  }
}
```

**로딩/오류/Success 상태 구성:**

```typescript
attendance_screen_states = {
  loading: {
    ui: {
      show_skeleton: true,  // 스켈레톤 UI 표시
      disable_interaction: true,
      message: '출결 정보를 불러오는 중...'
    }
  },

  error: {
    ui: {
      show_error_message: true,
      error_message: '출결 정보를 불러올 수 없습니다.',
      show_retry_button: true,
      retry_button_text: '다시 시도'
    },
    actions: {
      on_retry: 'reload_data',
      on_dismiss: 'hide_error'
    }
  },

  success: {
    ui: {
      show_success_toast: true,
      success_message: '출결 정보가 저장되었습니다.',
      auto_close_duration: 2000  // 2초 후 자동 닫기
    },
    actions: {
      on_continue: 'stay_on_screen',
      on_auto_close: 'refresh_data'
    }
  }
}
```

**오늘 출결하기**
- PC/태블릿/모바일 출결
- 오늘 수업 학생만 자동 표시
- AI 예측 기반 기본값 설정
- 학생 검색 및 출결 체크
- 등원/하원 처리

**QR 출결 실행 (설정 활성화 시에만 노출)**
- QR 코드 스캔을 통한 자동 출결
- 학생용 모바일 화면

**출결 알림 발송**
- 등원/하원 시 자동 알림 발송 (설정 기반)

**⚠️ M3: Attendance Fallback 규칙 중복 제거:**

**단일 정본 (v3.3 확정):**

출결 Fallback 규칙은 아래 섹션에서만 정의하고, 다른 섹션에서는 참조 형태로만 언급합니다.

#### 3.3.4 출결 Fallback UI/UX 규칙

Zero-Interaction이 실패한 경우, 시스템은 즉시 아래 fallback을 제공:

**자동 출결 실패 → "터치 1회로 등원 처리" 버튼 제공**
- 자동 감지 실패 시 즉시 수동 처리 버튼 표시
- 최소한의 클릭으로 처리 가능

**QR 복제 의심 → "본인 인증 요청" 화면 자동 표시**
- 동일 QR 반복 사용 감지 시 자동 인증 요청
- 추가 보안 검증 진행

**키오스크에서 얼굴 인식 실패 → "학생 번호 입력" 모드 자동 전환**
- 인식 실패 시 즉시 대체 입력 방식 제공
- 사용자 혼란 최소화

**학생 동일 이름 중복 → "학생 선택" 화면 자동 표시**
- 중복 이름 감지 시 선택 화면 제공
- 추가 정보(학년/반)로 구분

**인증 실패 → "재시도" 또는 "관리자 확인" 옵션 제공**
- 인증 실패 시 명확한 다음 단계 안내

#### 3.3.5 QR 출결 아키텍처

**⚠️ 출결 설정 통합 원칙:**

(출결 설정 JSON 구조는 3.3.7 '출결 설정'의 `tenant_settings.attendance` 정의를 따른다.)

**핵심 합의: QR은 "학원 고정 QR 코드 + 학생 휴대폰 촬영 방식"**

**QR 코드 방식**

각 학원(및 선택적으로 반/강의실)별로 고정 QR 코드를 발급한다.

**QR 내용:**
```
https://{public-gateway}/attend?q={signed_token}
```

signed_token 내부 정보:
- tenant_id
- location_type (academy / classroom / branch)
- location_id
- expires_at (필수, 학원 고정 QR은 90일 자동 설정)
- HMAC 서명

**⚠️ 🔥 H5: QR 토큰 만료 및 재발급 규칙 (단일 정본, v3.3 확정):**

**정본 규칙:**

```typescript
qr_token_expiry = {
  // 학원 고정 QR은 유효기간 90일 자동 설정
  default_expiry_days: 90,

  // 만료 7일 전 자동 재발급
  auto_renew_before_days: 7,

  // 재발급 시 관리자에게 안내
  notify_admin_on_renew: true
}
```

**QR 토큰 재발급 프로세스:**
- 만료 7일 전 자동으로 새 QR 토큰 생성
- 관리자 대시보드에 "QR 토큰 재발급 필요" 알림 카드 생성
- 새 QR 코드 다운로드 및 출력 안내
- 기존 QR 코드는 만료일까지 유효 (점진적 교체)

**⚠️ 다른 섹션에서 QR 토큰 만료 규칙을 언급할 때:**
- "3.3.5 QR 출결 아키텍처의 QR 토큰 유효기간 규칙 참조" 형태로만 언급
- 중복된 규칙 정의 제거

**출결 흐름**

1. 학원이 입구/강의실에 QR 출력·부착
2. 학생이 본인 휴대폰으로 QR 촬영 → 모바일 브라우저/앱 오픈
3. 인증 처리:
   - **학부모/학생 앱 로그인 상태** → 자동 인증 (JWT 토큰 확인)
   - **비로그인 브라우저 접근** → SMS 본인 인증 또는 temporary token 발급
4. 출결 API 호출:
   - attendance_mode = 'qr'
   - device_type = 'mobile'
   - qr_payload 포함
   - auth_token 또는 temp_token 포함
5. 서버에서:
   - 토큰 유효성 검증(HMAC, 만료시간 등)
   - 인증 상태 확인 (로그인 또는 SMS 인증 완료)
   - 출결 이벤트(`attendance_logs`)에 source='qr' 기록

**⚠️ 출결 테이블 명명 통일:**

문서 전반에서 출결 관련 테이블은 아래 표준 명명을 사용한다:

- **attendance_logs**: 출결 원본 로그 (원본 테이블)
- **attendance_events**: Event Engine 내부 이벤트 (Event Engine internal)
- **attendance_daily**: 일별 집계 데이터 (집계 테이블)
- **attendance_mv**: Materialized View (Materialized View)

**⚠️ B6: 출결 Anti-Abuse Device Fingerprint 실제 DB 필드 정의:**

**attendance_logs 테이블 스키마 (Anti-Abuse 필드 포함):**

```sql
CREATE TABLE public.attendance_logs (
  id bigserial NOT NULL,
  tenant_id uuid NOT NULL,
  student_id uuid NOT NULL,
  class_id uuid,
  occurred_at timestamptz NOT NULL,
  attendance_type text NOT NULL CHECK (attendance_type IN ('check_in', 'check_out', 'absent', 'late')),
  status text NOT NULL CHECK (status IN ('present', 'late', 'absent', 'excused')),
  notes text,
  created_by uuid,
  created_at timestamptz NOT NULL DEFAULT now(),

  -- ⚠️ B6: Anti-Abuse 필드 (Device Fingerprint/GPS/Auth Method)
  device_fingerprint text,  -- SHA256 해시값 (웹: user_agent+ip+screen, 모바일: device_uuid+app_instance_id)
  gps_lat numeric(10, 7),    -- GPS 위도 (QR 출결 시 선택적 수집)
  gps_lng numeric(10, 7),    -- GPS 경도 (QR 출결 시 선택적 수집)
  auth_method text,          -- 인증 방법: 'qr', 'manual', 'sms_auth', 'temp_token', 'fingerprint_match'
  source text,               -- 출결 소스: 'pc', 'tablet', 'mobile', 'qr'
  ip_address inet,          -- IP 주소 (부정행위 탐지용)
  user_agent text,           -- User Agent (웹 브라우저용)

  PRIMARY KEY (id, occurred_at)
) PARTITION BY RANGE (occurred_at);
```

**필드 설명:**
- `device_fingerprint`: Device Fingerprint SHA256 해시값 (low-assurance indicator)
- `gps_lat`, `gps_lng`: GPS 좌표 (QR 출결 시 `qr_gps_enabled=true`일 때만 수집)
- `auth_method`: 실제 인증 방법 (QR 인증, SMS 인증, 임시 토큰 등)
- `source`: 출결 소스 (PC/태블릿/모바일/QR)
- `ip_address`, `user_agent`: 부정행위 탐지용 보조 정보

**상태 필드 표준:**
- `status`: `present` | `late` | `absent` | `leave_early`

**QR 인증 방식:**

**⚠️ Parent/Student 인증 모델 명확화:**

**인증 토큰 구분:**
- **Parent Token**: 학부모 앱에서 발급된 JWT (role='parent')
- **Student Token**: 학생 앱에서 발급된 JWT (role='student')
- 두 토큰 모두 QR 출결에 사용 가능하나, 권한 범위는 다름

**학부모/학생 앱 로그인 상태:**
- 앱 내 JWT 토큰 자동 전달 (Parent Token 또는 Student Token)
- 추가 인증 없이 출결 처리 가능
- Parent Token: 자녀 출결 조회 가능
- Student Token: 본인 출결만 가능

**비로그인 브라우저 접근:**
- SMS 본인 인증: 학생 전화번호로 인증번호 발송
- Temporary Token: 일회용 토큰 발급 (5분 유효)
- 인증 완료 후 출결 처리 진행

**학생 본인 휴대폰 직접 인증:**
- 학부모 앱 없이 학생 본인 휴대폰으로 직접 QR을 찍어도 인증 가능
- 일부 학원에서 학생 본인 번호로 인증 진행
- 학생 전화번호가 등록되어 있으면 해당 번호로 SMS 인증 진행
- Parent 앱 없이도 학생 단독 QR 출결 가능

**SMS 인증 실패 시 대체 방법:**
- SMS 인증 실패 시 보조 인증 제공:
  - **방법 1**: 학생 ID + 생년월일 4자리 입력
  - **방법 2**: 학부모 번호 기반 대체 인증
- 보조 인증 성공 시 출결 처리 진행
- 보조 인증 실패 시 관리자 확인 요청

**보안 고려사항**

- 토큰 서명 필수 (평문 academy_id만 노출 금지)
- 일정 시간 이상 지난 QR 토큰 → 무효 처리 또는 리프레시 필요
- QR를 캡처/복제한 경우:
  - 위치 기반(선택 사항) or 시간대 기반 추가 검증(예: 야간 시간대 제한)

#### 3.3.6 Anti-Abuse Rule (출결 부정행위 방지 규칙)

QR 출결의 부정행위를 방지하기 위한 규칙:

**1) Device Fingerprint 비교**

**⚠️ C8: Device Fingerprint 신뢰도 분류 통일:**

초반 설명과 후반 보완 규칙이 충돌하지 않도록 통일:

- Device Fingerprint는 "low-assurance device indicator"로 분류
- "strong identifier"처럼 서술하지 않음
- Private Mode, VPN, 학교 공용 와이파이 환경에서 매번 다른 fingerprint 생성 가능
- 높은 신뢰도가 필요한 경우 추가 인증(SMS, 본인 확인) 필수

**Device Fingerprint 비교 규칙:**
- 동일 기기 토큰 지문(Device Fingerprint) 비교
- 동일 기기에서 반복 QR 입력 시 경고
- Fingerprint 불일치 시: `tenant_settings.attendance.device_fingerprint_fallback_policy`에 따라 처리
  - `sms_auth`: SMS 인증으로 자동 전환
  - `block`: 출결 차단
  - `warn`: 경고만 표시하고 출결 허용

**2) GPS 기반 허용 반경 제한 (선택)**

**⚠️ M2: GPS 출결 옵션 UI에서 optional로 명시:**

**GPS 옵션 제한사항 (v3.3 확정):**

GPS 옵션은 모바일 브라우저에서 100% 동작하지 않음:
- 학생 휴대폰에서 QR을 찍는 구조에서 GPS 권한 요청 시 거부율 매우 높음
- 실제 운영에서는 거의 사용할 수 없음
- **Fallback 규칙을 강화해야 함**

**UI 표시 규칙:**
- GPS 옵션은 설정 UI에서 **"선택 사항(Optional)"**로 명시
- 기본값은 `qr_gps_enabled: false` (비활성화)
- 활성화 시 경고 메시지 표시: "모바일 환경에서 GPS 권한 거부 시 자동으로 SMS 인증으로 전환됩니다"

**GPS 설정:**
- GPS 기반 허용 반경 제한 옵션 (`tenant_settings.attendance.qr_gps_enabled`)
- 기본 허용 반경: 150m (`tenant_settings.attendance.qr_gps_radius_meters`)
- 학원 위치에서 벗어난 QR 입력 감지
- GPS 검증 실패 시: SMS 인증 또는 본인 확인으로 자동 Fallback
- GPS 권한 거부 시: 자동으로 SMS 인증으로 전환

**3) 비정상 시간대 감지 (Adaptive Rule)**
- 정규 수업 시간이 아닌데 QR 찍힘 감지
- 장시간 외부에서 QR 입력 발생 감지

**4) 동일 학생의 반복 QR 입력 시 경고**
- 짧은 시간 내 동일 학생 QR 반복 입력 감지
- 부정행위 의심 시 본인 인증 요청

**5) AI 기반 "출석 불일치 패턴" 분석**
- 학생이 QR 코드를 사진 찍어서 친구에게 보내줌 감지
- 친구가 대신 QR을 찍어줌 감지
- 패턴 분석 기반 이상 출결 자동 탐지

**Device Fingerprint 계산 알고리즘**

Device Fingerprint는 출결 부정행위 방지를 위한 기기 식별자이다.

**⚠️ Device Fingerprint 신뢰도 분류:**

Device Fingerprint는 프라이버시 문제로 실제 웹브라우저에서 reliable하지 않을 수 있다:

- Private Mode, VPN, 학교 공용 와이파이 환경에서 매번 다른 fingerprint 생성 가능
- **fingerprint는 "low-assurance device indicator"로 분류해야 함**
- 높은 신뢰도가 필요한 경우 추가 인증(SMS, 본인 확인) 필수

**계산 방식:**

**웹 브라우저:**
```
device_fingerprint = sha256(
  user_agent +
  ip_address +
  device_id (cookie 기반) +
  screen_resolution +
  timezone
)
```

**모바일 앱:**
```
device_fingerprint = sha256(
  device_uuid (OS 제공) +
  app_instance_id +
  device_model
)
```

**Fingerprint 저장:**
- 첫 출결 시 device_fingerprint 생성 및 저장
- 이후 출결 시 기존 fingerprint와 비교
- **⚠️ 🔥 5번: Device Fingerprint 논리 일관성 확보:**

**부정행위 탐지에서 fingerprint 의존도 낮추기:**

Device Fingerprint는 "low-assurance indicator"이므로, 부정행위 판단 시 단독으로 사용하지 않고 **보조 지표**로만 활용:

```typescript
anti_abuse_detection_rule = {
  // Device Fingerprint는 경고 수준으로만 사용
  fingerprint_check: {
    level: 'warning',  // 'block'이 아닌 'warning'
    action: 'sms_auth_fallback',  // 불일치 시 SMS 인증으로 자동 전환
    strict_mode: false  // 엄격 모드 비활성화 (기본값)
  },

  // 실제 차단은 다음 조건에서만:
  block_conditions: [
    'gps_out_of_range + fingerprint_mismatch + abnormal_time',  // 복합 조건
    'repeated_failed_auth_attempts',  // 반복 인증 실패
    'ai_pattern_anomaly_detected'  // AI 패턴 이상 탐지
  ],

  // SMS fallback 강화
  sms_fallback_priority: 'high',  // Fingerprint 불일치 시 즉시 SMS 인증
  require_sms_on_fingerprint_mismatch: true  // 불일치 시 SMS 필수
}
```

**논리 일관성 확보:**
- Fingerprint는 "low-assurance"이므로 단독 차단 기준으로 사용하지 않음
- Fingerprint 불일치 시 → SMS 인증으로 자동 전환 (차단이 아닌 추가 인증)
- 실제 차단은 복합 조건(GPS + 시간대 + AI 패턴)에서만 수행

**iOS Safari Private Mode 예외 처리:**

Private Mode에서는 localStorage 금지 및 device UUID 생성이 불가능하므로:

```typescript
fingerprint_fallback = {
  // iOS Safari Private Mode 감지
  is_private_mode: detect_ios_safari_private_mode(),

  // Fallback 계산 방식
  fallback_fingerprint: sha256(
    ip_address +
    user_agent +
    screen_resolution
  ),

  // 보안 등급 자동 설정
  security_level: 'low'
}
```

**Private Mode 처리 규칙:**
- iOS Safari Private Mode 감지 시 fingerprint_fallback 사용
- 보안 등급을 'low'로 자동 설정
- `tenant_settings.attendance.device_fingerprint_fallback_policy`에 따라 처리:
  - `sms_auth`: SMS 인증 요청
  - `block`: 출결 거부
  - `warn`: 경고 후 출결 허용
- Private Mode 사용 이력 로그 기록

**Fingerprint 갱신 규칙:**
- 정상적인 기기 변경 시 (예: 새 폰 구매) 수동 갱신 허용
- 관리자 승인 후 fingerprint 업데이트
- 갱신 이력 추적

**⚠️ 🔥 H4: 출결 Anti-Abuse Fingerprint 설명 통일:**

**정본 규칙 (v3.3 확정):**

1. **Fingerprint mismatch → SMS 인증 fallback이 정본**
   - Fingerprint 불일치 시 즉시 SMS 인증으로 자동 전환
   - 차단이 아닌 추가 인증 요청

2. **Fingerprint 단독 차단 금지**
   - Fingerprint만으로는 출결 차단하지 않음
   - 실제 차단은 복합 조건(GPS + 시간대 + AI 패턴)에서만 수행

**부정행위 감지 시 처리 (복합 조건 충족 시):**
- 즉시 출결 처리 중단
- 본인 인증 요청 화면 표시
- 관리자에게 알림 카드 생성
- 출결 이력에 "의심" 플래그 표시

**UI 노출 방식:**
- QR 출결은 기본적으로 비활성이며, 원장이 'QR 출결 사용' 설정을 켜야 QR 기능이 메뉴에 나타난다.
- QR 출결 메뉴는 숨김 기본값이며, 설정에서 켜면 노출된다.

#### 3.3.7 출결 설정 (환경설정 > 출결 설정으로 이동)

**⚠️ 출결 설정 통합 원칙:**

출결 설정은 반드시 `tenant_settings.attendance` 단일 JSON으로 통합하여 제어한다.
QR 인증/보조 인증/토큰 유효기간/지각 기준/중복 체크/출결 모드 설정 모두 이 JSON 내부에서 관리한다.

**⚠️ 🔥 15번: 설정 UI 위치 통일:**

**최종 UI 구조 (PART 4 앞단에 명확히 정리):**

**설정 UI 위치 (확정):**
- **출결 설정**: 환경설정 > 출결 설정 (출결 관리 화면에서 제거)
- **고급 기능**: Advanced 메뉴 (펼치기 방식)
- **시스템 설정**: 환경설정 > 시스템 설정

**설정 UI 계층 구조:**
```
환경설정
├─ 출결 설정 (본 문서 3.3.7 섹션 참조)
├─ 알림 설정
├─ 청구 설정
├─ 시스템 설정
└─ Advanced (펼치기)
   ├─ 상품 관리
   ├─ 정산/매출 상세
   └─ 템플릿 관리
```

**중요: 출결 설정은 운영 초반에 1회만 설정하므로, 출결 관리 화면에서 제거하고 "환경설정 > 출결 설정"으로 이동한다.**

출결버스 매뉴얼에 존재하는 "출결문자 설정" 항목을 디어쌤 tenant_settings에 반영.

**tenant_settings.attendance 공식 스펙 (단일 소스):**

모든 출결 관련 설정은 아래 JSON 구조로 통합 관리된다:

```json
{
  "attendance": {
    // 기본 출결 설정
    "late_after_minutes": 10,          // 지각 기준 (분)
    "absent_after_minutes": 60,        // 결석 기준 (분)
    "allow_duplicate_checkin": false,  // 중복 출결 허용 여부
    "time_format_24h": true,           // 24시간/12시간 설정
    "default_mode": "pc",              // pc/tablet/mobile/qr

    // QR 출결 설정
    "qr_enabled": true,                // QR 출결 사용 여부
    "qr_token_expiry_days": 90,  // QR 토큰 유효기간 (일, 정본 설정값)
    "qr_auth_fallback_enabled": true,  // QR 인증 실패 시 보조 인증 허용
    "sms_auth_fallback_enabled": true, // SMS 인증 실패 시 보조 인증 허용

    // QR 보안 설정
    "qr_gps_enabled": false,           // GPS 기반 허용 반경 제한 사용 여부
    "qr_gps_radius_meters": 150,       // GPS 허용 반경 (미터)

    // Device Fingerprint 설정
    "device_fingerprint_strict": false, // Device Fingerprint 엄격 모드 (기본값: false, low-assurance indicator이므로 기본은 느슨하게)
    "device_fingerprint_fallback_policy": "sms_auth",  // Fingerprint 불일치 시 정책: "sms_auth" | "block" | "warn"

    // 출결 중복 체크 예외 규칙
    "duplicate_checkin_exceptions": {
      "allow_checkout_after_minutes": 5,  // 등원 후 N분 이후 하원 체크 허용
      "auto_checkout_enabled": true  // 학부모 앱 자동 하원 처리 허용
    },

    // AI 예측 모델 학습 예외 처리
    "ai_prediction_learning": {
      "exclude_user_overrides": true,  // 사용자가 AI 추천을 무시한 경우 학습에서 제외
      "exception_logging": true  // 예외 로깅 활성화
    },

    // 반별 지각 기준 (선택)
    "class_specific_late_rules": {}  // 예: {"class_1": 10, "class_2": 15}
  }
}
```

**설정 항목 설명:**
- allow_duplicate_checkin:
  - true: 같은 학생이 같은 날 여러 번 등원 체크 가능(특수 운영 학원)
  - false: 이미 등원 기록이 있으면 재등원을 막고 알림 표시
- time_format_24h:
  - UI의 시간 표시를 24시간제/12시간제로 변경
  - 출결버스의 설정 화면 기능이 디어쌤 Config 모델과 1:1 대응됨

설정 UI는 접기/펼치기 가능 구조로 단순화한다.

**⚠️ 출결 설정 통합 구조 명시:**

출결 설정(attendance_settings)은 단일 JSON 구조(`tenant_settings.attendance`)로 통합되어야 하며, QR 인증/보조 인증/토큰 로직/지각 기준/중복 체크/출결 모드도 모두 이 JSON 구조에서 제어된다.

문서 내 여러 위치(3.3.5 QR 출결 아키텍처, 3.3.7 출결 설정)에서 출결 설정이 언급되었더라도 실제 데이터 구조는 하나만 존재한다.

**⚠️ C2: 출결 설정 JSON 단일 정본 확정:**

출결 설정 JSON은 **3.3.7 출결 설정** 섹션의 상세 구조 버전만 유지하고, 다른 섹션에서는 참조 형태로만 언급합니다.

**정본 위치:** 3.3.7 출결 설정의 `tenant_settings.attendance` 공식 스펙 참조

**다른 섹션에서 출결 설정을 언급할 때:**
- "3.3.7 출결 설정의 `tenant_settings.attendance` 공식 스펙 참조" 형태로만 언급
- 중복된 JSON 구조 정의 제거

#### 3.3.8 출결 패턴 분석 & AI 이상 탐지

**중요: 출결 패턴 분석 및 AI 탐지는 실제로는 "분석/통계" 기능이므로, 출결 관리 화면에서 제거하고 "통계" 또는 "AI 인사이트" 메뉴로 이동한다.**

**참고:** 이 기능의 상세 내용은 본 섹션(3.3.8)에만 정의되어 있으며, 통계(3.6) 및 AI 인사이트(3.7) 메뉴에서도 동일한 데이터와 분석 로직을 활용한다.

**데이터 수집**

core-analytics는 다음 필드를 가진 `attendance_daily`(집계 테이블)를 분석 대상으로 사용:

**⚠️ 출결 테이블 명명 통일:**
- `attendance_logs`: 출결 원본 로그 (원본 테이블)
- `attendance_daily`: 일별 집계 데이터 (집계 테이블, 분석 대상)
- tenant_id
- student_id
- class_id
- occurred_at
- status (present/late/absent/leave_early 등)
- source (pc/tablet/mobile/qr)

**일 단위/주 단위 rollup 테이블 생성:**
- daily_attendance_stats
- class_attendance_heatmap

**반별 출결 히트맵**

축:
- X축: 요일(월~일)
- Y축: 시간대(예: 1시간 단위)

값:
- 출석률, 지각률, 결석률

UI:
- 테이블형 Heatmap (색상 단계로 진하기 표시)

**요일·시간대 패턴 분석**

지표:
- 특정 요일/시간대에 반복되는 지각·결석 패턴
- 학원 전체 vs 반별 비교

결과:
- "화요일 18~20시 지각률 ↑" 같은 Insight 생성

**AI 기반 이상 출결 탐지**

기본 규칙 기반:
- 단기간 내 급격한 결석 증가
- 특정 학생의 갑작스러운 패턴 변화
- 특정 반/요일에서 비정상 패턴

향후:
- ML 모델 연동 가능하도록 anomaly_score 컬럼 예약

#### 3.3.9 키오스크/태블릿 모드

**태블릿 전용 모드의 컴포넌트 규격**

태블릿/키오스크 모드를 위한 구체적인 기술 규격:

**① 키오스크 모드 전용 컴포넌트 규격**

**버튼 최소 너비/높이:**
- 최소 너비: 120px
- 최소 높이: 60px
- 터치 영역 최소 48px 규칙 준수

**폰트 크기:**
- 기본 텍스트: 최소 16px
- 버튼 텍스트: 최소 18px
- 제목: 최소 24px

**터치 영역:**
- 모든 클릭 가능 요소는 최소 48px × 48px
- 버튼 간 간격: 최소 8px

**오프라인 캐싱:**
- 출결 데이터는 로컬 캐시 저장
- 네트워크 복구 시 자동 동기화
- 오프라인 상태 표시

**오프라인 출결 동기화 충돌 전략:**

오프라인에서 생성된 출결 데이터가 서버와 동기화될 때 충돌이 발생할 수 있습니다. 아키텍처 레벨에서의 충돌 해결 방향:

1. **Version/Timestamp 기반 병합:**
   - `attendance_logs` 테이블에 `version` 또는 `last_modified_at` 필드 기반 충돌 감지
   - 서버 버전이 더 최신이면 서버 데이터 우선, 로컬 버전이 더 최신이면 로컬 데이터 우선 (Last Writer Wins)

2. **충돌 시 검토 필요 상태:**
   - 충돌 감지 시 출결 상태를 "검토 필요" 상태로 설정
   - 관리자 UI에서 충돌된 출결 내역을 확인하고 수동으로 병합 가능

3. **권한 경계 정책:**
   - 출결 수정 권한은 `staff_role`과 출결 이벤트 생성 시점(`event_age`)에 따라 제한
   - 예: 출석 후 1시간 이내는 교사(`staff_role >= TEACHER`) 수정 가능, 그 이후는 관리자(`staff_role >= MANAGER`)만 수정 가능
   - RLS 정책과 연계하여 `staff_role >= MANAGER AND event_age < X 일` 조건으로 접근 제어

**② 태블릿 회전(landscape) 기준 레이아웃 규칙**

**가로 모드(Landscape):**
- 출결 화면: 2열 레이아웃
- 학생 리스트: 그리드 형태
- 버튼 영역: 하단 고정

**세로 모드(Portrait):**
- 출결 화면: 1열 레이아웃
- 학생 리스트: 리스트 형태
- 버튼 영역: 우측 고정

**반응형 전환:**
- 화면 크기 변경 시 즉시 레이아웃 재조정
- 전환 애니메이션 최소화 (성능 우선)

### 3.4 수납·청구(Billing & Payment)

#### 3.4.1 수납 관리 홈(Home) — 자동 청구 진행 현황 대시보드

**라우팅 및 화면 구조**

수납 메뉴 첫 진입 시 라우트는 `/billing/home`이며, 기본 화면은 자동 청구 진행 현황 대시보드이다.

청구/수납 상세 목록은 `/billing/list`로 분리되며, 홈 화면에서는 별도의 "전체 청구서 보기" 버튼으로만 진입 가능하다.

**Auto-Billing 모델 (Zero-Interaction Principle)**

**모든 청구서는 자동 생성 → 관리자가 발송 버튼 누를 필요 없음**
- 월 자동 청구 생성 (배치)
- 청구서 자동 발송 (설정 기반)

**미납은 자동 알림(스케줄 기반 + AI 타이밍 추천)**
- AI가 최적 알림 시점 추천
- 자동 재알림 스케줄 실행

**결제 실패 시 자동 재시도 실행**
- 결제 실패 감지 시 자동 재시도
- 관리자 개입 최소화

**홈 화면 기본 구성 (대시보드 중심)**

**이번달 예상 수납률 카드**
- AI가 예상 수납률 자동 계산 및 표시
- 월말 자동으로 청구 요약 카드 상단 노출 (Adaptive UI)

**자동 청구 진행 현황**
- 이번 달 자동 생성된 청구서 수
- 발송 완료 / 발송 대기 / 발송 실패 현황
- 자동 청구 진행률 표시

**결제 현황 요약**
- 납부 완료 / 미납 / 부분납부 현황
- 결제 실패 자동 재시도 현황
- 주요 지표 (수납률, 미납률 등)

**미납 알림 진행 현황**
- 자동 미납 알림 발송 현황
- AI 추천 타이밍 기반 알림 스케줄
- 알림 발송 성공/실패 현황

**긴급 알림 카드**
- 결제 실패 긴급 처리 필요
- 미납 학생 즉시 연락 필요
- 자동 재시도 실패 알림

**Billing Home 카드 노출 조건:**

카드 노출은 아래 조건에 따라 결정된다:

```typescript
billing_home_card_visibility = {
  // 이번 달 청구서가 1건도 없으면 모든 카드는 "준비 중"으로 표시
  no_invoices_this_month: {
    condition: 'count(invoices where period_start >= current_month) = 0',
    action: 'show_placeholder_card',
    message: '이번 달 청구서가 아직 생성되지 않았습니다.'
  },

  // 결제 수단 미등록 시 "결제수단 설정 필요" 카드 최상단 노출
  no_payment_method: {
    condition: 'count(payment_methods where tenant_id = current_tenant) = 0',
    action: 'show_urgent_card',
    priority: 1,
    message: '결제수단을 등록해주세요.'
  }
}
```

**카드 노출 우선순위:**
1. 결제수단 미등록 카드 (최상단 고정)
2. 긴급 알림 카드
3. 이번달 예상 수납률 카드
4. 자동 청구 진행 현황
5. 결제 현황 요약
6. 미납 알림 진행 현황

**⚠️ 🔥 H2: Billing Home 카드 우선순위 충돌 해결:**

**명확한 규칙:**

1. **Billing Home 우선순위는 Billing 화면(`/billing/home`)에서만 적용**
   - Billing 메뉴 내부에서만 해당 우선순위 사용
   - Billing 화면에서는 Billing Home 우선순위 규칙 따름

2. **Home 화면(`/home`)은 Home Dashboard Rule만 따름**
   - Home 화면에서는 Billing 카드가 Home Dashboard Priority Table에 따라 재정렬
   - Billing Home 우선순위는 Home 화면에서 무시됨

**Billing Home(`/billing/home`)의 카드 우선순위는 Billing 메뉴 내부에서만 적용되며, 홈 대시보드(`/home`)에서는 Home 대시보드 우선순위 규칙에 맞게 재정렬된다:**

```typescript
card_priority_integration = {
  // Billing 메뉴 내부 (/billing/home)
  billing_home_priority: {
    scope: '/billing/home',
    rules: [
      '결제수단 미등록',
      '긴급 알림',
      '예상 수납률',
      '자동 청구 진행 현황',
      '결제 현황'
    ]
  },

  // 홈 대시보드 (/home)
  home_dashboard_priority: {
    scope: '/home',
    rules: [
      'Emergency (긴급 알림)',
      'AI Briefing',
      'Student Tasks',
      'Classes',
      'Stats',
      'Billing Summary'  // Billing 카드는 요약 형태로만 표시
    ]
  },

  // 카드 유형별 Global Priority Mapping Table
  global_priority_mapping = {
    // Billing Home의 "결제 수단 없음" 카드
    'billing_no_payment_method': {
      billing_home_priority: 1,      // Billing Home에서 최우선
      home_dashboard_priority: 2,    // Home에서는 Emergency 다음
      group_id: 'EMERGENCY',          // Emergency 그룹으로 분류
      convert_to_emergency: true      // Home에서는 Emergency 카드로 변환
    },

    // Billing Home의 "긴급 알림" 카드
    'billing_urgent_alert': {
      billing_home_priority: 2,
      home_dashboard_priority: 1,   // Home에서는 최우선
      group_id: 'EMERGENCY'
    },

    // Billing Home의 "예상 수납률" 카드
    'billing_expected_collection_rate': {
      billing_home_priority: 3,
      home_dashboard_priority: 5,    // Home에서는 Billing Summary 그룹
      group_id: 'BILLING',
      convert_to_summary: true        // 요약 형태로 변환
    }
  },

  // 카드 통합 규칙
  integration_rule: {
    // 홈 화면에서는 Billing 카드가 Home 우선순위에 맞게 재정렬
    on_home_dashboard: {
      billing_cards: 'convert_to_summary_card',
      priority: 'follow_global_priority_mapping',
      merge_with_student_tasks: false,

      // 구체적 우선순위 변환
      priority_conversion: {
        // Billing Home의 "결제 수단 없음"은 Home에서 Emergency 그룹으로 이동
        'billing_no_payment_method': {
          from: { scope: 'billing_home', priority: 1 },
          to: { scope: 'home', group: 'EMERGENCY', priority: 2 }
        }
      }
    }
  }
}
```

**통합 규칙 적용:**
- Billing Home은 Billing 메뉴 내부에서만 적용
- 홈 화면에서는 Billing 카드가 Home 대시보드 우선순위에 맞게 재정렬
- 카드 우선순위 체계가 메뉴별/홈별 구분되어야 함
- Global Priority Mapping Table을 통해 구체적 우선순위 변환 규칙 명시

**"준비 중" 상태 처리:**
- 이번 달 청구서가 없으면 모든 카드에 "준비 중" 플레이스홀더 표시
- 자동 청구 배치 실행 전까지 "준비 중" 유지
- 사용자에게 자동 청구 예정 시간 안내

#### 3.4.2 전체 청구/수납 목록(List View) — 검색 및 상세

**역할 및 진입 경로**

이 화면은 업무 홈이 아닌 "고급/상세 조회 기능"이며, 기본 진입 동선은 수납 홈(대시보드)에서 "전체 청구서 보기" 버튼 또는 상단 탭 전환을 통해서만 가능하다.

**라우팅:** `/billing/list`

**이번 달 청구서 보기**
- 현재 월 청구 내역 조회 (자동 생성)
- 학생별 청구 상태 확인
- 상세 필터 및 검색 기능

**결제 상태 보기**
- 납부 완료/미납 상태 확인
- 결제 내역 조회
- 결제 실패 자동 재시도 현황

**미납 관리**
- 미납 학생 목록 조회
- AI 추천 타이밍 기반 자동 미납 알림

#### 3.4.3 Partial Payment (부분납부) 명세

출결버스·알림뱅크 매뉴얼 기준으로 학원에서는 일부 납부 기능이 매우 빈번함.

**부분납부 처리:**

```
invoice.amount_due = invoice.amount - sum(payments.amount)
invoice.amount_paid = sum(payments.amount where status = 'paid')
```

- 청구 금액에서 실제 납부 금액을 차감한 미납 금액 계산
- 부분납부 시 amount_due는 0보다 크고 amount보다 작음
- **amount_paid**: `sum(payments.amount)`를 비동기 집계하여 캐시한 값 (성능 최적화용)

**⚠️ Partial Payment API 스펙:**

```typescript
// Edge Function: fns-payment-partial
POST /api/payments/partial

Request:
{
  invoice_id: uuid,
  amount: number,
  payment_method: 'bank' | 'card' | 'easy_pay',
  payment_date: timestamp
}

Response:
{
  payment_id: uuid,
  invoice_status: 'partial' | 'paid',
  amount_due: number,
  amount_paid: number
}

// 처리 로직:
// 1. payments 테이블에 새 레코드 생성
// 2. invoice.amount_paid = sum(payments.amount where status = 'paid')
// 3. invoice.amount_due = invoice.amount - invoice.amount_paid
// 4. invoice.status 업데이트 (partial 또는 paid)
```

**invoice.status:**
- partial: 일부납 (amount_due > 0 AND amount_due < amount)
- paid: 완납 (amount_due = 0)
- unpaid: 미납 (amount_due = amount)

**Webhook 수신 시 처리 규칙:**

**결제 금액 < invoice.amount → partial**
- 부분납부로 처리
- invoice.status를 'partial'로 업데이트
- amount_due 재계산

**결제 금액 == invoice.amount → paid**
- 완납으로 처리
- invoice.status를 'paid'로 업데이트
- amount_due = 0

**결제 금액 > invoice.amount → 오류 or 잔액 보정**
- 오류 처리: 관리자에게 알림 카드 생성
- 잔액 보정 옵션: 초과 납부 금액을 다음 청구서에 자동 반영
- 초과 납부 이력 추적

**Payment Webhook 예외 케이스 처리:**

**Webhook 지연 도착 처리:**

**⚠️ 이전 달 청구서가 이미 마감된 경우 처리:**

이전 달 청구서가 이미 마감된 경우 아래 전략을 적용한다:

```typescript
// ⚠️ 🔥 H3: Payment Webhook 마감된 invoice 처리 전략 우선순위 명확화
// ⚠️ 🔥 7번: Payment Webhook 지연 처리 단순화 (실제 구현 난이도 고려)
closed_invoice_payment_strategy = {
  // MVP 전략 (기본값, 우선순위 1)
  mvp_strategy: {
    // 전략 1: 마감된 invoice를 reopened (MVP 기본)
    reopen_closed_invoice: {
      enabled: true,  // MVP에서 기본 활성화
      priority: 1,    // 최우선 전략
      condition: 'invoice.status = "closed" AND payment.amount > 0',
      action: 'invoice.status = "reopened", invoice.closed_at = null',
      log: 'invoice_reopened_log',
      require_admin_approval: false
    }
  },

  // Advanced 전략 (설정에서 활성화 가능, 우선순위 2-3)
  advanced_strategies: {
    // 전략 2: 초과/지연 결제 금액을 다음 달로 자동 이월
    carry_over_to_next_month: {
      enabled: false,  // 기본 비활성, Advanced 모드에서만 활성화
      priority: 2,     // Advanced 전략 1순위
      condition: 'invoice.status = "closed" AND payment.amount > invoice.amount',
      action: 'create_credit_note, apply_to_next_invoice',
      log: 'carry_over_log',
      require_admin_approval: true,
      requires_advanced_mode: true
    },

    // 전략 3: 회계 상 충돌 시 관리자 수동 처리 요청
    accounting_conflict: {
      enabled: false,  // 기본 비활성, Advanced 모드에서만 활성화
      priority: 3     // Advanced 전략 2순위 (최후 수단)
      condition: 'invoice.status = "closed" AND accounting_period_closed = true',
      action: 'create_admin_alert_card',
      message: '마감된 회계 기간에 결제가 발생했습니다. 수동 조정이 필요합니다.',
      require_manual_review: true,
      requires_advanced_mode: true
    }
  },

  // 월 수납 마감(월 클로징) 처리
  monthly_closing: {
    // 마감 시점: 매월 말일 23:59
    closing_time: 'last_day_of_month 23:59',

    // 마감 후 결제 처리 (MVP: reopen만)
    post_closing_payment: {
      mvp_strategy: 'reopen_closed_invoice',  // MVP 기본 전략
      advanced_strategies: ['carry_over', 'accounting_conflict'],  // Advanced 모드에서만
      require_admin_approval: false  // MVP에서는 자동 처리
    }
  }
}
```

**장점:**
- MVP 구현 단순화: reopen만 구현하면 됨
- Event Engine state explosion 방지
- Advanced 모드에서 필요 시 확장 가능

**Webhook 지연 도착 처리 규칙:**
- Webhook이 늦게 도착하여 이전 달 청구서에 반영되는 경우
- 처리 규칙:
  - invoice.period_end를 확인하여 현재 월 청구서인지 검증
  - 이전 달 청구서인 경우 해당 invoice에 반영
  - 이전 달 청구서가 이미 마감된 경우: 위 전략에 따라 처리
  - 수동 조정 기능 제공

**마감 처리 규칙:**
- 마감된 invoice를 reopened 할 수 있음 (권한: Admin만)
- 초과/지연 결제 금액은 다음 달 청구서에 자동 이월
- 회계 상 충돌 시 관리자 수동 처리 필수
- 월 수납 마감(월 클로징) 후 결제는 관리자 승인 필요

**미납 해소 시 AI 카드 제거:**
- 미납 해소 처리 시 관련 AI 카드 자동 제거
- 처리 규칙:
  - invoice.status가 'unpaid' → 'paid' 또는 'partial'로 변경 시
  - 해당 학생의 미납 관련 AI 인사이트 카드 자동 삭제
  - 미납 알림 스케줄 취소
  - 관련 이벤트 로그 기록

**Payment Webhook → 미납 알림 자동 취소:**

결제가 성공하면 해당 invoice에 예약된 미납 알림은 즉시 취소한다:

```typescript
payment_success_notification_cancel = {
  // 결제 성공 시 미납 알림 자동 취소
  on_payment_success: {
    // 예약된 미납 알림 즉시 취소
    cancel_scheduled_notifications: true,

    // 지연 발송 대기 중인 알림 취소
    cancel_pending_notifications: true,

    // 대상: 해당 invoice_id와 연결된 모든 미납 알림
    target: 'all_unpaid_notifications_for_invoice',

    // 취소 이벤트 로그 기록
    log_cancellation: true
  }
}
```

**미납 알림 취소 규칙:**
- 결제 성공 Webhook 수신 시 즉시 처리
- 예약발송/지연발송 대기 중인 모든 미납 알림 취소
- 취소된 알림은 `notification_logs`에 `cancelled` 상태로 기록

**⚠️ Queue 지연 고려 Grace Period:**

"학부모가 결제했는데 메시지를 1분 늦게 받는 경우" → 중복 알림 발생 가능성 방지:

```typescript
notification_queue_grace_period = {
  // Queue latency(지연)를 고려한 grace-period
  grace_period_seconds: 15,  // 15초 grace period

  // 결제 성공 후 15초 이내 도착한 미납 알림은 자동 취소
  cancel_pending_within_grace_period: true,

  // 사용자에게 "발송 대기 중" 상태 표시
  show_pending_status: true
}
```
- 알림뱅크·출결버스 실서비스와 동일한 동작 보장

**부분납부 UI:**
- 청구서 상세 화면에 "납부 진행률" 표시
- 부분납부 내역 표시 (납부일, 금액, 잔액)
- 미납 금액 강조 표시

이 기능이 없으면 실제 학원에서 운영 불가능하다.

#### 3.4.4 조기납부(Early Payment) 규칙

학원 운영에서 자주 존재하는 조기납부 기능:

**조기납부 설정:**

```
early_payment_allowed: boolean
- 조기납부 허용 여부
- 기본값: false

early_payment_discount: number | null
- 조기납부 할인율 또는 할인 금액
- 예: 5 (5% 할인) 또는 10000 (10,000원 할인)
- null인 경우 할인 없음

early_payment_period: { start_at: date, end_at: date } | null
- 조기납부 가능 기간
- null인 경우 항상 가능
```

**조기납부 처리:**

**조기납부 금액 계산:**
- 원래 청구 금액에서 할인 적용
- early_payment_discount가 퍼센트인 경우: amount * (1 - discount / 100)
- early_payment_discount가 금액인 경우: amount - discount

**조기납부 상태:**
- invoice.status = 'early_paid'
- payment.early_payment = true
- payment.discount_amount 기록

**조기납부 UI:**
- 청구서에 "조기납부 할인" 옵션 표시
- 할인 금액 및 최종 납부 금액 표시
- 조기납부 기간 안내

**⚠️ C9: Early Payment 환불 규칙과 Billing 엔진 충돌 해결:**

**Early Payment 환불/취소 로직 (Billing 엔진과 통합):**

학생이 중도퇴원 시 조기납부 할인 적용 금액의 환불 처리는 **Monthly Closing 및 Carry-Over 규칙과 충돌하지 않도록** 아래 규칙을 적용한다:

```typescript
early_payment_refund_rule = {
  // 조기납부 할인 적용 금액 환불 계산
  refund_calculation: {
    // 원래 청구 금액 기준 환불
    original_amount: 'invoice.amount',

    // 실제 납부 금액 (할인 적용 후)
    paid_amount: 'payment.amount',

    // 할인 금액
    discount_amount: 'invoice.amount - payment.amount',

    // 환불 금액 계산
    refund_amount: {
      // 중도퇴원 시 실제 납부 금액 기준으로 환불 (할인 금액은 환불 불가)
      on_withdrawal: 'refund_paid_amount_only',

      // ⚠️ Monthly Closing 충돌 방지:
      // - 이미 마감된 invoice의 경우, 환불은 다음 달 invoice에 credit으로 반영
      // - 마감 전 invoice의 경우, 즉시 환불 처리 가능
      monthly_closing_conflict: {
        if_invoice_closed: 'create_credit_for_next_invoice',
        if_invoice_open: 'immediate_refund',
        require_admin_approval: false
      },

      // 할인 금액은 환불 대상에서 제외 (이미 제공된 혜택)
      discount_not_refundable: true
    }
  },

  // ⚠️ Carry-Over 규칙과의 통합:
  // Early Payment 환불 시 초과 납부 금액이 있는 경우, 다음 달 invoice에 자동 반영
  carry_over_integration: {
    excess_payment_handling: {
      if_excess_payment: 'carry_over_to_next_invoice',
      credit_note_creation: true,
      notify_admin: false
    }
  },

  // 환불 처리 예시
  example: {
    original_amount: 300000,      // 원래 청구 금액
    early_payment_discount: 30000, // 조기납부 할인 10%
    paid_amount: 270000,           // 실제 납부 금액
    refund_on_withdrawal: 270000  // 환불 금액 (납부한 금액만 환불)
  }
}
```

#### 3.4.5 Smart Retry Logic (결제 코드 기반 재시도 정책)

**⚠️ 핵심 개선안 4: Billing / Payment / Webhook / Retry 규칙 통합**

**통합 결제/청구/Webhook/Retry 규칙 (v3.2 확정, v3.3에서 변경 없이 유지):**

```typescript
billing_payment_webhook_retry_unified_rule = {
  // 1. Payment Webhook 처리
  webhook_processing: {
    // 멱등성 키 생성 (C11 해결)
    idempotency_key: '{provider}_{webhook_id}_{payment_id}',

    // Webhook 수신 시 처리 순서
    processing_order: [
      '1. idempotency_key 중복 확인',
      '2. invoice/payment 업데이트',
      '3. 미납 알림 스케줄 취소 (결제 성공 시)',
      '4. AI 인사이트 업데이트',
      '5. Notification 발송 (결제 완료 알림)'
    ]
  },

  // 2. Payment Retry 정책
  // ⚠️ M7: Payment Retry와 Notification Retry 표현 통일
  payment_retry: {
    // Smart Retry Logic (오류 코드 기반)
    // 재시도 정책은 Notification Retry와 동일한 구조 사용 (max_retries, retry_interval, on_failure)
    error_code_retry_policy: {
      'E101': {
        retry: true,
        max_retries: 3,           // Notification Retry와 동일한 필드명
        retry_interval: '1 hour', // interval 대신 retry_interval 사용 (통일)
        on_failure: 'create_admin_alert_card'  // on_failure 통일
      },      // 잔액 부족
      'E501': {
        retry: true,
        max_retries: 2,
        retry_interval: 'immediate',  // interval → retry_interval
        on_failure: 'move_to_dlq'  // on_failure 통일
      },  // 네트워크 문제
      'E203': {
        retry: true,
        max_retries: 2,
        retry_interval: '10 minutes',  // interval → retry_interval
        on_failure: 'notify_admin'  // on_failure 통일
      },  // 카드사 일시 오류
      'E104': {
        retry: false,
        action: 'notify_user',
        on_failure: 'notify_user'  // on_failure 통일
      },                  // 한도 초과
      'E302': {
        retry: false,
        action: 'notify_admin',
        on_failure: 'notify_admin'  // on_failure 통일
      },                // 계좌 정지
      'E401': {
        retry: false,
        action: 'request_auth',
        on_failure: 'request_auth'  // on_failure 통일
      }                 // 인증 실패
    },

    // 재시도 실패 시 처리 (Notification Retry와 동일한 구조)
    on_retry_failure: {
      action: 'create_admin_alert_card',
      notify_parent: true,
      suggest_alternative_payment: true,
      dlq_storage: true  // DLQ 저장 옵션 추가 (통일)
    }
  },

  // 3. Invoice 발송 실패 재발송 규칙
  invoice_delivery_retry: {
    // 발송 실패 시 재발송 정책
    on_delivery_failure: {
      max_retries: 3,
      retry_interval: '1 hour',
      require_admin_approval: false,  // 자동 재발송

      // 재발송 실패 시 처리
      on_retry_failure: {
        action: 'create_admin_alert_card',
        message: '청구서 발송 실패. 수동 발송 필요'
      }
    },

    // 발송 실패 원인별 처리
    failure_reasons: {
      'provider_error': { retry: true, max_retries: 3 },
      'template_rejected': { retry: false, action: 'notify_admin' },
      'recipient_invalid': { retry: false, action: 'update_contact' }
    }
  },

  // 4. Webhook 지연 도착 처리
  webhook_delay_handling: {
    // 이전 달 청구서 마감 처리 (C9 해결)
    closed_invoice_payment: {
      strategy: 'reopen_or_carry_over',
      default: 'reopen_closed_invoice',
      require_admin_approval: false
    }
  }
}
```

**알림뱅크 Webhook의 오류 코드별 재시도 정책:**

| 오류 코드 유형 | 예시 | 재시도 정책 |
|--------------|------|------------|
| 잔액 부족 | E101 | 1시간 후 3회까지 재시도 |
| 네트워크 문제 | E501 | 즉시 2회 재시도 |
| 카드사 일시 오류 | E203 | 10분 후 2회 재시도 |
| 한도 초과 | E104 | 재시도 없음 + 사용자에게 안내 |
| 계좌 정지 | E302 | 재시도 없음 + 관리자 카드 생성 |
| 인증 실패 | E401 | 재시도 없음 + 사용자 인증 요청 |

**재시도 정책 원칙:**
- 무한 재시도 방지 (최대 재시도 횟수 제한)
- 오류 코드별 적절한 재시도 간격 설정
- 재시도 불가능한 오류는 즉시 사용자/관리자에게 알림
- 재시도 이력은 결제 내역에 기록

**재시도 실패 시 처리:**
- 최대 재시도 횟수 도달 시 재시도 중단
- 관리자 대시보드에 "결제 실패" 알림 카드 생성
- 학부모에게 결제 실패 안내 및 대체 결제 방법 제시

**⚠️ H7: 청구서 재발송 실패 처리 규칙 추가:**

```typescript
invoice_resend_policy = {
  // 발송 실패 시 재발송 권한/조건/횟수/우선순위
  on_delivery_failure: {
    // 자동 재발송 (Provider 오류인 경우)
    auto_retry: {
      condition: 'provider_error',
      max_retries: 3,
      retry_interval: '1 hour',
      require_admin_approval: false
    },

    // 수동 재발송 (템플릿 거부 등)
    manual_retry: {
      condition: 'template_rejected OR recipient_invalid',
      require_admin_approval: true,
      admin_action: 'update_template OR update_contact'
    }
  },

  // 재발송 우선순위
  priority: {
    'unpaid_invoice': 1,      // 미납 청구서 최우선
    'partial_invoice': 2,     // 부분납 청구서
    'paid_invoice': 3         // 완납 청구서 (낮은 우선순위)
  }
}
```

#### 3.4.6 청구/수납 엔진

**주요 기능**

**상품 유형**

```
plan_type: monthly, times, package
- monthly: 고정 월 회비
- times: 출결 횟수와 연동된 횟수제
- package: 일정 기간 + 일정 회차/과목 묶음 상품(복합형)
```

**선불/후불 모델**

출결버스 매뉴얼의 용어를 따름:
```
billing_mode:
  - prepaid: 신규 등록생(선불)
  - postpaid: 기존 재원생(후불)
```

**월 자동 청구 생성 (Batch)**

배치 시각: 매일 04:00 KST

동작:
- billing_plans + enrollments + attendance 데이터를 기반으로
- 해당 기간에 대한 invoices 자동 생성
- 출결 연동 횟수제의 경우, 남은 회차/자동 차감 규칙 반영

멱등성:
- (tenant_id, period_start, period_end, template_key) 유니크 제약 유지
- 배치 실행 시 동일 기간 중복 인보이스 생성 방지

**출결 연동 횟수제**

```
times_link_mode 필드 추가:
- linked: 출결 발생 시 자동 횟수 차감
- manual: 관리자가 수동으로 횟수 차감
```

출결 이벤트가 발생할 때:
- linked인 경우 remaining_times 감소
- 0 이하로 내려갈 경우, 추가 출결 시 경고/알림 발송 옵션 지원

**미납 관리**

- 미납 학생 목록 조회
- 미납 알림 발송 설정
- 미납 이력 추적

**수납 홈 대시보드 메트릭 계산 규칙**

수납 홈(`/billing/home`) 대시보드의 각 카드 수치는 아래 계산식으로 산출한다:

```typescript
billing_home_metrics_spec = {
  // 예상 수납률 = 실제 납부 금액 / 전체 청구 금액
  expected_collection_rate:
    sum(invoices.amount_paid) / sum(invoices.amount) * 100,

  // 자동 청구 진행률 = 발송 완료 청구서 수 / 전체 청구서 수
  // 발송 실패 청구서는 계산에서 제외
  auto_billing_progress:
    count(invoices where status in ('sent', 'paid', 'partial')
          and messaging_delivery_failed = false)
    / count(invoices where messaging_delivery_failed = false) * 100,

  // 결제 실패 재시도 건수 = 재시도 실패한 결제 건수
  failed_retry_count:
    count(payments where last_retry_status = 'failed'),

  // AI 미해결 미납 건수 = 미납 상태이면서 AI가 해결하지 못한 건수
  unresolved_unpaid:
    count(invoices where status = 'unpaid' and ai_status = 'unresolved')
}
```

**계산 기준:**
- 계산 범위: 현재 월(이번 달) 청구서만 대상
- 업데이트 주기: 실시간 (데이터 변경 시 즉시 재계산)
- 캐싱: Materialized View 또는 Redis 캐시 활용

**부분납부 금액 정렬 규칙:**
- 부분납부 금액이 여러 번 발생하는 경우 가장 최신 결제 날짜 기준으로 정렬
- 결제 내역은 `payment.created_at DESC` 순서로 표시
- 부분납부 진행률 계산 시 최신 결제 금액 기준으로 집계

**발송 실패 청구서 처리:**
- `messaging_delivery_failed = true`인 청구서는 자동 청구 진행률 계산에서 제외
- 발송 실패 청구서는 별도 카드로 표시
- 발송 실패 원인 및 재발송 옵션 제공

#### 3.4.7 결제 처리 책임 범위

**중요: 디어쌤 플랫폼은 결제 로직(이체, 카드승인, 간편결제)을 직접 구현하지 않는다.**

모든 결제는 알림뱅크(효성FMS) 및 그 하위 PG사에서 처리되며, 디어쌤은 API 호출 + Webhook 수신 + DB 업데이트만 담당한다.

**결제 수단**

지원 수단:
- 계좌이체(알림뱅크 가상계좌/계좌이체)
- 카드결제 (알림뱅크 연동 PG)
- 간편결제(카카오페이/네이버페이 등, 알림뱅크를 통해 제공)

**중요 명시사항:**
- "카드 결제"와 "간편결제" 역시 알림뱅크를 통해 제공되며, 별도의 PG사 API를 직접 붙이지 않는다.
- 알림뱅크가 제공하는 통합 결제 API 스펙을 기준으로 한다.

**API 연동 방식**

**fns-payment-alimbank-request Edge Function:**
- 인자로 tenant_id, invoice_id, amount, channel(bank/card/easy_pay) 등을 수신
- 알림뱅크 API에 결제 요청 생성
- 요청/응답 전문은 audit 용도로 audit.payment_requests에 기록

**fns-payment-alimbank-webhook Edge Function:**
- 알림뱅크 Webhook 수신 전용
- 요청 서명/해시 검증 후, payments 및 invoices.status 업데이트
- 멱등성 키(idempotency_key)로 중복 콜백 방지

**정산/회계 책임:**
- 정산/회계는 알림뱅크 및 PG사에서 제공하는 정산 내역을 기준으로 하며,
- 디어쌤은 조회·필터·통계·대시보드 역할에 집중한다.

#### 3.4.8 고급 기능 (Advanced 옵션에서만 제공)

**상품 유형 관리**
- plan_type 설정 (monthly/times/package)
- 상품 생성 및 수정

**자동 청구 배치 설정**
- 배치 스케줄 설정
- 청구 규칙 커스터마이징

**패키지 상품 생성**
- 복합형 상품 설정

**정산/회계 기능**
- 월 매출 상세 분석
- 과목별 매출 분석
- 강사 매출 배분(옵션)
- 결제현황(알림뱅크 연동 결과 조회)

**UI 요구사항:**

- 수납/청구 화면은 '이번 달 청구서 보기', '결제 상태 보기'만 기본 제공하며,
- 상품 관리, 정산, 매출 분석 등은 Advanced 메뉴로 이동한다.

### 3.5 메시지/공지(Notification)

#### 3.5.1 AI 자동 초안 제안 모델 (AI-First Workflow)

**신규 기능**

AI가 상황을 감지하고 메시지 초안을 자동 생성

**예시:**
- "오늘 폭우 지역이라 하원 안내 메시지를 발송하시겠습니까?"
  → AI가 날씨 정보 기반으로 자동 감지 및 초안 제공
- "김○○ 학생 3일 결석 — 학부모 안부 문자 초안이 준비되었습니다."
  → AI가 결석 패턴 분석 후 자동 초안 생성
- 수업 종료 후 → 상담일지 작성 화면 자동 추천 (Adaptive UI)

#### 3.5.2 기본 UI (매일 사용하는 기능)

**공지 보내기**
- 단체 공지 발송
- AI 추천 초안 기반 간단한 메시지 작성 및 발송
- 상황 기반 AI 자동 제안

**출결 알림**
- 등원/하원 알림 자동 발송 (설정 기반)

#### 3.5.3 Notification Provider 구조

**⚠️ 🔥 8번: Notification Retry 구조 통합 (3중 구조 해결):**

**Notification Retry State Machine (통합 규칙):**

```typescript
notification_retry_state_machine = {
  // ⚠️ Retry Order 정의 (명확한 순서)
  retry_order: [
    '1. Provider-level retry (동일 채널 내)',
    '2. Channel-level fallback (알림톡 → SMS)',
    '3. Dead-Letter Queue (최종 실패)'
  ],

  // 1단계: Provider-level Retry (동일 채널 내)
  provider_level_retry: {
    condition: 'provider_error_code in [500, 502, 503, 504] OR network_error',
    max_retries: 3,
    retry_interval: 'exponential_backoff',  // 1초 → 5초 → 30초
    channels: ['kakao_at', 'sms'],  // 모든 채널에 적용
    on_failure: 'move_to_channel_fallback'
  },

  // 2단계: Channel-level Fallback (알림톡 → SMS)
  channel_level_fallback: {
    condition: 'provider_retry_exhausted OR provider_error_code not in [500, 502, 503, 504]',
    fallback_rule: {
      from: 'kakao_at',
      to: 'sms',
      delay: 10,  // 10초 후 SMS 발송
      max_fallback_attempts: 1  // SMS fallback은 1회만
    },
    on_failure: 'move_to_dlq'
  },

  // 3단계: Dead-Letter Queue (최종 실패)
  dead_letter_queue: {
    condition: 'all_channels_failed',
    action: 'create_admin_alert_card',
    dlq_storage: true,
    manual_retry_enabled: true
  }
}
```

**Dead-Letter Queue Mapping:**

```typescript
dlq_mapping = {
  'provider_error': {
    retry_count: 3,
    final_status: 'failed_provider',
    dlq_reason: 'provider_unavailable'
  },
  'channel_fallback_failed': {
    retry_count: 1,
    final_status: 'failed_all_channels',
    dlq_reason: 'all_channels_exhausted'
  },
  'invalid_recipient': {
    retry_count: 0,
    final_status: 'failed_validation',
    dlq_reason: 'recipient_invalid'
  }
}
```

**⚠️ 최종 통합 규칙 (Final Notification Rule):**

**1) 채널 우선순위:**
- kakao_at → 실패 → 10초 후 SMS 1회만 fallback

**2) SMS 실패 시 재시도 없음**

**3) Provider-level retry는 '공급업체 오류(500 또는 네트워크)'에만 적용:**
- 이는 동일 채널 내 retry이며, 알림톡→SMS fallback과는 별개
- Retry Order: Provider Retry → Channel Fallback → DLQ

**4) 모든 채널 실패 시 → Dead-Letter Queue → 관리자 긴급 카드 생성**

**중요: 디어쌤은 문자/알림톡 인프라를 직접 구현하지 않는다.**

**SMS/LMS 발송**

디어쌤의 SMS/LMS 발송은 기존 플레이온에서 이미 사용 중인 Provider 로직을 재사용한다.

**구현 주체:**
- core-notification → Provider 추상화
- 실제 전송 로직은 @lib/notification-sms-provider (플레이온 공통 모듈) 사용

디어쌤에서 새로 만드는 것은:
- 발송 요청 생성
- 템플릿 파라미터 바인딩
- 발송 결과 저장(로그)
- 재시도 정책 정의

즉, 통신사/게이트웨이 연동이 아니다.

**카카오 알림톡 (신규 구현)**

카카오 알림톡(AT)은 신규 Provider로 구현한다.

**연동 방식:**
- 카카오 비즈메시지 또는 알림톡 지원 SMS 사업자 API 사용
- 디어쌤은 다음만 담당:
  - 템플릿 키 + 변수 전달
  - 응답코드/전송 결과 수신
  - 실패 시 SMS 대체 발송 옵션 처리

**기술 요구:**
- 템플릿 승인/관리 화면(UI)
- 템플릿과 업무 이벤트(등원/하원/청구/미납) 매핑

**Provider 응답코드 → Internal Status 매핑표**

각 Provider의 응답코드를 내부 상태값으로 정규화하는 매핑표:

| Provider | provider_code | meaning | internal_status |
|----------|--------------|---------|----------------|
| 플레이온 SMS | 0 | 성공 | sent |
| 플레이온 SMS | 400 | 잘못된 요청 | failed |
| 플레이온 SMS | 401 | 인증 실패 | failed_auth |
| 플레이온 SMS | 500 | 공급업체 오류 | retry |
| 카카오 알림톡 | 0 | 성공 | sent |
| 카카오 알림톡 | 400 | 잘못된 요청 | failed |
| 카카오 알림톡 | 401 | 인증 실패 | failed_auth |
| 카카오 알림톡 | 500 | 공급업체 오류 | retry |

**매핑 규칙:**
- Webhook/Callback 수신 시 provider_code를 internal_status로 변환
- internal_status가 'retry'인 경우 자동 재시도 정책 적용
- internal_status가 'failed'인 경우 DLQ에 저장
- internal_status가 'sent'인 경우 발송 완료 처리

**카카오 알림톡 템플릿 승인 플로우**

**⚠️ 실제 서비스 방식 고려:**

문서는 API 기반 설명으로 되어 있으나, 실제로는 대부분 "사업자 콘솔에서 수동 제출 + API 조회" 방식:
- 실제 서비스 방식과 차이 있을 수 있음
- 사업자 콘솔 수동 제출 후 API로 상태 조회하는 하이브리드 방식 고려 필요

카카오 알림톡 템플릿 승인·검수 프로세스:

1) 템플릿 작성
- 관리자가 템플릿 내용 작성
- 변수 바인딩 설정
- 템플릿 미리보기

2) 카카오 비즈니스 센터 API로 제출
- 카카오 비즈니스 센터 API를 통해 템플릿 제출
- 제출 시 템플릿 상태: 'pending'

3) 템플릿 상태 관리
- pending: 승인 대기 중
- approved: 승인 완료 (발송 가능)
- rejected: 승인 거부

4) rejected 사유 표시
- 승인 거부 시 거부 사유 표시
- 템플릿 수정 후 재제출 가능

5) 승인된 템플릿만 발송 가능
- approved 상태의 템플릿만 실제 발송에 사용
- pending/rejected 템플릿은 발송 불가

6) 템플릿별 revision 관리
- 템플릿 수정 시 새 revision 생성
- 이전 revision 이력 보관
- 각 revision별 승인 상태 관리

**⚠️ B4: Notification Provider Approval Process 실제 Flow 연결 구조:**

**템플릿 키의 실제 naming convention:**
```typescript
template_key_naming = {
  // 형식: {category}_{event_type}_{industry}_{version}
  format: '{category}_{event_type}_{industry}_{version}',

  // 예시:
  examples: {
    attendance_checkin: 'attendance_checkin_academy_v1',
    billing_unpaid_alert: 'billing_unpaid_alert_academy_v1',
    counseling_summary: 'counseling_summary_academy_v1'
  },

  // 카테고리 분류
  categories: ['attendance', 'billing', 'counseling', 'announcement', 'system'],

  // 이벤트 타입
  event_types: ['checkin', 'checkout', 'unpaid_alert', 'payment_complete', 'summary'],

  // 업종별 분기
  industry_suffix: {
    academy: '_academy',
    salon: '_salon',
    real_estate: '_real_estate'
  }
}
```

**템플릿 versioning 규칙:**
```typescript
template_versioning = {
  // 버전 형식: v{major}.{minor}
  format: 'v{major}.{minor}',

  // 버전 증가 규칙
  version_increment: {
    major: '템플릿 내용 대폭 변경 시',
    minor: '템플릿 변수 추가/수정 시'
  },

  // 이전 버전 관리
  previous_version_handling: {
    keep_previous: true,  // 이전 버전 보관
    auto_deprecate: false,  // 자동 폐기 안 함
    manual_deprecation: true  // 수동 폐기만 가능
  }
}
```

**업종별 default template set:**
```typescript
default_template_set = {
  academy: {
    attendance_checkin: 'attendance_checkin_academy_v1',
    attendance_checkout: 'attendance_checkout_academy_v1',
    billing_unpaid_alert: 'billing_unpaid_alert_academy_v1',
    counseling_summary: 'counseling_summary_academy_v1',
    announcement: 'announcement_academy_v1'
  },
  salon: {
    appointment_reminder: 'appointment_reminder_salon_v1',
    service_complete: 'service_complete_salon_v1',
    payment_reminder: 'payment_reminder_salon_v1'
  },
  real_estate: {
    property_viewing_reminder: 'property_viewing_reminder_real_estate_v1',
    contract_reminder: 'contract_reminder_real_estate_v1'
  }
}
```

**메시지 카테고리별 템플릿 mapping table:**
```typescript
message_category_template_mapping = {
  // 출결 관련
  attendance: {
    checkin: {
      template_key: 'attendance_checkin_{industry}_v1',
      channel_priority: ['kakao_at', 'sms'],
      required_variables: ['student_name', 'checkin_time', 'class_name']
    },
    checkout: {
      template_key: 'attendance_checkout_{industry}_v1',
      channel_priority: ['kakao_at', 'sms'],
      required_variables: ['student_name', 'checkout_time', 'class_name']
    }
  },

  // 청구/결제 관련
  billing: {
    unpaid_alert: {
      template_key: 'billing_unpaid_alert_{industry}_v1',
      channel_priority: ['kakao_at', 'sms'],
      required_variables: ['student_name', 'invoice_amount', 'due_date']
    },
    payment_complete: {
      template_key: 'billing_payment_complete_{industry}_v1',
      channel_priority: ['kakao_at', 'sms'],
      required_variables: ['student_name', 'payment_amount', 'payment_date']
    }
  },

  // 상담 관련
  counseling: {
    summary: {
      template_key: 'counseling_summary_{industry}_v1',
      channel_priority: ['kakao_at'],
      required_variables: ['student_name', 'counseling_date', 'summary_text']
    }
  },

  // 공지 관련
  announcement: {
    general: {
      template_key: 'announcement_{industry}_v1',
      channel_priority: ['kakao_at', 'sms'],
      required_variables: ['announcement_title', 'announcement_content']
    }
  }
}
```

**템플릿 승인 UI:**
- 템플릿 목록 화면에 상태 표시
- 승인 대기 템플릿 필터링
- 승인 거부 사유 확인
- 템플릿 수정 및 재제출 기능

**메시지 채널 매핑**

channel 필드:
- sms: 문자 발송(플레이온 Provider)
- kakao_at: 카카오 알림톡(신규 Provider)

**UI/설정:**
- 텐넌트/학원별로 "출결 알림 방식" 선택:
  - kakao_at 우선 + 실패 시 SMS
  - SMS만 사용
  - 알림 사용 안 함

**책임 범위 요약**

디어쌤:
- 메시지 생성/큐잉/로그
- Provider API 호출

외부 Provider:
- 실제 메시지 전송
- 통신사/카카오와의 통신

#### 3.5.4 메시지 채널 우선순위 규칙

**⚠️ C3: Notification Provider 우선순위 규칙 통일 (확정):**

문서 내 두 규칙이 혼재되어 있었으나, 아래 확정본으로 통일:

**공식 Notification Rule (v3.2 확정, v3.3에서 변경 없이 유지):**

1. **채널 우선순위:**
   - kakao_at → 실패 → 10초 후 SMS 1회만 fallback
   - Channel-level retry(알림톡→SMS)는 1회로 제한

2. **SMS 실패 시 재시도 없음**

3. **Provider-level retry는 '공급업체 오류(500 또는 네트워크)'에만 적용:**
   - 이는 동일 채널 내 retry이며, 알림톡→SMS fallback과는 별개
   - Provider-level retry는 최대 3회, Exponential Backoff

4. **모든 채널 실패 시 → 관리자 긴급 카드 생성**

**⚠️ 이전 버전의 "Provider-level retry + SMS fallback" 혼합 설명은 무시하고 위 규칙만 따름**

**kakao_at 우선**
- 카카오 알림톡을 최우선 채널로 사용

**실패 → 10초 후 SMS fallback (1회만)**
- 알림톡 발송 실패 시 10초 후 자동으로 SMS 발송
- Channel-level retry는 1회로 제한
- 사용자에게 지연 없이 메시지 전달

**SMS 실패 → 재시도 없음**
- SMS 발송 실패 시 추가 재시도 없음
- 관리자에게 알림 카드 생성

**Provider-level Retry 적용 범위:**
- Provider-level retry는 '공급 업체 시스템 오류'에만 적용
- 예: 카카오 알림톡 API 서버 오류(500), 네트워크 타임아웃 등
- Channel-level retry(알림톡→SMS)와는 별개로 동작

**발송 실패 시 관리자에게 알림 카드 생성**
- 모든 채널 실패 시 관리자 대시보드에 알림 카드 표시
- 수동 처리 필요 시 명확히 안내

**⚠️ M4: Notification Throttling 중복 제거:**

**단일 정본 (v3.3 확정):**

Notification Throttling 규칙은 아래 섹션에서만 정의하고, 다른 섹션(예: 10.7 Rate Limit & Abuse Detection)에서는 참조 형태로만 언급합니다.

#### 3.5.5 Notification Throttling Rule (알림 처리량 제한 규칙)

**⚠️ 실시간 Rate Limit (초 단위):**

자동화가 많아질 경우 메시지 폭주를 방지하기 위한 제한 규칙:

**Rate Limit (단일 정본):**
- 서버 전체: 50건/초
- 단일 테넌트: 3건/초
- 초과 시 자동 큐잉 및 지연 처리

**⚠️ 메시지 전송 지연 UX:**

Rate limit → Event Queue → DLQ → Retry 흐름에서 전송 지연이 발생할 수 있음:

```typescript
notification_delay_ux = {
  // 전송 지연 시 사용자에게 명시
  show_pending_status: true,
  pending_message: '발송 대기 중',

  // 지연 시간 표시
  show_delay_time: true,
  delay_threshold_seconds: 5  // 5초 이상 지연 시 표시
}
```

**👉 메시지 전송지연을 사용자에게 명시하는 UX가 필요 ("발송 대기 중")**

**중복 발송 방지:**
- 부모 1명당 동일 메시지는 10분 안에 1회만 발송
- 출결/하원 알림은 연속 3분 이내 중복 발송 금지
- 동일 이벤트의 중복 발송 방지 (idempotency_key 사용)

**Fallback Delay 규칙:**
- Queue Overflow 시 "지연 발송 모드" 전환
- 긴급 알림은 우선 처리, 일반 알림은 지연
- 지연 발송 시 사용자에게 "발송 대기 중" 상태 표시

**비용 최적화:**
- 동일 내용 반복 발송 금지로 비용 절감
- 스팸 처리 방지를 위한 Rate Limit 적용
- 한 학원만 사용해도 메시지 폭주 방지

**Notification Provider 비용 조건:**

알림톡 실패 → SMS fallback 시 비용 처리 규칙:

```typescript
notification_cost_handling = {
  // 알림톡 실패 → SMS fallback 시 SMS 비용은 테넌트가 부담
  fallback_sms_cost: {
    payer: 'tenant',
    billing_method: 'monthly_invoice'
  },

  // SMS 비용 안내는 청구서 PDF 또는 설정 UI에서 표시
  cost_display: {
    location: ['invoice_pdf', 'settings_ui'],
    details: ['sms_count', 'sms_cost_per_unit', 'total_cost']
  }
}
```

**비용 처리 규칙:**
- 카카오 알림톡 실패 시 SMS fallback 비용은 테넌트 부담
- 월별 청구서에 SMS 사용량 및 비용 명시
- 설정 UI에서 SMS 비용 안내 및 사용량 모니터링 제공
- 카카오 알림톡 약관 기반 비용 처리 명시

#### 3.5.6 학부모 중복 수신 제어

**⚠️ 수신자 단위 Limit (일/10분 단위):**

**학부모(contact_id) 단위 Rate Limit:**

```
max_notifications_per_parent_per_day = 20
- 학부모 1명당 하루 최대 20건 제한
- 초과 시 큐에 저장 후 다음 날 발송
- 긴급 알림은 제한 예외 (최대 5건)
```

**same_message_hash 제어:**
```
same_message_hash cannot be sent to same_parent within 10 minutes
- 동일 메시지 해시는 10분 내 중복 발송 금지
- 메시지 내용 기반 해시 생성
```

**학부모 중복 수신 시나리오 대응:**

자녀 2명 이상인 경우:
- 출결 알림이 2배로 폭주 가능 → 일일 제한으로 방지
- 미납 알림도 중복 발송 가능 → 메시지 해시로 방지
- 동일 내용 알림은 10분 내 1회만 발송

**중복 수신 제어 로직:**
- 발송 전 contact_id + message_hash 조합 확인
- 10분 내 동일 조합 발견 시 발송 취소
- 일일 발송량 20건 초과 시 큐에 저장

**모니터링:**
- 발송량 모니터링 및 알림
- Rate Limit 초과 시 관리자 알림
- 발송 실패율 추적 및 리포트

#### 3.5.7 Quota / Billing / Abuse Prevention 정책

**⚠️ 테넌트 단위 Quota (일 단위):**

대규모 학원(학생 500~2000명) 사용 시 리소스 폭주를 방지하기 위한 정책:

**① 테넌트별 메시지 일일 발송량(Quota)**
- 기본: 5,000건/일
- 초과 시 관리자 승인 필요
- 초과 사용 시 추가 과금 또는 플랜 업그레이드 안내

**② 테넌트별 AI 호출량 제한**
- 상담일지 요약: 하루 200건 제한
- AI 리포트 생성: 하루 10건 제한
- 출결 이상 탐지: 실시간 (제한 없음)
- 초과 시 "AI 호출 한도 초과" 알림 및 관리자 승인 필요

**③ 테넌트별 통계/AI 업데이트 빈도 제한**
- 통계 리프레시: 1분에 1회 제한
- AI 인사이트 업데이트: 10분에 1회 제한
- 초과 요청은 큐에 저장 후 순차 처리

**④ Abuse 방지 룰**
- 동일 IP에서 과도한 요청: 1분에 100회 초과 시 자동 차단
- 스팸성 메시지 자동 차단: AI 기반 스팸 감지
- 미납 알림을 하루 수십 번 보내는 시나리오 방지: 동일 수신자 1일 3회 제한
- 비정상 패턴 감지 시 자동 계정 일시 정지

**Quota 관리:**
- Quota 사용량 실시간 모니터링
- Quota 초과 시 관리자 대시보드에 알림
- Quota 증가 요청 프로세스 제공

#### 3.5.8 고급 기능 (Advanced 옵션에서만 제공)

**템플릿 관리**
- 메시지 템플릿 생성 및 관리
- 템플릿 변수 설정

**예약 발송**
- 예약 시간 설정 및 발송

**자동 미납 알림 관리**
- 미납 알림 규칙 설정

**알림톡 템플릿 승인**
- 카카오 알림톡 템플릿 관리

**메시지 채널 라우팅 설정**
- SMS/알림톡 우선순위 설정

**발송 내역 조회**
- 상세 발송 이력 확인

**UI 요구사항:**

- 메시지 화면에는 기본적으로 '공지 보내기' 버튼만 보이며,
- 템플릿 관리, 예약발송, 채널 설정 등은 고급 옵션에서 제공한다.

### 3.6 지역 기반 통계(Regional Analytics) - Phase 1 (MVP)

(출결버스에 없는 "초격차 기능")

**중요: 기본 지역 통계 기능은 Phase 1 (MVP)에 포함됩니다.**

**⚠️ Regional Analytics 문서 정합성:**

Regional Analytics의 상세 SRS, 테이블 구조, 지표 정의는 통계문서 v1.0(RA1)을 정본으로 따른다. 테이블/뷰 명칭은 본 문서의 Regional Analytics 매핑표(3.6.5 섹션)와 통계문서 v1.0이 동일하게 유지된다.

#### 3.6.1 테넌트 위치 설정 규칙

지역 기반 통계를 하려면 각 학원의 행정동/구/시 단위 정보가 필요하다.

**tenant_settings.location 필드 구조:**

```json
{
  "location": {
    "si": "서울특별시",
    "gu": "강남구",
    "dong": "대치동",
    "lat": 37.498,
    "lng": 127.061
  }
}
```

**위치 정보 필수성:**
- 이 값이 없으면 지역 평균 비교 불가
- AI 인사이트가 지역 기반 분석을 못함
- 지도 기반 통계도 불가능

**위치 정보 설정:**
- 테넌트 생성 시 위치 정보 필수 입력
- 설정 화면에서 위치 정보 수정 가능
- 주소 입력 시 자동으로 행정동/구/시 매핑
- GPS 좌표는 선택 사항 (지도 기능 사용 시 필요)

**위치 정보 활용:**
- 지역 평균 계산 시 해당 지역의 모든 학원 데이터 집계
- 지역 순위 계산 시 동일 지역 내 순위 산출
- AI 인사이트 생성 시 지역 특성 반영

#### 3.6.2 지역코드 규칙(행정동 코드키)

지역 분석과 비교에는 반드시 지역 코드가 필요하다.

**지역 코드 구조:**

**location_code (행정동 코드):**
- H_DONG_CODE 형식
- 예: 1168010100 (서울특별시 강남구 대치동)
- 행정안전부 표준 행정동 코드 사용

**sigungu_code (시군구 코드):**
- SIGUNGU_CODE 형식
- 예: 11680 (서울특별시 강남구)
- 행정안전부 표준 시군구 코드 사용

**sido_code (시도 코드):**
- SIDO_CODE 형식
- 예: 11 (서울특별시)
- 행정안전부 표준 시도 코드 사용

**tenant_settings.location 확장 구조:**

```json
{
  "location": {
    "si": "서울특별시",
    "gu": "강남구",
    "dong": "대치동",
    "lat": 37.498,
    "lng": 127.061,
    "sido_code": "11",
    "sigungu_code": "11680",
    "location_code": "1168010100"
  }
}
```

**지역 코드 활용:**
- 지역 평균 계산 시 location_code로 조인
- 전국 단위 Heatmap 생성 시 sido_code/sigungu_code 사용
- AI 분석 시 Administrative Join 수행
- 지역 통계 집계 시 코드 기반 그룹핑

**지역 코드 매핑:**
- 주소 입력 시 자동으로 행정동 코드 매핑
- 행정안전부 공공데이터 API 활용
- 코드 매핑 실패 시 수동 입력 가능

**⚠️ 지역 코드 용어 통일:**

본 문서는 지역 통계용 코드 네이밍의 "정본"이다:
- 행정동 코드 → `location_code`
- 시군구 코드 → `sigungu_code`
- 시도 코드 → `sido_code`

다른 통계 문서에서 `adm_dong_code`, `region_code` 등을 사용하는 경우, 이 문서의 네이밍을 기준으로 동기화해야 한다.

**지역별 비교 그룹 결정 로직**

통계를 정확히 비교하려면 "지역 그룹"이 어떻게 잡히는지 명확히 정의해야 한다:

```typescript
comparison_group_rule = {
  // 1순위: 같은 행정동 내 학원들
  primary: 'same_dong',  // location_code 기준

  // 2순위: 행정동 내 학원 수가 부족하면 같은 구 내 학원들
  fallback: 'same_sigungu',  // sigungu_code 기준
  minimum_sample_size: 3,  // 최소 3개 학원 필요 (지방지역 고려)

  // 3순위: 구 내 학원 수가 부족하면 같은 시도 내 학원들
  fallback2: 'same_sido',  // sido_code 기준

  // 업종 필터: 동일 업종(industry_type) 내에서만 비교
  industry_filter: true
}
```

**비교 그룹 결정 프로세스 (공식 확정):**
1. 같은 행정동(location_code) 내 학원 수 확인
2. 3개 미만이면 같은 구(sigungu_code)로 확장
3. 여전히 3개 미만이면 같은 시도(sido_code)로 확장
4. 여전히 3개 미만이면 권역(region_zone)으로 확장
5. 동일 업종(industry_type) 필터 적용
6. 최종 그룹 내 학원들의 평균값 계산

**⚠️ 🔥 9번: Regional Analytics 비교 그룹 로직 통일 (확정):**

**공식 Fallback 우선순위 (단일 정본):**
- 1순위: 동 (location_code)
- 2순위: 구 (sigungu_code)
- 3순위: 시도 (sido_code)
- 4순위: 권역 (region_zone)

**다른 섹션에서 "권역 → 동 → 구" 형태로 언급된 경우는 오류입니다.**
**위 순서(동 → 구 → 시도 → 권역)가 공식 확정본입니다.**

**⚠️ Regional Analytics 비교 그룹 로직과 Industry 필터 조합 시 처리 방식:**

실제 데이터가 없을 경우 처리 방식을 명확히 정의:

```typescript
regional_comparison_with_industry_filter = {
  // Fallback 우선순위 (업종 필터 적용)
  fallback_priority: {
    // 1순위: 같은 동 + 같은 업종
    primary: { location: 'same_dong', industry: 'same_industry' },

    // 2순위: 같은 구 + 같은 업종
    fallback1: { location: 'same_sigungu', industry: 'same_industry' },

    // 3순위: 같은 시도 + 같은 업종
    fallback2: { location: 'same_sido', industry: 'same_industry' },

    // 4순위: 같은 권역 + 같은 업종
    fallback3: { location: 'same_region_zone', industry: 'same_industry' },

    // 5순위: 업종 필터 제거 후 지역만 비교
    fallback4: { location: 'same_region_zone', industry: 'all_industries' }
  },

  // ⚠️ C10 해결: Fallback 우선순위 통일
  // 공식 순서: 동 → 구 → 시도 → 권역 (위 fallback_priority 참조)
  // tenant_settings.regional_analytics.comparison_priority로 커스터마이징 가능하나
  // 기본값은 위 순서를 따름

  // 최소 샘플 수 규칙
  minimum_sample_size: {
    primary: 3,      // 1순위 그룹 최소 3개 (지방지역 고려하여 5에서 3으로 조정)
    fallback: 3,      // Fallback 그룹 최소 3개
    absolute_minimum: 3  // 절대 최소값

    // ⚠️ 실제 운영 고려사항:
    // "최소 지역 샘플 5개"는 실제 학원 통계에서 지나치게 높은 편
    // 서울 이외 지역에서는 거의 항상 "비교 불가"로 나올 수 있음
    // → 기본값을 3으로 조정하여 지방지역에서도 작동하도록 개선
    // → tenant_settings.regional_analytics.minimum_sample_size로 조정 가능하도록 설정
  },

  // AI 문장 출력 규칙 강화
  ai_insight_message_rule = {
    // 비교 불가 시 메시지
    insufficient_sample: {
      condition: 'count(academies_in_group) < 3',
      message: '비교할 수 있는 학원이 부족하여 지역 비교 분석을 제공할 수 없습니다.'
    },

    // Fallback 사용 시 메시지
    fallback_used: {
      condition: 'used_fallback_group',
      message_template: '{fallback_level} 기준으로 평균 대비 {comparison_result}',
      example: '동에서는 비교 불가했지만, 구 기준으로 평균 대비 +7% 우수합니다.'
    },

    // 업종 필터 제거 시 메시지
    industry_filter_removed: {
      condition: 'industry_filter_removed',
      message: '동일 업종 비교가 불가하여 전체 업종 기준으로 비교했습니다.'
    }
  }
}
```

**최소표본수 미달 시 처리:**

비교 그룹의 학원 수가 최소표본수 미만일 때:

```typescript
minimum_sample_handling = {
  // N < 3이면 지역 비교 인사이트를 생성하지 않음
  insufficient_sample: {
    condition: 'count(academies_in_group) < 3',
    action: 'skip_comparison',
    message: '비교할 학원 수가 충분하지 않습니다.'
  },

  // 3 <= N < 5이면 경고 메시지와 함께 비교 수행 (기본값 3이므로 이 구간은 사실상 사용 안 됨)
  low_sample: {
    condition: '3 <= count(academies_in_group) < 5',
    action: 'show_warning',
    message: '비교 대상 학원 수가 적어 정확도가 낮을 수 있습니다.'
  }
}
```

**처리 규칙:**
- 학원 수가 3개 미만이면 지역 비교 인사이트 생성 안 함
- "비교할 학원 수가 충분하지 않습니다" 안내 메시지 표시
- 3개 이상이면 정상 비교 수행 (지방지역 고려하여 기본값 3으로 조정)
- ⚠️ **minimum_sample_size 기본값 변경**: 5 → 3 (지방지역에서 대부분 작동하지 않는 문제 해결)

#### 3.6.3 AI 해석 문장 중심 (초보자 친화적)

**UI 구성 원칙**

"AI 해석 문장"을 최상단에 배치
- 예시: "이번 주 출석률 +3% 향상, 지역 평균 대비 +4% 우수합니다."
- 그래프는 아래로 "펼치기" 처리
- 초보자도 숫자와 그래프 없이 문장으로 이해 가능

**UI 노출 방식:**
- 지역 기반 통계는 디어쌤의 핵심 기능으로, 기본 메뉴에서 항상 노출된다.
- 초보 사용자를 위해 기본 화면은 AI 해석 문장 중심, 상세 분석만 별도 페이지에서 제공한다.

#### 3.6.4 데이터 업데이트 주기 정의 (원천→Staging 집계 주기)

**⚠️ 2-1: Regional Analytics 집계 주기 vs MV Refresh 주기 명확화:**

**원천→Staging 집계 주기 (정본):**

**attendance_stats_staging: 1분 단위**
- 출결 이벤트 발생 시 원천 데이터(attendance_logs)에서 Staging 테이블로 집계
- 1분 단위로 집계 데이터 업데이트
- 실시간 대시보드에 반영

**class_heatmap_staging: 10분 단위**
- 반별 출결 히트맵은 원천 데이터에서 Staging 테이블로 10분 단위로 집계
- 실시간성보다는 정확성 우선
- 일별 집계 데이터는 매일 자정에 생성

**regional_metrics_daily: 1일 1회 (00:30)**
- 지역 통계는 하루 1회 자정 30분에 집계 (정본 이름: regional_metrics_daily)
- 대량 데이터 처리 최적화

**⚠️ 2-4: AI 인사이트 스케줄 (Phase 구분):**

**ai_insight:**
- **Phase 1**: 주간 브리핑 (매주 월요일 07:00), 주간 모델 재학습
- **Phase 2+**: Daily briefing → 07:00 자동 생성, 고급 인사이트 실시간 감지
- Risk detection → 실시간 감지 및 업데이트 (Phase 1부터 적용)

**⚠️ MV Refresh 주기는 7.5 Materialized View 설계 섹션을 참조합니다.**

#### 3.6.5 Analytics Pipeline Specification (데이터 파이프라인 구조)

**⚠️ 2-1: Materialized View Refresh 전략은 7.5 Materialized View 설계 섹션을 참조합니다.**

통계 정합성을 보장하기 위한 3계층 데이터 파이프라인:

**Raw Layer (원천 데이터):**
- attendance_logs: 출결 원본 로그
- payments: 결제 원본 데이터
- invoices: 청구서 원본 데이터
- students, classes 등 기본 엔티티

**Staging Layer (집계 데이터):**
- 1분/10분 단위 aggregate 수행
- daily_attendance_stats: 일별 출결 통계
- class_attendance_heatmap: 반별 출결 히트맵
- hourly_payment_stats: 시간별 결제 통계

**Analytics Layer (분석 데이터):**
- AI·지역통계용 최종 데이터
- regional_metrics_daily: 지역별 일일 통계 (정본 이름, 통계문서와 일치)
- tenant_kpi_daily: 테넌트별 KPI 일일 집계
- ai_insight_materialized: AI 인사이트 Materialized View

**⚠️ 중요: Analytics 테이블 명칭 정본화:**

본 문서에서 기술하는 지역 통계 테이블은 통계문서(RA1)의 정식 테이블명 `regional_metrics_daily`를 기준으로 정본화합니다.

- 아키텍처 문서에서 `regional_stats_daily` 또는 유사 변형이 언급되는 경우, 이는 `regional_metrics_daily`와 동일한 엔터티를 의미합니다.
- 실제 DB 스키마 및 ETL/Materialized View 구성 시에는 통계문서의 정식 명칭 `regional_metrics_daily`를 사용합니다.
- 통계문서(RA1)가 단일 정본(Single Source of Truth)입니다.

**⚠️ 이슈 3: Regional Analytics 통계문서와 용어 매핑:**

통계문서와 아키텍처 문서 간 테이블/뷰 이름 매핑:

| 통계문서 이름 | 아키텍처 문서 이름 | 타입 | 비고 |
|---|---|---|---|
| regional_metrics_daily | regional_metrics_daily | MATERIALIZED VIEW | 지역별 일일 통계 (통일됨) |
| academy_metrics_daily | tenant_kpi_daily | MATERIALIZED VIEW | 테넌트별 KPI 일일 집계 |
| ranking_snapshot | (별도 정의) | TABLE/VIEW | 랭킹 스냅샷 (통계문서 전용) |
| ai_insights | ai_insight_materialized | MATERIALIZED VIEW | AI 인사이트 (논리 테이블 → 실제 MV) |

**참고:** 통계문서의 `academy_metrics_daily`는 아키텍처 문서의 `tenant_kpi_daily`와 동일한 테이블로 간주한다.

**⚠️ Materialized View Refresh 전략은 7.5 Materialized View 설계 섹션을 참조합니다.**

**데이터 흐름 (Data Flow):**

**실시간 이벤트 → Analytics:**
- 출결 이벤트, 결제 이벤트 등 실시간 발생 → `analytics.events` 테이블에 기록
- Edge Function이 실시간으로 이벤트를 수집하고 전처리

**배치 집계 → Analytics:**
- `analytics.events` → `analytics.daily_metrics` (일별 집계)
- `analytics.events` → `analytics.monthly_revenue` (월별 집계)
- Cron Job 기반 주기적 집계 실행

**AI 엔진 → AI 산출물:**
- `analytics.daily_metrics` + `analytics.monthly_revenue` → AI 엔진 입력
- AI 엔진 → `ai_student_risk_scores` (또는 유사 테이블) 생성
- Risk Score 계산 및 이상 탐지 수행

**UI → 사용자 화면:**
- `ai_student_risk_scores` → `StudentTaskCard` 생성
- `ai_student_risk_scores` → Emergency 리스트 화면 표시
- `analytics.daily_metrics` → Regional Analytics 대시보드 표시

**파이프라인 실행 위치:**
- Edge Function: 실시간 집계 (1분/10분 단위)
- Cron Job: 일일 집계 (regional_metrics_daily)
- 외부 ETL (선택): 대규모 데이터 처리 시 AWS Athena/Kinesis 활용

**테넌트 데이터 분리 전략:**
- 모든 집계는 tenant_id 기준으로 완전 분리
- RLS 정책으로 테넌트 간 데이터 접근 차단
- Materialized View도 테넌트별로 분리 생성

**캐싱 전략:**
- 통계 뷰는 Materialized View로 캐싱
- 자주 조회되는 통계는 Redis 캐시 활용
- 캐시 무효화는 데이터 갱신 시 자동 수행

#### 3.6.6 데이터 무결성 보정(Backfill & Repair) 로직

실제 운영에서 발생하는 데이터 누락/오류를 보정하는 프로세스:

**① Backfill Job**
- 지난 N일 데이터 재집계
- 특정 테넌트만 재집계 가능해야 함
- Webhook 지연으로 결제 정보가 늦게 들어온 경우 보정
- 출결 로그가 특정 시간 누락된 경우 보정

**② Repair Mode**
- 통계 mismatch 발견 시 재계산 실행
- 운영자가 "통계 재동기화" 버튼을 누를 수 있어야 함
- 일일 통계가 잘못 집계된 경우 수동 재계산
- 재계산 진행 상황 표시 및 완료 알림

**③ Analytics Locking**
- 집계 중에는 같은 데이터셋을 다른 프로세스가 수정하지 못하도록 잠금 필요
- 동시 집계 방지로 데이터 정합성 보장
- Lock 타임아웃: 30분 (초과 시 자동 해제)

**자동 보정 프로세스:**
- 일일 자동 검증 작업 실행
- 데이터 불일치 감지 시 자동 Backfill 실행
- 심각한 불일치 발견 시 관리자 알림

**수동 보정 프로세스:**
- 관리자 대시보드에서 "데이터 재동기화" 기능 제공
- 특정 기간/테넌트 선택하여 재집계 가능
- 재집계 이력 추적 및 로그 보관

#### 3.6.7 지역 기준

**지역 비교 기준:**

- 행정동 (location_code)
- 구 (sigungu_code)
- 시/도 (sido_code)
- 권역(Region Zone, 본사 정의)

**⚠️ 권역(Region Zone) 정의:**

권역은 본사 운영 지표와 연결하기 위한 상위 지역 단위이다:

```typescript
region_zone = {
  // 권역 코드 구조
  region_code: string,  // 예: "SEOUL_SOUTH", "GYEONGGI_NORTH"
  region_name: string,  // 예: "서울 남부권", "경기 북부권"

  // 권역 매핑 규칙
  mapping_rule: {
    // 시도 코드 기반 매핑
    sido_code_to_region: {
      "11": "SEOUL_SOUTH",  // 서울특별시 → 서울 남부권
      "41": "GYEONGGI_NORTH"  // 경기도 → 경기 북부권
    },

    // 또는 수동 매핑 (테넌트별)
    manual_mapping: true
  },

  // ⚠️ C10: 지역 통계 Fallback 로직 통일 (확정)
  // 공식 Fallback 우선순위 (본사 운영 기준):
  fallback_priority: {
    1: 'same_dong',         // 1순위: 같은 행정동 (location_code)
    2: 'same_sigungu',      // 2순위: 같은 구 (sigungu_code)
    3: 'same_sido',         // 3순위: 같은 시도 (sido_code)
    4: 'same_region_zone'   // 4순위: 같은 권역 (region_code)
  }

  // ⚠️ 다른 섹션에서 "권역 → 동 → 구" 형태로 언급된 경우는 오류
  // 위 순서(동 → 구 → 시도 → 권역)가 공식 확정본
}
```

**권역 활용:**
- 본사 운영 지표 집계 시 권역 단위로 그룹핑
- 권역별 평균/순위 계산
- 권역 코드는 `tenant_settings.location.region_code`에 저장

#### 3.6.8 분석 지표

**운영 지표**
- 학생 수
- 신규 등록 수
- 이탈(휴원/퇴원)
- 출석률
- 지각률/결석률

**매출 지표**
- 월 매출
- 예정 매출
- 미납률
- ARPU
- 과목별 매출

**성장 지표**
- 학생 성장률
- 매출 성장률
- 신규 전환률
- 재등록률

**패턴 지표**
- 등원 시간대
- 요일별 출석 패턴
- 반별 출결 패턴

#### 3.6.9 기능 요구사항

**비교/순위 기능**
- "대치동 학생 수 상위 12%"
- "송파구 매출 상위 8%"
- "지역 평균 대비 출석률 +4%"

**히트맵 기능**
- 지역 성장률
- 지역 출석률
- 학생 분포

**AI 인사이트 기능**
- 출결 이상 탐지
- 지역 대비 강점/약점 분석
- 추천 운영 전략

### 3.7 AI 인사이트(AI Insights) - Phase 1 (MVP)

**중요: 기본 AI 분석 기능은 Phase 1 (MVP)에 포함됩니다.**

**⚠️ AI 코드 생성 규약:**

AI 코드/SQL 생성 시에는 AI 자동 검증 프로세스를 통해 Zero-Trust/RLS 규칙을 강제한다. AI 코드 생성 규칙은 AI_자동검증_프로세스 문서를 정본으로 따른다.

**⚠️ AI Risk Score Weight 업종별 차등 원칙:**

AI Risk Score Weight는 업종별(`industry_type`)로 기본값이 다르며, Tenant Override가 우선 적용된다.

#### 3.7.1 홈 화면 상단 "AI 브리핑 카드" 도입 (AI-First Workflow)

**기본 화면 구성**

홈 화면 상단에 AI 브리핑 카드 자동 표시

**예시:**
- "원장님, 오늘 3건의 상담이 필요하며 2명의 학생이 이탈 위험 단계입니다."
- "이번 주 수업 중 수학A반 출결률이 지역 평균 대비 12% 낮습니다. 원인을 분석할까요?"
- "이번 달 청구서가 자동 발송되었습니다. 예상 수납률은 92%입니다."

각 카드 클릭 시 상세 분석 화면으로 자동 이동

**주요 기능**

- 상담일지 자동 요약
  - 상담일지 작성 시 AI가 자동 요약 생성
- 학생 출결 이상 탐지
  - AI가 출결 패턴 자동 분석 및 이상 탐지
- 반/과목 성과 분석
  - 반별/과목별 성과 자동 분석
- 지역 대비 부족 영역 분석
  - 지역 통계와 비교하여 부족 영역 자동 식별
- 월간 운영 리포트 자동 생성
  - 월말 자동으로 운영 리포트 생성

**출력 예:**

"최근 4주간 월요일 지각률이 지역 평균보다 12% 높습니다.
등원 시간 재조정 및 반 개편을 고려하세요."

**UI 노출 방식:**
- AI 인사이트는 기본 메뉴에서 항상 노출되며,
- 홈 화면 상단에 AI 브리핑 카드 자동 표시
- 기본 화면에서는 AI가 자동 생성한 "요약 카드" 중심으로
- 사용자에게 부담 없이 인사이트를 제공하고,
- 상세 분석은 별도 페이지에서 제공한다.
- 즉, AI는 숨김 기능이 아니라 '가벼운 진입 → 깊은 분석' 구조의 핵심 메뉴이다.

**AI 브리핑 카드 중복 제거 규칙:**

카드가 너무 많이 생성되는 것을 방지하기 위한 규칙:

```typescript
dedup_rule = {
  // 동일 insight_type + 동일 student/class/session이 24시간 내에 중복 생성되면 덮어쓰기
  same_insight_within_24h: {
    condition: 'same insight_type + same entity_id',
    time_window: '24 hours',
    action: 'overwrite_existing'
  },

  // 동일 내용의 인사이트는 최신 것으로만 표시
  same_content: {
    condition: 'same insight_content_hash',
    action: 'keep_latest'
  }
}
```

**중복 제거 적용 범위:**
- Daily briefing: 매일 1개만 생성
- Risk detection: 동일 학생/반에 대해 24시간 내 1개만 유지
- 상담일지 요약: 동일 상담일지에 대해 최신 요약만 유지

**⚠️ 🔥 2번: StudentTaskCard / AI Insight / AI Briefing 규칙 통합 (경계 명확화):**

**"학생 단위 업무" vs "데이터 단위 인사이트" 명확히 분리:**

문서 내 3개 섹션에서 각각 따로 정의되어 있었으나, 아래 통합 규칙으로 통일:

**카드 타입별 생성 규칙 (경계 명확화):**

```typescript
card_type_boundary = {
  // StudentTaskCard: "학생 단위 업무" 레이어
  StudentTaskCard: {
    purpose: 'actionable_student_tasks',  // 실행 가능한 학생 업무
    trigger: [
      '결석 3일 발생',
      '이탈 위험 감지',
      '상담 필요',
      '신규 등록'
    ],
    scope: 'student_level',  // 학생 단위
    action_required: true  // 사용자 액션 필요
  },

  // AI Insight: "데이터 단위 인사이트" 레이어
  AI_Insight: {
    purpose: 'data_analysis_insights',  // 데이터 분석 인사이트
    trigger: [
      '출결 패턴 분석',
      '지역 비교 분석',
      '성과 분석'
    ],
    scope: 'data_level',  // 데이터 단위
    action_required: false  // 정보 제공만
  },

  // AI Briefing: "데일리 요약" 레이어
  AI_Briefing: {
    purpose: 'daily_summary',  // 일일 요약
    trigger: [
      '매일 07:00 자동 생성'
    ],
    scope: 'tenant_level',  // 테넌트 단위
    action_required: false  // 정보 제공만
  }
}
```

**중복 생성 방지 규칙:**

```typescript
card_creation_conflict_resolution = {
  // 결석 3일 → StudentTaskCard만 생성 (AI Insight는 생성 안 함)
  'absence_3_days': {
    create: ['StudentTaskCard'],
    skip: ['AI_Insight']  // 중복 방지
  },

  // 이탈 위험 → StudentTaskCard 우선, AI Insight는 별도 생성
  'risk_detection': {
    create: ['StudentTaskCard', 'AI_Insight'],
    dedup_rule: 'same_student_same_day_only_one_insight'  // 동일 학생 동일 날짜는 1개만
  },

  // 오전 7시 AI 브리핑 생성 직후 → AI Insight는 덮어쓰기 안 함
  'after_briefing_generation': {
    ai_insight_rule: 'keep_existing_if_created_within_1_hour'  // 1시간 내 생성된 것은 유지
  }
}
```

**통합 Dedup/TTL/우선순위 규칙 (공식 정의, 단일 소스):**

StudentTaskCard, AI Insight, AI Briefing Card 세 시스템에 대한 통합 규칙:

```typescript
// ⚠️ 공식 통합 규칙 (v3.2 확정, 모든 섹션에서 이 규칙만 참조)
unified_card_dedup_ttl_priority_rule = {
  // 공통 Dedup 규칙
  dedup: {
    // 동일 타입 + 동일 엔티티 + 동일 날짜 → 1장만 유지
    same_type_same_entity_same_day: {
      StudentTaskCard: 'same task_type + same student_id + same day',
      AI_Insight: 'same insight_type + same entity_id + same day',
      AI_Briefing: 'same_date (per_date: 1)'
    },

    // 동일 내용은 최신 것으로만 유지
    same_content: {
      condition: 'same_content_hash',
      action: 'keep_latest'
    }
  },

  // 공통 TTL 규칙
  ttl: {
    StudentTaskCard: 'expires_at 기준',
    AI_Insight: '24시간',
    AI_Briefing: 'per_date: 1'
  },

  // 공통 우선순위 계산
  priority: {
    StudentTaskCard: '긴급도 + 시간대 + 담당 반/학생',
    AI_Insight: 'risk_score + 생성 시간',
    AI_Briefing: '생성 시간 (최신 우선)'
  }
}
```

**⚠️ 다른 섹션에서 Dedup/TTL/Priority를 언급할 때는:**
- "3.7.1 AI 브리핑 카드의 통합 Dedup/TTL/우선순위 규칙 참조" 형태로만 언급
- 중복된 규칙 정의 제거

**⚠️ 🔥 H1: 홈 대시보드 Priority Table 통일:**

**홈 대시보드 카드 우선순위 공식 테이블 (v3.3 확정, 단일 정본):**

카드 우선순위 충돌을 원천적으로 차단하기 위한 단일 테이블:

```typescript
home_dashboard_card_groups = {
  // 그룹 Enum 정의
  card_group_enum: [
    'EMERGENCY',      // 긴급 알림 그룹
    'AI_BRIEFING',    // AI 브리핑 그룹
    'STUDENT_TASKS',  // 학생 업무 카드 그룹
    'CLASSES',        // 오늘의 반 수업 그룹
    'BILLING',        // 수납 요약 그룹
    'STATS'           // 통계/트렌드 그룹
  ],

  // 그룹별 우선순위 (낮을수록 높은 우선순위)
  group_priority: {
    EMERGENCY: 1,
    AI_BRIEFING: 2,
    STUDENT_TASKS: 3,
    CLASSES: 4,
    BILLING: 5,
    STATS: 6
  },

  // 그룹 내부 우선순위 규칙
  within_group_priority: {
    EMERGENCY: {
      // 긴급 카드는 항상 최상단, 그룹 내부 정렬 없음
      rule: 'always_top'
    },
    STUDENT_TASKS: {
      // StudentTaskCard의 priority 값 사용
      rule: 'use_card_priority',
      // 단, StudentTaskCard priority가 90 이상이어도 Emergency 그룹보다는 낮음
      max_priority: 99  // Emergency 그룹이 항상 우선
    },
    AI_BRIEFING: {
      // 생성 시간 기준 (최신 우선)
      rule: 'created_at_desc'
    },
    CLASSES: {
      // 수업 시작 시간 기준
      rule: 'class_start_time_asc'
    }
  },

  // Merge Rule
  merge_rule: {
    // 긴급(Emergency) 카드는 항상 최상단
    emergency_always_top: true,

    // StudentTaskCard priority가 90 이상이어도 Emergency 그룹보다는 낮음
    student_task_max_priority: 99,

    // AI Insight가 StudentTaskCard에 의존하는 경우 상호 참조 방지
    prevent_circular_reference: {
      ai_insight_depends_on_student_task: false,
      student_task_depends_on_ai_insight: false
    },

    // "오늘의 반 수업 카드" 그룹 명확히 정의
    classes_group: {
      group_id: 'CLASSES',
      priority: 4,
      cards: ['today_classes', 'class_attendance_summary', 'class_schedule']
    }
  }
}
```

**통합 규칙 적용:**
- 세 시스템 모두 동일한 Dedup 로직 사용 (구현 재사용)
- TTL은 각 카드 타입별로 다르게 설정 가능
- 우선순위는 카드 타입별로 별도 계산하되, 통합 정렬 규칙 적용
- 그룹 우선순위 → 그룹 내부 우선순위 순으로 정렬

**AI 브리핑 카드 캐싱 규칙:**

매일 7시에 생성해도 사용자가 앱을 늦게 열면 카드가 여러 장 보이는 현상을 방지:

```typescript
ai_briefing_card_caching = {
  // AI briefing card는 날짜별 1장만 저장하며, 최신 1장만 유지
  storage_rule: {
    per_date: 1,
    keep_latest_only: true
  },

  // 날짜별 카드 생성 시 기존 카드 자동 삭제
  on_new_card: {
    action: 'delete_old_card',
    condition: 'same_date'
  }
}
```

**캐싱 처리 규칙:**
- 날짜별 AI 브리핑 카드는 1장만 저장
- 새 카드 생성 시 같은 날짜의 기존 카드 자동 삭제
- 사용자가 앱을 늦게 열어도 최신 1장만 표시
- 카드 생성 시간과 관계없이 날짜 기준으로 관리

#### 3.7.2 AI 인사이트 데이터 업데이트 주기

**Daily briefing: 07:00 자동 생성**
- 매일 아침 7시에 전날 데이터 기반 브리핑 자동 생성
- System Event Engine의 Time-based Event로 트리거

**Risk detection: 실시간 감지 및 업데이트**
- 이탈 위험, 출결 이상 등은 실시간으로 감지
- Pattern-based Event로 즉시 트리거

**상담일지 요약: 저장 시 즉시 생성**
- 상담일지 저장 시 AI 자동 요약 (Behavior-based Event)
- Level 3 Auto-Action으로 자동 실행

#### 3.7.3 AI Insight 정확도 보정(Weighting Rule)

AI Insight가 여러 지표를 합산할 때 가중치를 적용한다.

**risk_score 계산 공식:**

```
risk_score =
   (attendance_weight * attendance_score)
 + (counseling_weight * counseling_score)
 + (payment_weight * payment_score)
 + (performance_weight * performance_score)
```

**⚠️ H8: AI Risk Weight 업종별 가중치 일관성 확보:**

**모든 Risk Score 계산에 industry_risk_weights rule 적용:**

AI Risk Score 계산은 반드시 업종별(`industry_type`) 기본 가중치를 사용하며, Tenant Override가 우선 적용됩니다.

**기본 가중치 (업종별 차등 적용):**

업종별 기본 가중치는 아래 `industry_risk_weights` 테이블을 참조합니다 (본 문서 3.7.3 AI Insight 정확도 보정 섹션 참조).

**가중치 적용 순서:**
1. Tenant Override (테넌트별 커스터마이징, 최우선)
2. Industry Default (업종별 기본 가중치)
3. Global Default (전역 기본 가중치, fallback)

**가중치 커스터마이징:**
- 테넌트별로 가중치 조정 가능 (tenant_override)
- 업종별 기본 가중치 다를 수 있음 (industry_risk_weights 참조)
- AI 학습 결과에 따라 가중치 자동 조정 가능

**업종별 기본 가중치 차등:**

AI Risk Model 가중치는 `industry_type`별로 기본값이 다르며, `tenant_override` 가능함을 명시한다:

```typescript
industry_risk_weights = {
  academy: {
    attendance_weight: 0.4,
    counseling_weight: 0.3,
    payment_weight: 0.2,
    performance_weight: 0.1
  },
  salon: {
    attendance_weight: 0.3,
    counseling_weight: 0.2,
    payment_weight: 0.4,
    performance_weight: 0.1
  },
  real_estate: {
    attendance_weight: 0.2,
    counseling_weight: 0.3,
    payment_weight: 0.4,
    performance_weight: 0.1
  }
}
```

**⚠️ 🔥 C1: industry_type enum 값 불일치 문제 (Critical — 시스템 전체가 무너질 수 있음):**

**문제:**
문서 곳곳에서 다음 3가지 표기가 혼재합니다:
- `realestate` / `real_estate` (붙여씀/언더스코어 혼용)
- `salon` / `beauty_salon` (단순/복합 혼용)

**영향 범위:**
Schema Engine / RLS / Analytics / Notification 라우팅 / AI Risk Weight / SDUI Override / Regional Analytics 필터 / Event Engine industry filter 모두가 `industry_type`을 기반으로 동작하므로, 이는 치명적 충돌입니다.

**해결: industry_type enum 통일 (v3.2 확정 정본):**

```typescript
// ⚠️ 공식 industry_type enum (단일 정본, Schema Engine v2.1과 반드시 일치)
industry_type_enum = [
  'academy',      // 학원 (확정)
  'salon',        // 미용실 (확정 - beauty_salon 사용 금지)
  'real_estate'   // 부동산 (확정 - realestate 사용 금지, 언더스코어 필수)
]

// ❌ 사용 금지 표현:
// - realestate (붙여씀) → real_estate로 변경
// - beauty_salon → salon로 변경
// - real_estate (언더스코어) → 유지 (정본)
```

**통일 규칙 (강제):**
1. ✅ `academy` - 항상 소문자, 단수형
2. ✅ `salon` - `beauty_salon` 사용 금지, `salon`으로 통일
3. ✅ `real_estate` - `realestate` 사용 금지, `real_estate`(언더스코어)로 통일

**적용 범위 (모든 계층):**
- RLS 정책: `industry_type = 'academy' | 'salon' | 'real_estate'`
- Schema Registry: enum 값과 완전 일치 필수
- AI Risk Weight: `industry_risk_weights.real_estate` (언더스코어)
- SDUI Override: `industry_type` 필터링
- Regional Analytics: 업종 필터링
- Notification 템플릿: 업종별 분기
- Event Engine: industry filter

**⚠️ 문서 전체에서 industry_type 전부 탐색 후 일괄 교정 필요**

**기본값 설정 (RLS 정책 충돌 방지):**

**기본값 설정 (RLS 정책 충돌 방지):**

모든 Industry 테이블에 `industry_type` DEFAULT 값 지정 필요:

```sql
-- 예시: students 테이블
ALTER TABLE students
  ALTER COLUMN industry_type
  SET DEFAULT 'academy';  -- 또는 실제 기본값

-- Supabase에서 insert 시 필드 누락 시 null → policy mismatch로 403 발생 가능
-- 따라서 DEFAULT 값 필수
```

**가중치 적용 우선순위:**
1. tenant_override (테넌트별 커스텀 가중치)
2. industry_default (업종별 기본 가중치)
3. global_default (전역 기본 가중치)

**점수 정규화:**
- 각 지표 점수는 0-100 범위로 정규화
- 최종 risk_score는 0-100 범위

**risk_score 레이블 표:**

| risk_score 범위 | 레이블 | Emergency 카드 표시 | 설명 |
|----------------|--------|-------------------|------|
| 90 이상 | Emergency | ✅ 표시 | 긴급 위험, 즉시 조치 필요 |
| 70-89 | 고위험 | ❌ 표시 안 함 | 높은 위험도, 주의 필요 |
| 40-69 | 중위험 | ❌ 표시 안 함 | 보통 위험도, 모니터링 필요 |
| 0-39 | 저위험 | ❌ 표시 안 함 | 낮은 위험도, 정상 범위 |

#### 3.7.4 AI Override System (AI 행동 보정 체계)

Zero-Interaction 시스템에서 AI 오판(incorrect action)에 대한 보정 기능이 필수적이다.

사용자는 아래 방식으로 AI 동작을 보정할 수 있어야 한다:

**1) Insight Override**
- "이탈 위험 아님"으로 표시 → 모델 학습에 반영
- "출결 패턴 정상"으로 수정 → AI 판단 기준 업데이트
- 잘못된 분석 결과에 대한 피드백 제공

**2) Suggestion Override**
- AI 메시지 초안 수정 → 새로운 템플릿 학습
- 추천된 메시지 내용 수정 및 재발송
- AI 제안 무시 옵션

**3) Auto-Action Undo**
- 자동 발송된 알림 취소 (가능한 경우)
- 자동 결제 재시도 OFF로 전환
- 잘못된 자동 청구 제거
- 자동 처리된 작업의 롤백 기능

**AI Feedback Loop (피드백 재반영):**

사용자가 AI 판단을 보정(Override)하거나 자동 액션을 Undo할 때, 해당 피드백이 AI 모델 학습에 재반영되어 향후 판단 정확도가 향상됩니다.

**피드백 수집:**
- `ai_feedback_logs` 테이블에 Override/Undo 이벤트 기록
- 피드백 유형: `insight_override`, `suggestion_override`, `auto_action_undo`
- 피드백 내용: 원래 AI 판단, 사용자 보정 내용, 보정 이유

**피드백 재반영:**
- 주기적 모델 재학습 시 `ai_feedback_logs` 데이터를 학습 데이터에 포함
- Override된 패턴은 향후 동일 상황에서 AI가 다른 판단을 하도록 가중치 조정
- Undo된 자동 액션은 해당 액션의 트리거 조건을 완화하거나 제거

**Zero-Interaction 철학 강화:**
- 사용자 피드백이 자동으로 학습에 반영되어, 시간이 지날수록 AI 판단 정확도가 향상
- 사용자가 명시적으로 학습 데이터를 제공하지 않아도, 일상적인 사용 중 발생하는 Override/Undo가 자연스럽게 학습 데이터로 축적

#### 3.7.5 Auto-Action Undo 조건 명세

어떤 Auto-Action은 Undo 가능하고 어떤 것은 불가능한지 명확히 정의:

| Action | Undo 가능 여부 | 이유 | Undo 방법 |
|--------|--------------|------|----------|
| 자동 미납 알림 발송 | ❌ 불가 | 이미 전송된 메시지는 회수가 불가 | - |
| 자동 청구 생성 | ⭕ 가능 | 청구서 삭제 또는 draft 복귀 가능 | 청구서 삭제 또는 status를 'draft'로 변경 |
| 자동 결제 재시도 | ⭕ 가능 | next_retry_at 초기화 가능 | 재시도 스케줄 취소, next_retry_at = null |
| 자동 상담 요약 | ⭕ 가능 | 요약 재생성 가능 | 요약 삭제 후 재생성 |
| 자동 출결 처리 | ❌ 불가 | 이미 기록된 출결은 수정만 가능 | 출결 수정 기능 사용 |
| 자동 청구 발송 | ❌ 불가 | 이미 발송된 청구서는 회수 불가 | - |
| 자동 리포트 생성 | ⭕ 가능 | 리포트 삭제 가능 | 리포트 삭제 |
| AI 인사이트 생성 | ⭕ 가능 | 인사이트 재생성 가능 | 인사이트 삭제 후 재생성 |

**Undo 가능한 Action 처리:**
- Undo 버튼 제공
- Undo 실행 시 확인 다이얼로그 표시
- Undo 이력 로그 저장
- Undo 후 원래 상태로 복구

**Undo 불가능한 Action 처리:**
- Undo 버튼 비활성화 또는 숨김
- 대신 "수정" 또는 "보정" 기능 제공
- 사용자에게 Undo 불가능 이유 명시

**⚠️ H9: AI Undo 규칙 권한 매트릭스 충돌 해결:**

**Auto-Action Undo 권한 매트릭스 (v3.3 확정):**

| Action | Admin | Sub Admin | Teacher | Assistant |
|--------|-------|-----------|---------|-----------|
| 자동 청구 생성 Undo | ⭕ | ⭕ | ❌ | ❌ |
| 자동 결제 재시도 취소 | ⭕ | ⭕ | ❌ | ❌ |
| 자동 상담 요약 삭제 | ⭕ | ⭕ | ⭕ | ❌ |
| 자동 리포트 생성 삭제 | ⭕ | ⭕ | ❌ | ❌ |
| (실제 발송된) 미납 알림 Undo | ❌ | ❌ | ❌ | ❌ |

**권한 적용 규칙 (명확화):**
- **Admin**: 모든 Undo 가능 항목에 대해 Undo 가능
- **Sub Admin**: 표에서 ⭕ 인 항목만 Undo 가능 (청구 생성, 결제 재시도 취소, 상담 요약 삭제, 리포트 생성 삭제)
- **Teacher**: 상담 요약 삭제만 가능 (⭕ 표시된 항목)
- **Assistant**: Undo 권한 없음 (모든 항목 ❌)

**⚠️ 다른 섹션에서 "Undo는 Admin만"이라고 서술된 경우는 오류입니다.**
**위 권한 매트릭스가 정본입니다.**

#### 3.7.6 Auto-Action Undo API & Audit Rule

**Undo API 규격:**

```
POST /api/automation/{action_id}/undo

Request Body:
{
  "reason": "mistaken_action" | "incorrect_data" | "user_request",
  "requested_by": "user_id",
  "comment": "string (선택)"
}

Response:
{
  "success": boolean,
  "action_id": "uuid",
  "undo_status": "completed" | "failed",
  "message": "string"
}
```

**Undo API 인증:**
- Admin 권한 필수
- Sub Admin은 제한적 Undo만 가능 (본 문서 3.7.5 Auto-Action Undo 권한 매트릭스 참조)
- Undo 실행 전 권한 확인

**Undo Audit Log 정의:**

```sql
CREATE TABLE automation_undo_logs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  action_id uuid NOT NULL REFERENCES automation_actions(id),
  user_id uuid NOT NULL,
  tenant_id uuid NOT NULL,
  reason text NOT NULL,

  // ⚠️ 🔥 12번: Auto-Action Undo 원본 상태 저장 구조
  before_state jsonb NOT NULL,  // 변경 전 전체 상태 (snapshot)
  after_state jsonb NOT NULL,   // 변경 후 전체 상태 (snapshot)
  reversible boolean NOT NULL DEFAULT true,  // Undo 가능 여부 플래그

  // 원본 상태 복구에 필요한 추가 정보
  original_action_type text NOT NULL,  // 원본 액션 타입 (예: 'auto_billing_create')
  original_entity_type text NOT NULL,  // 원본 엔티티 타입 (예: 'invoice')
  original_entity_id uuid NOT NULL,    // 원본 엔티티 ID

  undo_status text NOT NULL,
  comment text,
  created_at timestamptz NOT NULL DEFAULT now()
);

// ⚠️ 원본 상태 저장 규칙:
// - before_state: 변경 전 전체 엔티티 상태를 JSON으로 저장
// - after_state: 변경 후 전체 엔티티 상태를 JSON으로 저장
// - reversible: 이 액션을 Undo할 수 있는지 여부 (false면 Undo 불가)
// - 원본 상태 복구 시 before_state를 그대로 복원
```

**Audit Log 기록 항목:**
- action_id: Undo된 액션 ID
- user_id: Undo 실행한 사용자
- before_state: Undo 전 상태 (JSON)
- after_state: Undo 후 상태 (JSON)
- reason: Undo 사유
- undo_status: Undo 성공/실패 상태

**Audit Log 활용:**
- Undo 이력 추적
- 보안 감사
- 문제 분석
- AI 학습 데이터

#### 3.7.7 AI Feedback Persistence (학습 저장 방식)

AI가 수정 내용을 저장하고 학습하는 구조:

**ai_feedback_logs 테이블 구조:**

| 필드 | 타입 | 설명 |
|------|------|------|
| id | UUID | PK |
| tenant_id | UUID | 멀티테넌트 |
| ai_type | VARCHAR | insight / suggestion / auto_action |
| original_output | JSONB | AI 원본 결과 |
| user_override | JSONB | 사용자 수정 내용 |
| override_type | VARCHAR | deny / edit / undo |
| created_at | TIMESTAMP | 시간 |
| applied_to_model | BOOLEAN | 모델 반영 여부 |
| feedback_context | JSONB | 추가 컨텍스트 정보 |

**피드백 처리 흐름:**
1. 사용자가 AI 결과를 수정/거부/취소
2. ai_feedback_logs에 자동 저장
3. 주기적으로 피드백 데이터를 모델 학습에 반영
4. applied_to_model = true로 업데이트

**모델 학습 반영:**
- 주기적 배치 작업으로 피드백 데이터 수집
- 모델 재학습 또는 Fine-tuning에 활용
- AI가 점점 똑똑해지는 구조 완성

**AI Feedback → 모델 반영 과정**

Feedback이 모델에 반영되는 구체적인 프로세스:

**⚠️ C12: AI Feedback learning cycle과 Event Engine 스케줄 충돌 해결:**

**AI Feedback 학습 스케줄과 Event Engine 통합 규칙:**

```typescript
AI_feedback_learning_schedule = {
  // 매일 새벽 3시에 Fine-tuning 큐 업데이트
  daily_fine_tuning_queue: '03:00',

  // ⚠️ Event Engine 스케줄과 통합:
  // - Daily queue refill(03:00) → AI Insight 생성(07:00) 사이 4시간 간격
  // - Weekly retrain(04:00 일요일) → AI Insight 생성(07:00) 사이 3시간 간격
  // - 충분한 간격으로 설정하여 Event Queue 지연 방지

  // Insights 모델 재학습 주기: 주 1회 (일요일 새벽 4시)
  insights_model_retrain: {
    schedule: 'weekly',
    day: 'sunday',
    time: '04:00',
    // ⚠️ AI Insight 생성(07:00) 전에 완료되도록 설정
    max_duration: '2 hours',  // 최대 2시간 내 완료 가정

    // ⚠️ Event Queue 우선순위 조정:
    // - AI Feedback 재학습은 낮은 우선순위로 처리
    // - 출결/결제 이벤트가 발생하면 재학습 작업 일시 중단 가능
    event_queue_priority: 'low',
    interruptible: true  // 높은 우선순위 이벤트 발생 시 중단 가능
  },

  // Risk 모델 재학습 주기: 주 1회
  risk_model_retrain: {
    schedule: 'weekly',
    day: 'sunday',
    time: '04:00',
    max_duration: '2 hours'
  },

  // Feedback 가중치 증가 규칙: 최근 30일 데이터에 가중
  feedback_weight_rule: {
    recent_30_days: 1.5,
    recent_90_days: 1.2,
    older: 1.0
  },

  // ⚠️ 대량 출결/결제 발생 시 처리:
  // 월요일 대량 이벤트 발생 시 AI Feedback 처리 → Event Queue 지연 가능
  // → AI Feedback 처리는 낮은 우선순위로 설정하여
  //   출결/결제 이벤트가 우선 처리되도록 함
  priority: 'low',  // Event Queue에서 낮은 우선순위
  batch_size: 100,  // 배치 단위로 처리하여 Queue 부하 최소화
  max_processing_time: '30 minutes'  // 최대 처리 시간 제한
}
```

**모델 반영 범위:**
- **Insights 모델**: AI 인사이트 생성 정확도 향상
- **Risk 모델**: 이탈 위험 탐지 정확도 향상
- **Suggestion 모델**: AI 추천 메시지 품질 향상
- **Auto-Action 모델**: 자동 실행 판단 정확도 향상

**Feedback 영향 범위:**
- Level 1 (AI Insight Only): Insights 모델에 반영
- Level 2 (AI Suggestion): Suggestion 모델에 반영
- Level 3 (AI Auto-Action): Auto-Action 모델에 반영

**Zero-Trust 준수:**
- 모든 AI 판단과 사용자 보정은 추적 가능
- ai_feedback_logs는 RLS로 테넌트별 완전 분리

**보정 사례:**
- 정상 학생을 이탈 위험으로 판단 → "이탈 위험 아님" 표시
- 잘못된 출결 패턴 분석 → 분석 결과 수정 및 피드백
- 미납 알림을 잘못된 학부모에게 보냄 → 알림 취소 및 재발송

## 4. UI/UX 아키텍처 (UI/UX Architecture)

### 4.1 Zero-Learning UI

사용자가 튜토리얼 없이도 직관적으로 사용할 수 있어야 한다.
- 화면이 복잡하지 않다.
- 기능보다 "해야 할 일" 중심이다.
- 한 화면에 한 가지 행동만 명확히 드러나야 한다.
- 메뉴 구조는 단순화하여, 학원 원장/선생님이 처음 접해도 즉시 사용할 수 있어야 한다.

### 4.2 Zero-Interaction UX

사용자가 클릭하지 않아도 시스템이 먼저 일을 한다.

**적용 영역:**
- 출결 자동 감지
- 자동 청구 생성
- 자동 미납 알림
- 자동 상담 요약
- 자동 리포트 생성
- 자동 통계 분석
- 자동 추천 메시지 생성

이 원칙은 출결·청구·AI·통계 전체에 적용되는 최상위 규칙이다.

### 4.3 Adaptive UI

(본 문서 1.8 섹션 참조)

### 4.4 기기별 UX(PC/Tablet/Mobile)

(본 문서 1.8 섹션 참조)

### 4.5 태블릿/키오스크 전용 UI 규약

(본 문서 3.3.9 섹션 참조)

**상세 UI/UX 규약:**
- UI/UX Technical Architecture v6.0 - "Responsive UX / Kiosk Mode" 섹션 참조

### 4.5.1 UI 기술 스택 요약

**⚠️ UI 기술 스택 핵심 규약 (U6, S3 참조):**

디어쌤 UI는 다음 기술 스택 경로를 따른다:

**레이어 구조:**
- `schema-engine` → `core-ui` → `design-system` → `theme-engine` (U6 참조)
- 의존성 방향: schema-engine → `@ui-core/react` → (design-system/theme-engine 토큰) → CSS 변수 (S3 참조)

**핵심 제약:**
- **Tailwind 클래스 직접 사용 금지**: 어떤 레이어에서도 Tailwind 클래스를 직접 사용하지 않는다
- **ui-core 기반 컴포넌트**: 실제 UI 컴포넌트는 `@ui-core/react`를 사용하며, 스타일은 design-system/theme-engine 토큰이 CSS 변수로 적용된다
- **앱 레벨 스타일 제한**: 앱 레벨(index.css)는 앱 전용 최소 스타일만 사용하고, 글로벌 스타일은 디자인 시스템/테마 엔진에서 제공한다
- **Schema Engine 중심**: 모든 UI 렌더링은 Schema Engine을 통해서만 수행한다

**상세 규약:**
- UI/UX Technical Architecture v6.0 (U6) 참조
- Schema Engine v2.1 (S3) 참조

### 4.6 홈 대시보드 우선순위 규칙

**⚠️ 홈 대시보드 정렬 원칙:**

홈 대시보드 정렬은 Group Priority → 그룹 내부 Priority 순으로 정렬한다.
StudentTaskCard의 priority는 'StudentTaskCard 그룹 내부'에서만 적용된다.

**Home Priority Rule (홈 대시보드 우선순위 규칙)**

홈 화면에서 카드 표시 우선순위:

**1순위: 긴급 알림**
- 결제 실패
- 위험 학생
- 출결 오류
- 시스템 오류

**2순위: AI 브리핑 카드**
- 오늘의 AI 인사이트
- 자동 생성된 요약 정보

**3순위: 오늘 해야 할 일(학생 업무 카드)**
- 상담 필요 학생
- 결석 학생
- 이탈 위험 학생
- 신규 등록 학생

**4순위: 오늘 반 수업 요약**
- 오늘 수업 있는 반
- 출결 현황 요약
- 수업 일정

**5순위: 통계/트렌드 요약**
- 지역 통계 요약
- 성장 지표
- 트렌드 분석

**우선순위 적용 규칙:**
- 긴급 알림은 항상 최상단 고정
- 동일 우선순위 내에서는 시간순 정렬
- 카드 개수 제한: 최대 8개 (나머지는 "더 보기"로 접근)
- 사용자가 카드를 닫으면 해당 카드는 하루 동안 숨김 처리

**⚠️ C4: Billing Home 카드 우선순위 충돌 해결:**

**홈 대시보드 카드 우선순위 통합 규칙 (확정):**

위의 "홈 대시보드 카드 우선순위 공식 테이블" (3112-3184줄)이 유일한 정식 정의입니다.

**다른 섹션에서 카드 우선순위를 언급할 때는:**
- "3.7.1 AI 브리핑 카드의 홈 대시보드 카드 우선순위 공식 테이블 참조" 형태로만 언급
- 중복된 우선순위 규칙 정의 제거

**Merge Rule 적용:**
- Card Group이 우선이고, Priority는 그룹 내부에서만 적용된다
- Emergency 그룹은 항상 최상단 고정 (priority 무시)
- AI 그룹은 Emergency 다음
- StudentTaskCard 그룹 내부에서만 priority 필드로 정렬
- emergency_card 조건이 StudentTaskCard의 priority보다 강함

**⚠️ M8: Home 화면 카드 최대 8개 규칙과 StudentTaskCard 무제한 모순 해결:**

**카드 수 제한 규칙 (v3.3 확정):**

홈 화면이 카드형인데 여러 카드가 동시에 생성되면 화면이 과밀해지므로 아래 규칙을 적용한다:

```typescript
home_card_limit = {
  // 전체 카드 최대 개수
  home_max_cards: 8,

  // 그룹별 최대 카드 개수
  per_group_max_cards: {
    EMERGENCY: 3,      // 긴급 알림 그룹 최대 3개
    AI_BRIEFING: 2,    // AI 브리핑 그룹 최대 2개
    STUDENT_TASKS: 3,  // StudentTaskCard 그룹 최대 3개 (무제한 아님)
    CLASSES: 2,        // 오늘의 반 그룹 최대 2개
    BILLING: 2,        // 수납 요약 그룹 최대 2개
    STATS: 1           // 통계 그룹 최대 1개
  },

  // StudentTaskCard는 무제한 생성 가능하나, 홈 화면에는 우선순위 상위 3개만 표시
  student_task_card_display_rule: {
    max_display: 3,  // 홈 화면에 최대 3개만 표시
    overflow_action: 'show_more_button',  // 나머지는 "더 보기" 버튼으로 접근
    overflow_url: '/students/tasks'  // 전체 StudentTaskCard 목록 페이지
  },

  // 초과 카드 처리 방식
  overflow_card_handling: {
    // 전체 카드가 8개 초과 시 처리
    when_total_exceeds_max: {
      action: 'show_more_button',
      button_text: '더 보기',
      button_url: '/home/all-cards',  // 전체 카드 목록 페이지
      show_count: true,  // "더 5개 보기" 형태로 표시
      count_format: '더 {count}개 보기'
    },

    // 그룹별 카드가 최대 개수 초과 시 처리
    when_group_exceeds_max: {
      action: 'show_group_more_button',
      button_text: '{group_name} 더 보기',
      button_url: '/home/{group_name}',  // 그룹별 카드 목록 페이지
      preserve_priority: true  // 우선순위 상위 카드만 표시
    }
  },

  // "더 보기" 동작 UX
  more_button_ux: {
    // 버튼 위치
    position: 'bottom_of_card_list',  // 카드 리스트 하단에 고정

    // 버튼 스타일
    style: {
      type: 'outlined_button',
      text: '더 보기',
      icon: 'chevron_down',
      show_count: true
    },

    // 클릭 시 동작
    on_click: {
      action: 'navigate_to_full_list',
      preserve_scroll_position: false,
      show_back_button: true
    }
  },

  // 사용자 숨김 처리 TTL 규칙
  user_hidden_card_ttl: {
    // 사용자가 카드를 닫으면 해당 카드는 하루 동안 숨김 처리
    hidden_duration: '24 hours',

    // 숨김 처리 저장 위치
    storage: 'user_preferences.hidden_cards',

    // 숨김 카드 복구 규칙
    restore_rules: {
      // 긴급 알림 카드는 숨김 해제 불가
      emergency_cards_cannot_hide: true,

      // 24시간 후 자동 복구
      auto_restore_after_ttl: true,

      // 수동 복구 가능
      manual_restore_enabled: true,
      restore_ui_location: '/settings/preferences'
    },

    // 숨김 카드 카운트
    hidden_card_counting: {
      // 숨김 카드는 home_max_cards 계산에서 제외
      exclude_from_max_count: true,

      // 숨김 카드 개수 표시
      show_hidden_count: true,
      hidden_count_format: '숨김 카드 {count}개'
    }
  }
}
  overflow_action: 'show_more_button'
}
```

**카드 그룹 분류:**
- 긴급 알림 그룹: 결제 실패, 출결 오류, 시스템 오류
- AI 브리핑 그룹: AI 인사이트 카드
- 학생 업무 그룹: 상담 필요, 결석, 이탈 위험, 신규 등록
- 반 수업 그룹: 오늘 수업 있는 반
- 통계/트렌드 그룹: 지역 통계 요약, 성장 지표

**Emergency Card 표시 조건:**

긴급 알림 카드는 아래 조건을 만족할 때만 표시된다:

```typescript
emergency_rule = {
  // 결제 실패가 2회 이상 발생
  payment_failed: count(payments where status = 'failed') >= 2,

  // 출결 오류 이벤트가 10분 이내 발생
  attendance_error_event: exists(attendance_errors within 10 minutes),

  // AI 위험 점수가 90 이상
  ai_risk_score: risk_score >= 90
}
```

**긴급 알림 카드 처리:**
- 긴급 알림은 항상 최상단 고정
- 긴급 알림은 사용자가 닫아도 1시간 후 재표시
- 긴급 알림 처리 완료 시 자동으로 카드 제거

### 4.7 메인 메뉴 구조

**기본 메뉴 (항상 노출 - 6개만)**

1. **홈**
   - 오늘의 지표
   - 통계 요약 카드
   - AI 브리핑 카드 (상단 고정)

2. **출결**
   - 오늘 출결하기
   - QR 출결 실행 (설정 활성화 시)

3. **학생**
   - 오늘의 학생 업무 카드 (자동 생성)
   - 학생 기본 조회 및 등록
   - 상담일지 작성

4. **수납**
   - 이번달 청구서 보기 (자동 생성)
   - 결제 상태 보기
   - 이번달 예상 수납률

5. **통계** 🔥 핵심 메뉴
   - AI 해석 문장 (최상단)
   - 지역 기반 통계 요약
   - 상세 분석 화면 (펼치기)
   - 비교/순위 기능
   - 히트맵 기능

6. **AI** 🔥 핵심 메뉴
   - AI 브리핑 카드
   - 상세 분석 화면
   - 출결 이상 탐지
   - 운영 리포트

**핵심 원칙:**
- 기본 메뉴는 6개만 항상 노출: 홈, 출결, 학생, 수납, 통계, AI
- 통계와 AI는 절대로 고급 메뉴에 들어가면 안 되고,
- 수납/출결/학생관리와 동일한 레벨의 메인 메뉴여야 한다.
- 화면이 곧 "해야 할 일 목록"이어야 하며, 최대 1~2탭으로 모든 업무가 처리돼야 함

### 4.8 Advanced 메뉴 기준

**고급 메뉴 (Advanced - 숨겨진 메뉴 / 펼치기 방식)**

나머지 모든 기능은 Advanced Menu로 접기

- 반/강사 관리
- 출결 설정
- 상품/청구 설정
- 메시지 템플릿/예약발송
- 정산/매출 상세
- 시스템 설정

**Advanced Functions Hidden 규칙:**
- Advanced Functions Hidden 규칙은 통계·AI에는 적용되지 않는다.
- 상품설정·정산·세부 필터·템플릿 관리 등만 감춤 대상이다.
- 초기 화면에 노출되면 혼란을 주는 운영 기능은 기본적으로 숨김 처리한다.

### 4.9 반응형 테이블 & 카드형 모바일 UI

**출결 화면**

**PC:**
- 출결 리스트 + 검색/필터 + 일자 선택

**태블릿:**
- 키오스크 모드(큰 번호 패드 + 등원/하원 버튼)

**모바일:**
- 학생용/강사용 뷰 분리, QR 스캔 진입 동선 최적화

**청구/수납 화면**

**PC:**
- 복합 테이블(학생·상품·금액·상태) + 우측 상세 패널

**모바일:**
- 카드형 리스트 + 최소 컬럼만 노출, 상세는 드로어/모달로 분리

**통계/대시보드**

**Desktop:**
- 카드 + 차트 + 히트맵 조합

**Mobile:**
- 카드형 위주, 차트는 한 화면 하나씩만 노출

**Daily-Use First**
- 매일 사용하는 기능(출결, 학생조회, 청구확인)은 최상단 메뉴에 고정한다.
- 통계와 AI는 디어쌤의 핵심 가치이므로 Daily-Use 원칙의 예외로 처리한다.
- 통계/AI는 초보자도 부담 없도록 "요약 카드 → 상세 화면" 단계 구조로 제공한다.

**Role-Based UI Simplification**
- 보조교사: '출결'만
- 선생님: '오늘 반 + 출결'
- 원장: 전체 메뉴
- 역할별로 화면 밀도 및 노출 기능이 다르다.

## 5. SDUI Schema Engine v2.1 (중앙 Schema Registry)

### 5.1 SDUI 적용 범위

(본 문서 1.6 섹션 참조)

**학원 도메인 주요 화면별 SDUI 적용 범위:**

| 화면 | SDUI 적용 여부 | 비고 |
|------|--------------|------|
| **학생 등록/수정** | 100% SDUI | FormSchema (S3 참조) |
| **반 배정** | SDUI + Custom | Table + Custom Action |
| **출결 메인 화면** | Custom | Realtime Feed (실시간 출결 처리) |
| **청구 상세** | 100% SDUI | DetailSchema (S3 참조) |
| **수납 목록** | SDUI + Custom | Table/Filter는 SDUI, 결제 처리 부분은 Custom |
| **통계 대시보드** | Custom | Analytics 차트 (실시간 차트/히트맵) |
| **AI 인사이트 화면** | Custom | 실시간 위험 감지, 인터랙티브 차트 |
| **환경설정 화면** | 100% SDUI | FormSchema (S3 참조) |
| **메시지 템플릿 관리** | 100% SDUI | FormSchema (S3 참조) |

**SDUI 적용 원칙:**
- 정적 폼/테이블/상세 화면: 100% SDUI 적용
- 실시간 데이터 처리 화면: SDUI + 커스텀 위젯 혼합
- 복잡한 상호작용 화면: 커스텀 위젯 중심, 기본 레이아웃만 SDUI 활용

### 5.2 SDUI vs Custom 경계 규칙

**SDUI와 Custom UI의 경계 조건**

개발 시 충돌을 방지하기 위한 명확한 경계 규칙:

**① 실시간 데이터가 필요한 화면은 Custom Only**
- 출결 화면 (실시간 출결 처리)
- 라이브 반 수업 (실시간 학생 상태)
- AI 모니터링 (실시간 위험 감지)
- 실시간 통계 대시보드

**② 사용자 상호작용이 많은 화면은 SDUI 비권장**
- 캘린더 편성표 (드래그 앤 드롭, 복잡한 상호작용)
- 출결부 (실시간 체크, 복잡한 필터)
- AI 대시보드 (인터랙티브 차트, 실시간 업데이트)

**③ SDUI 출력 구조의 표준 Component Set**

**Form:**
- Field.Control: 단일 필드 입력
- Field.Group: 필드 그룹화
- Section: 섹션 구분

**Table:**
- Columns: 컬럼 정의
- Pagination: 페이지네이션
- Filter: 필터 패널
- Summary: 요약 행

**Detail:**
- KeyValueView: 키-값 쌍 표시

**Widget:**
- Card: 카드 레이아웃
- Metric: 지표 표시
- ChipList: 칩 리스트

이 표준 Component Set을 준수하여 개발자마다 다른 구조로 설계되는 것을 방지한다.

### 5.3 Form Schema

**SDUI Component Props 구조 명세**

각 SDUI 컴포넌트의 JSON Schema 구조:

**Field.Control Props:**
- id: string (필수)
- label: string (필수)
- type: 'text' | 'number' | 'select' | 'date' | 'datetime' | 'email' | 'phone' | 'textarea' | 'checkbox' | 'radio' (필수)
- placeholder: string (선택)
- default_value: any (선택)
- validation: ValidationRule (선택)
- condition: ConditionRule[] (선택)
- options?: Option[] (select/radio 타입 시 필수)

**Field.Group Props:**
- fields: Field.Control[] (필수)
- layout: { columns: number, columnGap: string } (선택)
- title?: string (선택)

**Section Props:**
- title: string (필수)
- description?: string (선택)
- fields: (Field.Control | Field.Group)[] (필수)
- collapsible?: boolean (선택)

**JSON Schema 예시:**

```json
{
  "version": "1.0.0",
  "entity": "student",
  "type": "form",
  "form": {
    "fields": [
      {
        "id": "name",
        "label": "이름",
        "type": "text",
        "placeholder": "학생 이름을 입력하세요",
        "validation": {
          "required": true,
          "min": 1,
          "max": 50
        }
      },
      {
        "id": "grade",
        "label": "학년",
        "type": "select",
        "options": [
          { "value": "1", "label": "1학년" },
          { "value": "2", "label": "2학년" }
        ],
        "default_value": "1",
        "condition": [
          {
            "field": "student_type",
            "op": "==",
            "value": "regular",
            "action": "show"
          }
        ]
      }
    ]
  }
}
```

### 5.4 Table Schema

**⚠️ B5: SDUI Table Schema 예시 추가:**

**Table Props:**
- columns: ColumnDefinition[] (필수)
- data: any[] (필수)
- pagination?: { page: number, pageSize: number } (선택)
- filter?: FilterSchema (선택)
- summary?: SummaryRow (선택)
- actions?: TableActions (선택)

**Table SDUI Schema 예시:**

```json
{
  "version": "1.0.0",
  "entity": "student",
  "type": "table",
  "table": {
    "columns": [
      {
        "id": "name",
        "label": "이름",
        "type": "text",
        "sortable": true,
        "width": "150px"
      },
      {
        "id": "grade",
        "label": "학년",
        "type": "number",
        "sortable": true,
        "width": "80px"
      },
      {
        "id": "class_name",
        "label": "반",
        "type": "text",
        "sortable": true,
        "width": "120px"
      },
      {
        "id": "status",
        "label": "상태",
        "type": "badge",
        "badge_config": {
          "present": { "color": "green", "label": "재원" },
          "absent": { "color": "red", "label": "휴원" }
        },
        "width": "100px"
      },
      {
        "id": "created_at",
        "label": "등록일",
        "type": "date",
        "sortable": true,
        "width": "120px"
      }
    ],
    "pagination": {
      "enabled": true,
      "pageSize": 20,
      "pageSizeOptions": [10, 20, 50, 100]
    },
    "filter": {
      "enabled": true,
      "fields": [
        {
          "id": "grade",
          "type": "select",
          "options": [
            { "value": "1", "label": "1학년" },
            { "value": "2", "label": "2학년" }
          ]
        },
        {
          "id": "status",
          "type": "select",
          "options": [
            { "value": "present", "label": "재원" },
            { "value": "absent", "label": "휴원" }
          ]
        },
        {
          "id": "search",
          "type": "text",
          "placeholder": "이름으로 검색"
        }
      ]
    },
    "summary": {
      "enabled": true,
      "rows": [
        {
          "label": "전체 학생 수",
          "value": "count(*)",
          "position": "bottom"
        }
      ]
    }
  }
}
```

**Table Actions 정의:**

```json
{
  "actions": {
    "row": [
      {
        "id": "view",
        "label": "보기",
        "action_url": "/students/{id}",
        "icon": "string (선택)"
      },
      {
        "id": "edit",
        "label": "수정",
        "action_url": "/students/{id}/edit",
        "icon": "string (선택)"
      },
      {
        "id": "menu",
        "label": "더보기",
        "menu_items": [
          { "id": "delete", "label": "삭제", "action": "delete" },
          { "id": "export", "label": "내보내기", "action": "export" }
        ]
      }
    ],
    "bulk": [
      {
        "id": "export",
        "label": "엑셀 다운로드",
        "action": "export_excel"
      },
      {
        "id": "send_message",
        "label": "공지 보내기",
        "action": "send_notification"
      },
      {
        "id": "bulk_update",
        "label": "일괄 수정",
        "action": "bulk_edit"
      }
    ],
    "inline_edit": {
      "enabled": true,
      "editable_fields": ["name", "grade"],
      "save_action": "update_student",
      "save_method": "edge_function"  // edge_function | supabase_rpc | direct_update
    }
  }
}
```

**Inline Edit 저장 방식:**

SDUI Table의 inline_edit 기능은 아래 방식 중 하나로 저장된다:

```typescript
inline_edit_save_method = {
  // 방법 1: Edge Function 호출 (권장)
  edge_function: {
    endpoint: '/api/students/{id}',
    method: 'PATCH',
    validation: 'server_side'
  },

  // 방법 2: Supabase RPC 호출
  supabase_rpc: {
    function_name: 'update_student',
    params: { id, field, value }
  },

  // 방법 3: Direct Table Update (RLS 정책 통과)
  direct_update: {
    table: 'students',
    where: { id },
    update: { field: value }
  }
}
```

**⚠️ C5: SDUI Inline Edit Direct Update 규칙 통일 (확정):**

문서 내 서로 다른 설명이 있었으나, 아래 확정본으로 통일:

**Direct Update 허용 범위 제한 (공식 규칙):**

Direct Update는 RLS 정책 충돌 가능성이 있으므로 매우 제한된 테이블/필드에서만 허용한다:

```typescript
// ⚠️ 공식 Direct Update 허용/금지 목록 (v3.2 확정)
direct_update_allowed = {
  // 기본 정책: Direct Update는 기본적으로 비활성화
  default_policy: {
    direct_update_enabled: false,  // 기본값: false
    allow_list_only: true  // Allow-list에 포함된 테이블만 enable
  },

  // 허용 테이블 목록 (Allow-list)
  allowed_tables: [
    'students',  // 단순 필드만 (name, grade, status)
    'classes',   // 단순 필드만 (name, color, capacity)
    'contacts'   // 단순 필드만 (phone, email, address)
  ],

  // 금지 테이블 (Forbidden-list, 절대 Direct Update 불가)
  forbidden_tables: [
    'invoices',         // 결제/수납 관련 → Edge Function 필수
    'payments',         // 결제 내역 → Edge Function 필수
    'attendance_logs',  // 출결 기록 → Edge Function 필수
    'ai_insights',     // AI 인사이트 → Edge Function 필수
    'notifications',    // 알림 발송 → Edge Function 필수
    'ai_feedback_logs', // AI 피드백 로그 → Edge Function 필수
    'automation_undo_logs' // 자동화 Undo 로그 → Edge Function 필수
  ],

  // 허용 필드 제한 (테이블별 세부 필드 제한)
  allowed_fields: {
    students: ['name', 'grade', 'status'],
    classes: ['name', 'color', 'capacity'],
    contacts: ['phone', 'email', 'address']
  },

  // 금지 필드 (허용 테이블 내에서도 금지)
  forbidden_fields: {
    students: ['tenant_id', 'industry_type', 'created_at', 'updated_at'],
    classes: ['tenant_id', 'industry_type', 'created_at', 'updated_at'],
    contacts: ['tenant_id', 'created_at', 'updated_at']
  }
}
```

**저장 방식 선택 규칙 (확정):**
- 복잡한 비즈니스 로직이 필요한 경우: Edge Function (권장)
- 단순 필드 업데이트: Supabase RPC (권장)
- 실시간성이 중요한 경우: Direct Update (허용 테이블/필드만, RLS 정책 필수, 기본 비활성화)
- 출결/청구/AI 관련 테이블: Direct Update 절대 금지, Edge Function 필수

**⚠️ Implementation 가이드:**
- Direct Update는 기본적으로 비활성화
- Allow-list에 포함된 테이블만 enable
- RLS 정책이 모든 필드에 적용되는지 확인 필수
- 권한 검증이 서버 측에서 수행되는지 확인 필수
- Audit Log가 모든 변경사항을 기록하는지 확인 필수

**SDUI Inline Edit 저장 실패 시 Rollback 처리:**

저장 실패 시 UI rollback 규칙:

```typescript
inline_edit_rollback = {
  // 저장 실패 시, SDUI 엔진은 편집 전 상태(prev_state)를 즉시 복구
  on_save_failure: {
    action: 'rollback_to_prev_state',
    restore_fields: 'all_edited_fields',
    show_error_message: true
  },

  // prev_state는 편집 시작 시점에 자동 저장
  prev_state_storage: {
    on_edit_start: 'save_prev_state',
    storage_location: 'component_state'
  }
}
```

**Rollback 처리 규칙:**
- 편집 시작 시점에 편집 전 상태(prev_state) 자동 저장
- 저장 실패 시 즉시 prev_state로 복구
- 사용자에게 저장 실패 오류 메시지 표시
- 복구된 필드는 편집 전 값으로 되돌림
- 네트워크 오류, 서버 오류, 검증 실패 등 모든 실패 케이스에 적용
```

**Row Action:**
- 각 행에 대한 개별 액션 버튼
- 보기, 수정, 삭제, 메뉴 등

**Bulk Action:**
- 다중 선택 시 일괄 처리 액션
- 엑셀 다운로드, 공지 보내기, 일괄 수정 등

**Inline Edit:**
- 테이블 내 직접 수정 기능
- 편집 가능한 필드 지정
- 저장 액션 정의

### 5.5 Detail Schema

**⚠️ B5: SDUI Detail Schema 예시 추가:**

**Detail Props:**
- fields: KeyValueField[] (필수)
- layout: 'vertical' | 'horizontal' | 'grid' (선택)

**Detail SDUI Schema 예시:**

```json
{
  "version": "1.0.0",
  "entity": "student",
  "type": "detail",
  "detail": {
    "layout": "vertical",
    "sections": [
      {
        "title": "기본 정보",
        "fields": [
          {
            "id": "name",
            "label": "이름",
            "type": "text",
            "value": "{student.name}"
          },
          {
            "id": "grade",
            "label": "학년",
            "type": "number",
            "value": "{student.grade}"
          },
          {
            "id": "class_name",
            "label": "반",
            "type": "text",
            "value": "{student.class_name}"
          },
          {
            "id": "status",
            "label": "상태",
            "type": "badge",
            "value": "{student.status}",
            "badge_config": {
              "present": { "color": "green", "label": "재원" },
              "absent": { "color": "red", "label": "휴원" }
            }
          }
        ]
      },
      {
        "title": "연락처 정보",
        "fields": [
          {
            "id": "parent_name",
            "label": "학부모명",
            "type": "text",
            "value": "{student.parent_name}"
          },
          {
            "id": "phone",
            "label": "연락처",
            "type": "phone",
            "value": "{student.phone}"
          },
          {
            "id": "email",
            "label": "이메일",
            "type": "email",
            "value": "{student.email}"
          }
        ]
      }
    ],
    "actions": [
      {
        "id": "edit",
        "label": "수정",
        "action_url": "/students/{id}/edit",
        "type": "button"
      },
      {
        "id": "delete",
        "label": "삭제",
        "action": "delete",
        "type": "button",
        "variant": "danger"
      }
    ]
  }
}
```

### 5.6 Widget Schema

**Widget Props:**
- type: 'card' | 'metric' | 'chiplist' (필수)
- data: any (필수)
- config: WidgetConfig (선택)

### 5.7 Validation Rule

**SDUI Validation & ConditionRule 규칙**

Schema Engine v2.1에 따른 Validation 및 ConditionRule 명세:

**Validation 규격:**

**required:**
- 필수 필드 검증
- 예: { validation: { required: true } }

**min/max:**
- 숫자/문자열 길이 제한
- 예: { validation: { min: 1, max: 100 } }

**regex:**
- 정규식 패턴 검증
- 예: { validation: { regex: "^[0-9]{3}-[0-9]{4}-[0-9]{4}$" } }

**custom (Edge Function 호출):**
- 커스텀 검증 로직
- 예: { validation: { custom: "validate-student-id" } }
- Edge Function에서 검증 수행 후 결과 반환

### 5.8 ConditionRule

**ConditionRule 규격:**

**field == value:**
- 필드 값 일치 조건
- 예: { condition: { field: "student_type", op: "==", value: "regular" } }

**field in [...]:**
- 필드 값이 배열 내 포함 여부
- 예: { condition: { field: "grade", op: "in", value: ["1", "2", "3"] } }

**visibility (show/hide):**
- 조건에 따른 필드 표시/숨김
- 예: { condition: { field: "has_parent", op: "==", value: true }, action: "show" }

**readonly (true/false):**
- 조건에 따른 필드 읽기 전용 설정
- 예: { condition: { field: "status", op: "==", value: "graduated" }, action: "readonly" }

**default_value (동적):**
- 조건에 따른 기본값 동적 설정
- 예: { condition: { field: "billing_mode", op: "==", value: "prepaid" }, default_value: 0 }

이 규칙이 없으면 SDUI 폼 생성 시 테넌트/업종별 동작이 불안정해진다.

### 5.9 Field-Level Event

**SDUI Form Schema의 Field-Level Event**

Field 변경 시 다른 Field 값 자동 변경을 위한 Form-Level Event 규칙:

**Field Event Rule:**

```json
{
  "events": [
    {
      "trigger": "billing_mode",
      "action": "set_default",
      "target": "amount",
      "value_map": {
        "prepaid": 300000,
        "postpaid": 250000
      }
    },
    {
      "trigger": "student_type",
      "action": "set_default",
      "target": "enrollment_fee",
      "value_map": {
        "regular": 0,
        "premium": 50000
      }
    }
  ]
}
```

**Event Action 타입:**
- set_default: 기본값 설정
- show/hide: 필드 표시/숨김
- enable/disable: 필드 활성화/비활성화
- set_options: 옵션 목록 동적 변경

**Event Trigger 조건:**
- field 값 변경 시
- field 값이 특정 조건일 때
- 복수 필드 조건 (AND/OR)

**⚠️ 복합 조건(AND/OR) 예시:**

```json
{
  "events": [
    {
      "trigger": {
        "logic": "AND",
        "conditions": [
          { "field": "student_type", "op": "==", "value": "regular" },
          { "field": "grade", "op": "in", "value": ["1", "2", "3"] }
        ]
      },
      "action": "set_default",
      "target": "enrollment_fee",
      "value": 0
    },
    {
      "trigger": {
        "logic": "OR",
        "conditions": [
          { "field": "billing_mode", "op": "==", "value": "prepaid" },
          { "field": "payment_method", "op": "==", "value": "card" }
        ]
      },
      "action": "show",
      "target": "discount_field"
    }
  ]
}
```

**예시 시나리오:**
- billing_mode 선택 → 금액/회차 자동 채움
- student_type 변경 → 특정 필드 default 자동 설정
- grade 선택 → 해당 학년 반 목록만 표시

이 규칙이 없으면 SDUI Form의 동적 상호작용이 불가능하다.

### 5.10 Industry Override → Tenant Override 규칙

**SDUI 우선순위 규칙:**

1. tenant override (테넌트별 커스텀 스키마)
2. industry override (업종별 스키마)
3. core default (공통 기본 스키마)

### 5.11 Custom Widget 등록 규칙

Custom Widget은 SDUI 내에서 동적 로딩 가능하다.

## 6. Event Engine (Automation & Workflow Engine)

### 6.1 Event Source 4종

(본 문서 1.5 섹션 참조)

### 6.2 Event Priority Rule

**Event Priority Rule (이벤트 우선순위 규칙)**

여러 이벤트가 동시에 발생할 경우 우선순위에 따라 처리한다.

**우선순위 (높은 순서):**
1. 결제(Webhook) - 최우선 처리
2. 출결(Behavior) - 즉시 처리
3. AI 위험 감지(Pattern) - 빠른 처리
4. 대시보드 업데이트(Time-based) - 일반 처리
5. 메시지 자동 발송(Behavior/Pattern) - 일반 처리

**충돌 시 처리 규칙:**
- 높은 우선순위 이벤트만 즉시 실행
- 낮은 우선순위 이벤트는 5~30초 지연 큐에 넣고 순차 처리
- UI에는 "자동 처리 중" 알림만 표시
- 동일 우선순위 이벤트는 발생 시간 순서대로 처리

**예시 시나리오:**
- 07:00 AI 브리핑 생성 중에 출결 이벤트 발생
  → 출결 이벤트 즉시 처리, AI 브리핑은 30초 지연 후 처리
- 웹훅 → 미납 자동 알림 → AI 위험 분석이 연속적으로 중첩
  → 웹훅 즉시 처리, 미납 알림 5초 지연, AI 분석 10초 지연

### 6.3 Event Queue & Retry

**Event Queue 구조:**

- 모든 이벤트는 `event_logs` + 내부 Queue에 적재 후 비동기 처리
- 우선순위 큐(Priority Queue) 사용: 결제 > 출결 > AI > 대시보드 > 일반 메시지
- Retry는 3회, Exponential Backoff (1초 → 5초 → 30초)
- 재시도 실패 이벤트는 DLQ로 이동 (본 문서 6.5 섹션 참조)

### 6.4 Event Reliability Spec (신뢰성 보장 규칙)

대규모 SaaS 운영을 위한 이벤트 신뢰성 보장 정책:

**재시도 정책:**
- 모든 이벤트는 최대 3회 재시도
- 재시도 간격: Exponential Backoff (1초 → 5초 → 30초)
- Webhook 이벤트는 재시도 + 멱등성 키(idempotency_key) 확인

### 6.5 Dead-Letter Queue

**Dead Letter Queue (DLQ):**
- 실패 시 DLQ에 저장 → 재처리 페이지 제공
- AI 분석 실패, 결제 처리 실패 등 영구 실패 이벤트 저장
- 관리자 대시보드에서 DLQ 이벤트 조회 및 수동 재처리 가능

### 6.6 Batch Flush

**Batch Flush 정책:**
- 출결·메시지 이벤트는 Batch Flush(1초 단위 묶음 처리)
- 단일 이벤트 처리 방식은 성능 낭비 방지
- 동일 타입 이벤트는 1초 내 묶어서 일괄 처리

### 6.7 멱등성(idempotency_key) 구조

**Event Engine 멱등성 규칙의 DB Level 정의**

모든 이벤트는 멱등성(idempotency_key)을 보장해야 한다.

**event_logs 테이블 구조:**

```sql
CREATE TABLE event_logs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  idempotency_key text UNIQUE NOT NULL,
  event_type text NOT NULL,
  tenant_id uuid NOT NULL,
  payload jsonb NOT NULL,
  status text NOT NULL DEFAULT 'pending',
  created_at timestamptz NOT NULL DEFAULT now(),
  processed_at timestamptz,
  retry_count integer DEFAULT 0,
  error_message text
);

CREATE UNIQUE INDEX idx_event_logs_idempotency
ON event_logs(idempotency_key);
```

**⚠️ C11: Billing Webhook 멱등성 규칙 통일 (확정):**

실제 PG Webhook 설계에 따라 하나의 방식으로 확정:

```typescript
// ⚠️ 공식 멱등성 키 생성 규칙 (v3.2 확정)
idempotency_key_generation = {
  // Webhook 멱등성 키 생성 (통일 규칙)
  webhook: {
    // 기본 규칙: provider + webhook_id + payment_id (또는 invoice_id)
    // timestamp는 webhook_id에 포함되어 있을 수 있으나, 별도로 추가하지 않음
    standard: '{provider}_{webhook_id}_{payment_id}',

    // payment_id가 없는 경우 (예: 청구서 생성 webhook)
    fallback: '{provider}_{webhook_id}_{invoice_id}',

    // 둘 다 없는 경우 (드문 경우)
    fallback2: '{provider}_{webhook_id}_{tenant_id}_{received_at}',

    // ⚠️ timestamp를 별도로 추가하지 않음
    // webhook_id 자체가 Provider에서 고유성을 보장하므로
    // payment_id 또는 invoice_id만 추가하면 충분
  },

  // Behavior Event 멱등성 키
  behavior_event: '{event_type}_{entity_id}_{timestamp}',

  // Pattern Event 멱등성 키
  pattern_event: '{pattern_type}_{tenant_id}_{detected_at}'
}
```

**멱등성 키 생성 규칙 (확정):**
- Webhook: `{provider}_{webhook_id}_{payment_id}` (또는 `{invoice_id}`)
- Behavior Event: `{event_type}_{entity_id}_{timestamp}`
- Pattern Event: `{pattern_type}_{tenant_id}_{detected_at}`

**⚠️ 이전 버전의 `{provider}_{webhook_id}_{timestamp}` 방식은 사용하지 않음**

**멱등성 검증:**
- 이벤트 처리 전 idempotency_key로 중복 확인
- 중복 발견 시 기존 이벤트 결과 반환
- 새로운 이벤트는 event_logs에 저장 후 처리

**적용 범위:**
- Webhook(알림뱅크): 결제 이벤트 중복 방지
- Behavior Event(출결): 출결 이벤트 중복 방지
- Pattern Event(AI): AI 분석 이벤트 중복 방지

멱등성이 없으면 중복 폭탄 시스템이 된다.

### 6.8 Event Logs 테이블 스키마

(본 문서 6.7 섹션 참조)

### 6.9 Event → AI → Billing/Notification 연동

**시스템 이벤트 Role 정의:**
Time-based 자동 청구 생성, Webhook 이벤트 등 시스템이 직접 생성하는 이벤트는 `system_role = 'system'`으로 평가된다.
이 `system_role`은 Event Engine의 Role 검증 시 특정 권한을 우회하거나, 시스템 내부 로직에 따라 특별 처리된다.

**⚠️ C12: AI Feedback learning cycle과 Event Engine 스케줄 통합:**

**Event Engine 스케줄과 AI Feedback 학습 스케줄 통합 규칙:**

```typescript
ai_feedback_event_schedule_alignment = {
  // Event Engine Time-based 스케줄
  event_engine_schedule: {
    '04:00': 'auto_billing_generation',  // 자동 청구 생성
    '07:00': 'ai_insight_generation',     // AI 인사이트 생성
    '23:59': 'daily_statistics_update'    // 일일 통계 업데이트
  },

  // AI Feedback 학습 스케줄
  ai_feedback_schedule: {
    '03:00': 'daily_fine_tuning_queue_refill',  // Fine-tuning 큐 업데이트
    '04:00_sunday': 'weekly_model_retrain'      // 주간 모델 재학습
  },

  // ⚠️ 충돌 방지 규칙:
  conflict_prevention: {
    // 1. AI Feedback 재학습은 낮은 우선순위로 처리
    ai_feedback_priority: 'low',

    // 2. 출결/결제 이벤트 발생 시 AI Feedback 작업 일시 중단
    interrupt_on_high_priority_event: true,

    // 3. 월요일 대량 출결/결제 발생 시 AI Feedback 지연 처리
    monday_high_volume_handling: {
      detect_high_volume: 'count(events) > 100 within 1 hour',
      action: 'delay_ai_feedback_processing',
      delay_duration: '30 minutes',
      resume_after: 'event_queue_normalized'
    },

    // 4. AI Insight 생성(07:00) 전에 모든 AI Feedback 작업 완료 보장
    ensure_completion_before_insight: {
      deadline: '06:30',  // AI Insight 생성 30분 전
      action: 'force_complete_or_skip'
    }
  }
}
```

**⚠️ 핵심 개선안 2: Event → Notification → AI → UI 일원화 흐름도**

**통합 시퀀스 다이어그램 (v3.2):**

```
[Event Source] → [Event Engine] → [AI Engine] → [Notification Engine] → [UI]
     |                |                |                  |                |
     |                |                |                  |                |
  출결/결제      Role 검증         Risk 분석         채널 라우팅      권한 필터링
     |                |                |                  |                |
     |                |                |                  |                |
     v                v                v                  v                v
[Event Logs]   [Event Queue]   [AI Insights]    [Notification Logs]  [Dashboard]
```

**상세 흐름:**

**1) 출결 이벤트 흐름:**
```
attendance_created (by Teacher/Assistant)
  → Event Engine (Role 검증)
  → AI Risk Detection (Trigger)
  → AI Insight 생성 (Result Visibility: Teacher=visible, Assistant=hidden)
  → Notification (출결 알림, Role에 따라 발송)
  → UI (권한에 따라 카드 표시/숨김)
```

**2) 결제 Webhook 흐름:**
```
payment_webhook (by System)
  → Event Engine (system_role, bypass role check)
  → Billing Engine (invoice/payment 업데이트)
  → AI Insight 업데이트 (미납 해소 카드 제거)
  → Notification (결제 완료 알림, 미납 알림 취소)
  → UI (Billing Home 카드 업데이트)
```

**3) 상담일지 저장 흐름:**
```
counseling_note_saved (by Teacher)
  → Event Engine (Role 검증: Teacher)
  → AI Summary Generation (Trigger)
  → AI Insight 생성 (Result Visibility: Teacher=visible)
  → Notification (선택적, 상담 요약 완료 알림)
  → UI (StudentTaskCard 업데이트)
```

**⚠️ C2: Event → Notification → AI 흐름 Role 제한 충돌 완전 해결:**

**Role → Event → Result → UI 권한 매핑 테이블 (완전 명세):**

| Event Source | Event Role | AI Trigger | AI Result Visibility | Notification | UI Visibility |
|-------------|-----------|-----------|---------------------|--------------|--------------|
| 출결 생성 (Assistant) | assistant | ai_risk_detection | assistant=hidden, teacher=visible, admin=visible | 출결 알림 (발송) | Assistant는 AI 카드 숨김 |
| 출결 생성 (Teacher) | teacher | ai_risk_detection | teacher=visible, admin=visible | 출결 알림 (발송) | Teacher는 AI 카드 표시 |
| 상담일지 저장 (Teacher) | teacher | ai_summary | teacher=visible, admin=visible | 선택적 | Teacher는 요약 표시 |
| 결제 Webhook (System) | system | ai_insight_update | all=visible | 결제 알림 (발송) | 모든 Role 표시 |
| 자동 청구 생성 (System) | system | billing_auto | admin=visible, sub_admin=visible | 청구 알림 (발송) | Admin/Sub Admin만 표시 |

**Event 연동 흐름:**

**Payment Webhook → Event → Billing/Notification:**
- `payment_webhook` 수신 → `event_logs`에 `event_type='payment_webhook'` 기록
- Event Engine이 이를 처리 (`system_role`로 평가):
  1) `invoices` / `payments` 업데이트
  2) 미납 해소 시 미납 알림 스케줄 취소 (3.4.3 규칙)
  3) 필요한 경우 AI 인사이트 업데이트 (예: '미납 해소' 카드 제거)

**Attendance Event → AI → Notification:**
- `attendance_event` → `ai_risk_detection` → `notification`(출결 알림/안부 문구) 순으로 연동
- 출결 이상 패턴 감지 시 AI가 위험도 분석 후 알림 발송 결정
- **Role에 따라 AI 결과 가시성 필터링 적용**

이벤트는 AI 분석, 청구 생성, 알림 발송 등과 연동되며, Role 기반 권한 매핑이 전 과정에 적용된다.

### 6.10 Role-Restricted Automation

**Event Engine 권한 기반 자동화 제한**

Event Engine 내부에서 이벤트 실행 자체를 Role로 제한하는 규칙:

**권한 기반 이벤트 필터링:**
- Teacher는 자동 미납 알림을 실행할 수 없음 → 이벤트 제거 또는 ReadOnly
- Assistant는 출결 이벤트만 생성 가능
- 원장(Admin)만 자동 청구 생성, 미납 알림 실행 가능

**이벤트 실행 전 Role Check:**
- 모든 이벤트 실행 전 사용자 Role 확인
- 권한 없는 Role의 이벤트는 자동 제거 또는 무시
- 권한 부족 시 관리자에게 알림 카드 생성

**이벤트 생성 시 Role 검증:**
- 출결 이벤트: Teacher, Assistant 생성 가능
- 미납 알림 이벤트: Admin만 생성 가능
- 자동 청구 이벤트: Admin만 생성 가능
- AI 분석 이벤트: Admin, Sub Admin, Teacher 생성 가능

**⚠️ 시스템 자동 생성 이벤트의 Role 정의:**

Time-based 자동 청구 생성, Webhook 이벤트 등 시스템이 자동 생성한 이벤트는 role이 없으므로 별도 처리 규칙이 필요하다:

```typescript
system_event_role = {
  // 시스템 자동 생성 이벤트는 'system' role로 처리
  system_role: 'system',

  // Super Admin은 모든 이벤트에 접근 가능
  super_admin_role: 'super_admin',

  // Role 검증 규칙
  role_check_rule: {
    // system role 이벤트는 role 검증 우회
    system_events: 'bypass_role_check',

    // 사용자 생성 이벤트는 role 검증 필수
    user_events: 'require_role_check'
  }
}
```

**시스템 이벤트 처리:**
- Time-based 자동 청구 생성: `role='system'` → role 검증 우회
- Webhook 이벤트: `role='system'` → role 검증 우회
- 사용자 행동 기반 이벤트: 사용자 role 검증 필수
- AI Pattern 이벤트: `role='system'` → role 검증 우회

**⚠️ Event Engine Role-Based Automation과 Notification/AI Trigger 규칙 충돌 해결:**

Teacher/Assistant의 행동 제약이 Notification/AI Trigger 규칙과 충돌하는 문제를 해결:

```typescript
event_role_result_visibility_matrix = {
  // Event → Result → UI 권한 매핑 테이블
  mapping: {
    // Assistant가 출결 생성 → AI Risk Detection 트리거
    'attendance_created_by_assistant': {
      event_role: 'assistant',
      triggers: ['ai_risk_detection'],
      result_visibility: {
        // Assistant는 Risk Insight를 볼 수 없음
        assistant: 'hidden',
        teacher: 'visible',
        admin: 'visible'
      },
      action: 'create_insight_but_hide_from_assistant'
    },

    // Teacher가 상담일지 저장 → AI Insight 생성
    'counseling_note_saved_by_teacher': {
      event_role: 'teacher',
      triggers: ['ai_insight_generation'],
      result_visibility: {
        teacher: 'visible',  // Teacher는 볼 수 있음
        assistant: 'hidden',
        admin: 'visible'
      },
      action: 'create_insight_with_teacher_visibility'
    }
  },

  // Role → Event → Result → UI 권한 전부 매핑
  role_event_result_ui_mapping = {
    assistant: {
      can_create_events: ['attendance_created'],
      cannot_create_events: ['billing_auto_generate', 'unpaid_notification'],
      event_results: {
        attendance_created: {
          ai_risk_detection: 'hidden',  // AI 결과는 숨김
          notification: 'hidden',       // 알림도 숨김
          statistics: 'visible'         // 통계는 볼 수 있음
        }
      }
    },
    teacher: {
      can_create_events: ['attendance_created', 'counseling_note_saved'],
      cannot_create_events: ['billing_auto_generate', 'unpaid_notification'],
      event_results: {
        attendance_created: {
          ai_risk_detection: 'visible',
          notification: 'visible',
          statistics: 'visible'
        },
        counseling_note_saved: {
          ai_insight: 'visible',
          ai_summary: 'visible'
        }
      }
    }
  }
}
```

**충돌 해결 규칙:**
- Assistant는 출결 생성 가능하지만, AI Risk Detection 결과는 볼 수 없음
- Teacher는 상담일지 저장 시 AI Insight 생성 가능, 결과도 볼 수 있음
- Event → Result → UI 권한이 전부 매핑되어 있어 권한 충돌 방지
- 시스템 이벤트는 role 검증을 우회하되, 실행 결과는 권한 매트릭스에 따라 필터링

**Permission Matrix와의 연동:**
- Automation Permission Matrix의 권한 규칙을 Event Engine에서도 적용
- UI 관점뿐만 아니라 Event Engine 내부 동작에도 role-check 규칙 적용
- 시스템 이벤트는 role 검증을 우회하되, 실행 결과는 권한 매트릭스에 따라 필터링

**Queue Overflow 처리:**
- Queue Overflow 시 FIFO Drop 옵션 또는 Sticky Priority Queue 적용
- 낮은 우선순위 이벤트는 자동 Drop, 높은 우선순위는 유지
- Overflow 발생 시 관리자에게 알림 카드 생성

**네트워크 장애 처리:**
- 네트워크 장애 시 Webhook 처리 재시도 정책 적용
- 알림뱅크 Webhook 실패 → 결제 상태 Sync 보장을 위한 재시도
- 최대 3회 재시도 후 DLQ에 저장

**이벤트 드리프트 방지:**
- 이벤트 처리 실패로 인한 자동화 불일치 방지
- 모든 이벤트는 처리 상태 추적 (pending → processing → completed/failed)
- 실패 이벤트는 자동 재처리 또는 관리자 알림

## 7. 데이터 모델/DB 아키텍처 (DB & Data Architecture)

### 7.1 Core Entity 구조(persons, parties 등)

Core Platform의 공통 엔티티를 기반으로 확장한다.

**Core Platform 공통 엔티티:**

- **tenants**: 테넌트(학원/매장/조직) 기본 정보
- **tenant_settings**: 테넌트별 JSON 설정 (attendance, location, notification, billing 등)
- **persons**: 개인 정보 (학생, 학부모, 교사 등)
- **parties**: 조직/단체 정보 (학원 본원/분원, 법인 등)
- **contacts**: 연락처 정보
- **addresses**: 주소 정보

**⚠️ tenant_settings JSON 구조 통합 원칙:**

문서 전반에서 사용하는 `tenant_settings.attendance`, `tenant_settings.location` 등은 모두 `tenant_settings` 엔티티의 JSON 필드 내부 서브필드이다. 이 구조는 Schema 설계 시 단일 소스로 관리된다.

**tenant_settings.json_schema.v1 공식 정의:**

모든 테넌트 설정은 아래 단일 JSON 스키마로 통합 관리된다:

```json
{
  "attendance": {
    // 3.3.7 출결 설정 참조
    "late_after_minutes": 10,
    "absent_after_minutes": 60,
    "allow_duplicate_checkin": false,
    "time_format_24h": true,
    "default_mode": "pc",
    "qr_enabled": true,
    "qr_token_expiry_days": 90,  // ⚠️ 3.3.7 출결 설정 참조 (중복 제거)
    "qr_auth_fallback_enabled": true,
    "sms_auth_fallback_enabled": true,
    "qr_gps_enabled": false,
    "qr_gps_radius_meters": 150,
    "device_fingerprint_strict": true,
    "device_fingerprint_fallback_policy": "sms_auth",  // ⚠️ 3.3.7 출결 설정 참조 (중복 제거)
    "class_specific_late_rules": {}  // ⚠️ 3.3.7 출결 설정 참조 (중복 제거)
  },
  "location": {
    // 3.6.2 지역코드 규칙 참조
    "si": "서울특별시",
    "gu": "강남구",
    "dong": "대치동",
    "lat": 37.498,
    "lng": 127.061,
    "sido_code": "11",
    "sigungu_code": "11680",
    "location_code": "1168010100",
    "region_code": "SEOUL_SOUTH"  // 권역 코드 (선택)
  },
  "notification": {
    "default_channel": "kakao_at",  // kakao_at | sms
    "kakao_at_fallback_to_sms": true,
    "sms_fallback_delay_seconds": 10,
    "throttle_per_parent_per_day": 20,
    "throttle_per_parent_urgent": 5,
    "same_message_hash_cooldown_minutes": 10,
    "notification_queue_grace_period_seconds": 15  // Queue 지연 고려 grace period
  },
  "billing": {
    "auto_billing_enabled": true,
    "auto_billing_time": "04:00",
    "early_payment_allowed": false,
    "early_payment_discount": null,
    "early_payment_period": null,
    "partial_payment_allowed": true,
    "monthly_closing_time": "last_day_of_month 23:59"
  },
  "ai": {
    "risk_score_weights": {
      "attendance_weight": 0.4,
      "counseling_weight": 0.3,
      "payment_weight": 0.2,
      "performance_weight": 0.1
    },
    "daily_briefing_time": "07:00",
    "model_retraining_schedule": "weekly_sunday_04:00",
    "pii_masking_enabled": true  // 개인정보 마스킹 활성화
  },
  "regional_analytics": {
    "minimum_sample_size": 3,  // 지방지역 고려하여 5에서 3으로 조정
    "fallback_sample_size": 3,
    "comparison_priority": ["dong", "sigungu", "sido", "region_zone"],
    "industry_filter_enabled": true
  }
}
```

**⚠️ 모든 설정은 이 단일 JSON 스키마를 기준으로 하며, 문서 내 다른 위치에서 언급되는 설정도 이 구조에 맞춰야 한다.**

### 7.2 Industry Layer Entity 확장 규칙

(본 문서 2.6 섹션 참조)

### 7.3 테넌트 격리 구조(RLS)

(본 문서 1.3 섹션 참조)

### 7.4 Analytics Pipeline

(본 문서 3.6.5 섹션 참조)

**⚠️ 2-3: Event Engine 스케줄 vs Supabase Scheduled Functions:**

위에서 정의된 Event Engine 시간 기반 스케줄(04:00 자동 청구 생성, 07:00 AI 데일리 브리핑, 03:00 AI Feedback 등)은
Supabase Scheduled Functions(또는 별도 Cron Runner)로 구현한다.

### 7.5 Materialized View 설계

**⚠️ 2-4: Materialized View Refresh 전략 (Phase 구분):**

**Phase 1 (MVP, 100~300 테넌트):**
- attendance MV → 5분 주기 갱신
- heatmap MV → 10분~15분 주기 갱신
- regional MV → 1일 1회 갱신 (00:30)

**Phase 2+ (고성능 스펙):**
- attendance MV → 30초 주기 갱신
- heatmap MV → 5분 주기 갱신
- regional MV → 1일 1회 갱신 (00:30) (동일)

**Materialized View 예시 (⚠️ 이슈 3: MV vs 테이블 구분):**

| 이름 | 타입 | 설명 |
|---|---|---|
| daily_attendance_stats | TABLE (Staging) | 일별 출결 통계 |
| class_attendance_heatmap | TABLE (Staging) | 반별 출결 히트맵 |
| regional_metrics_daily | MATERIALIZED VIEW | 지역별 일일 통계 (정본 이름, 통계문서와 일치) |
| tenant_kpi_daily | MATERIALIZED VIEW | 테넌트별 KPI 일일 집계 |
| ai_insight_materialized | MATERIALIZED VIEW | AI 인사이트 Materialized View |

**참고:** Staging 테이블은 원천 데이터에서 집계된 중간 테이블이며, Materialized View는 Staging 테이블 또는 Raw 데이터를 기반으로 주기적으로 갱신되는 최종 분석 뷰이다.

### 7.6 Backfill/Repair

(본 문서 3.6.6 섹션 참조)

### 7.7 Audit Log 정책

**Audit Log 정책:**

모든 중요한 데이터 변경은 Audit Log에 기록되어야 한다.

**Audit Log 테이블 예시:**
- automation_undo_logs: 자동화 Undo 이력
- event_logs: 이벤트 처리 이력
- ai_feedback_logs: AI 피드백 이력

**Audit Log 기록 항목:**
- 변경 전 상태 (before_state)
- 변경 후 상태 (after_state)
- 변경자 (user_id)
- 변경 시간 (created_at)
- 변경 사유 (reason)

### 7.8 AI Feedback 저장 모델

(본 문서 3.7.7 섹션 참조)

## 8. 결제 아키텍처 (Payment Architecture)

### 8.1 알림뱅크 API 구조

**중요: 디어쌤 플랫폼은 결제 로직(이체, 카드승인, 간편결제)을 직접 구현하지 않는다.**

모든 결제는 알림뱅크(효성FMS) 및 그 하위 PG사에서 처리되며, 디어쌤은 API 호출 + Webhook 수신 + DB 업데이트만 담당한다.

**결제 수단:**
- 계좌이체(알림뱅크 가상계좌/계좌이체)
- 카드결제 (알림뱅크 연동 PG)
- 간편결제(카카오페이/네이버페이 등, 알림뱅크를 통해 제공)

### 8.2 결제 요청 → 승인 → Webhook

**Billing & Payment 아키텍처 개요:**

알림뱅킹 ↔ Edge Function ↔ audit.webhook_events ↔ payments/invoices ↔ Reconcile UI

**핵심 구성 요소:**
- **Core Billing 모듈**: invoices/invoice_items/payments 구조 (T3 참조)
- **알림뱅킹 Adapter**: Edge Function 기반 결제 요청/Webhook 처리
- **Event/Hook 구조**: Webhook 이벤트 추적 및 재시도 메커니즘

**멱등성 · Advisory Lock · Webhook 재시도 규칙:**
- T3 참조 (14-2-1-1 섹션: 결제/알림뱅킹 운영 정책)
- R7.4 참조

**실패 시 Fallback 경로:**

알림뱅킹 Webhook 실패/지연 시 처리 흐름:

1. **Webhook 실패 감지:**
   - `audit.webhook_events` 테이블에 실패 상태 기록
   - 재시도 큐에 추가 (지수 백오프: 5s → 30s → 2m → 10m → 30m, 최대 5회)

2. **최대 재시도 초과 시:**
   - Dead Letter Queue(DLQ)로 이동
   - 운영자 알림 카드 생성
   - 수동 조정 UI에서 재처리 가능

3. **정산 불일치 감지:**
   - `audit.webhook_events` vs `payments` vs 정산 데이터 비교
   - 불일치 금액 < 1,000원: 자동 조정 (로그 기록)
   - 불일치 금액 ≥ 1,000원: 수동 조정 UI에서 승인 필요

4. **수동 조정 UI:**
   - 정산 불일치 목록 조회 (날짜별, 업체별 필터)
   - 불일치 상세 내역 확인 (webhook 이벤트 vs 정산 데이터 비교)
   - 수동 조정 승인/거부 (승인 시 audit.events에 기록)
   - 조정 이력 조회

**상세 구현:**
- T3 참조 (14-2-1-1 섹션: 결제/알림뱅킹 운영 정책)
- R7.4 참조

**⚠️ 트랜잭션 격리 수준:**

Billing/Payments 트랜잭션 격리 수준은 전체 기술문서 PART 4-1-1의 규칙(Billing/Payments는 REPEATABLE READ)을 따른다.

### 8.3 부분납부 처리

(본 문서 3.4.3 섹션 참조)

### 8.4 Early Payment

(본 문서 3.4.4 섹션 참조)

### 8.5 Smart Retry Logic

(본 문서 3.4.5 섹션 참조)

### 8.6 멱등성 처리

**Webhook 멱등성:**
- idempotency_key로 중복 콜백 방지
- 동일 idempotency_key는 한 번만 처리
- 중복 요청 시 기존 결과 반환

### 8.7 정산/회계 책임 범위

**정산/회계 책임:**
- 정산/회계는 알림뱅크 및 PG사에서 제공하는 정산 내역을 기준으로 하며,
- 디어쌤은 조회·필터·통계·대시보드 역할에 집중한다.

## 9. 운영·배포 구조 (DevOps / Deployment)

### 9.1 Vercel + Supabase 구조

**배포 구조:**
- Frontend: Vercel 배포
- Backend: Supabase (PostgreSQL + Edge Functions)
- 인증: Supabase Auth
- 스토리지: Supabase Storage

### 9.2 CI/CD Workflow (TurboRepo + Git)

**Monorepo 구조:**
- TurboRepo 기반 빌드 시스템
- Git 기반 버전 관리
- 자동 배포 파이프라인

**⚠️ 2-3: Event Engine 스케줄 vs Supabase Scheduled Functions:**

문서에서 정의된 Event Engine 시간 기반 스케줄은 Supabase Scheduled Functions(또는 별도 Cron Runner)로 구현한다:
- 04:00 자동 청구 생성
- 07:00 AI 데일리 브리핑 생성
- 03:00 AI Feedback Queue Refill
- 04:00 (일요일) AI 모델 재학습
- 23:59 일일 통계 업데이트

### 9.3 환경변수 & Secrets 관리

**환경변수 관리:**
- Vercel 환경변수 설정
- Supabase Secrets 관리
- 민감 정보는 Secrets로 관리

### 9.4 에러 모니터링(Sentry)

**에러 모니터링:**
- Sentry를 통한 에러 추적
- 실시간 알림 설정
- 에러 로그 분석

### 9.5 성능 기준(FCP, Bundle Size ≤ 500KB)

**성능 기준:**
- First Contentful Paint (FCP) 최적화
- Bundle Size ≤ 500KB
- 이미지 최적화
- 코드 스플리팅

### 9.6 Logging & Observability

**로깅 전략:**
- 구조화된 로그 형식
- 로그 레벨 관리 (DEBUG, INFO, WARN, ERROR)
- 로그 집계 및 분석

### 9.7 Scale-up 전략 (20,000 테넌트 대비)

**스케일 업 전략:**
- 데이터베이스 샤딩 (필요 시)
  - 샤딩 단위: `tenant_id` 또는 `industry_type + tenant_id`를 기준으로 한다
  - 테넌트별 데이터 격리 유지
- 캐싱 전략 (Redis)
- CDN 활용
- Edge Function 최적화

### 9.8 Disaster Recovery & Backup

**⚠️ 백업·DR·Region 전략 계층적 로드맵:**

본 문서에서는 백업·DR·Region 전략의 계층적 로드맵만 명시하며, 상세 RTO/RPO 값 및 Region Failover 정책은 T7을 참조합니다.

**Phase 1: 단일 Region + 정기 백업**
- Supabase 자동 백업 활용
- 일일 자동 백업
- PITR(Point-In-Time Recovery) 기능 활용
- 백업 보관 기간 설정

**Phase 2: Read Replica 기반 보고서 분리**
- 읽기 전용 쿼리를 Read Replica로 분리
- 보고서/통계 조회 성능 향상
- 메인 DB 부하 감소

**Phase 3+: 멀티 리전/DR**
- Region Failover 전략
- 상세 RTO/RPO 정책
- 자동 장애 복구 메커니즘

**상세 정책:**
- T7 참조 (Multi-Region DR은 Phase 3+에서 외부 DB 기반으로 구현)

## 10. 보안(Security) 규약

### 10.1 Zero-Trust Data Path

(본 문서 1.4 섹션 참조)

### 10.2 Supabase RLS 정책 표준

(본 문서 1.3 섹션 참조)

### 10.3 Audit Log & Event Log

(본 문서 7.7 섹션 참조)

### 10.4 API Request Signature(HMAC)

**HMAC 서명:**
- QR 토큰 서명에 HMAC 사용
- API 요청 서명 검증
- 서명 키는 Secrets로 관리

### 10.5 QR Token Security

(본 문서 3.3.5 섹션 참조)

### 10.6 Parent App 인증 모델

**학부모 앱 인증:**
- Public Gateway를 통한 인증
- JWT 토큰 기반 인증
- 자녀 정보만 접근 가능

### 10.7 Rate Limit & Abuse Detection

**⚠️ M4: Notification Throttling 중복 제거:**

Rate Limit 규칙은 **3.5.5 Notification Throttling Rule** 섹션을 참조합니다.

**Rate Limit (본 문서 3.5.5 섹션 참조):**
- 서버 전체: 50건/초
- 단일 테넌트: 3건/초
- 초과 시 자동 큐잉 및 지연 처리

**Abuse Detection:**
- 동일 IP에서 과도한 요청: 1분에 100회 초과 시 자동 차단
- 스팸성 메시지 자동 차단: AI 기반 스팸 감지
- 비정상 패턴 감지 시 자동 계정 일시 정지

### 10.8 Data Encryption 정책

**⚠️ 2-2: PII/암호화 섹션 Phase 구분 명시:**

**Phase 1 (MVP):**
- 최소 수집, 노출 최소화, UI/로그 마스킹 위주
- DB 컬럼은 평문이지만 RLS + 권한 + Audit Log로 방어
- 전송 중 암호화 (HTTPS)

**Phase 2+:**
- 점진적 컬럼 암호화 검토

**Phase 3+:**
- App Layer AEAD(Envelope Encryption) 암호화 기본 적용
- pgcrypto는 여전히 사용하지 않음 (운영 복잡성, 마이그레이션 이유)
- 자세한 키 회전/PII 카탈로그는 전체 기술문서 19장 참조

**데이터 암호화:**
- 전송 중 암호화 (HTTPS)
- 저장 데이터 암호화 (Phase별 적용)
- 민감 정보 마스킹 (Phase 1부터 적용)

**⚠️ 2-6: 보안 섹션 - Audit/Monitoring/Alerting 연결:**

**Audit Log → 보안 이벤트 연계:**
- 권한 실패, RLS 차단, 비정상 로그인 시도 등 보안 이벤트는 Audit Log에 기록
- 보안 관련 에러는 Monitoring/Alerting Tool(Sentry, Logflare 등)과 연동하여 동일 채널에서 모니터링

**운영 자동화/알람:**
- Custom Domain 헬스체크, SSL 만료 알람, Auth Redirect Allowlist 동기화 배치 등은 전체 기술문서 28장 참고
- 보안 = 규칙 + 모니터링 원칙 적용

## 11. API / Edge Function 구조

### 11.1 Public Gateway API

**Public Gateway 역할:**
- 학부모 앱 접근
- QR 출결 접근
- 공개 API 제공

**Public Gateway 엔드포인트:**
- /public-gateway/payment/**
- /public-gateway/attendance/notifications
- /public-gateway/billing/history

### 11.2 Supabase Edge Function 구조

**Edge Function 구조:**
- Domain Function (Students, Classes, Billing 등)
- Payment Function (Request/Webhook)
- SDUI Schema API
- AI API (요약/인사이트 생성)
- Notification API

### 11.3 Domain Function (Students, Classes, Billing 등)

**도메인별 Edge Function:**
- fns-student-*: 학생 관련 함수
- fns-class-*: 반 관련 함수
- fns-billing-*: 청구 관련 함수
- fns-attendance-*: 출결 관련 함수

### 11.4 Payment Function (Request/Webhook)

(본 문서 8.2 섹션 참조)

### 11.5 SDUI Schema API

**SDUI Schema API:**
- 스키마 조회 API
- 스키마 업데이트 API
- 테넌트별 커스텀 스키마 API

### 11.6 AI API (요약/인사이트 생성)

**AI API:**
- 상담일지 요약 API
- AI 인사이트 생성 API
- 위험 탐지 API

### 11.7 Notification API

**Notification API:**
- 메시지 발송 API
- 템플릿 관리 API
- 발송 내역 조회 API

## 12. 운영 매뉴얼 (Operation Manual)

### 12.1 테넌트 생성

**⚠️ B3: 테넌트 생성 플로우에 location_code 등록 Step 추가:**

**테넌트 생성 절차 (v3.3 확정):**

Regional Analytics는 `tenant_settings.location.*`이 필수이므로, 테넌트 생성 시 위치 정보를 반드시 등록해야 합니다:

**Step 1: 업종 선택**
- 학원 (academy)
- 미용실 (salon)
- 부동산 (real_estate)

**Step 2: 학원 기본 정보 입력**
- 학원명
- 대표자명
- 연락처
- 이메일

**Step 3: 주소 입력 → 행정동 코드 자동 매핑**
- 주소 검색 (다음/카카오 주소 API 연동)
- 시/도 선택
- 시/군/구 선택
- 동 선택
- 상세 주소 입력
- **자동 매핑:**
  - `sido_code`: 시/도 코드 (예: "11" = 서울특별시)
  - `sigungu_code`: 시/군/구 코드 (예: "11680" = 강남구)
  - `location_code`: 행정동 코드 (예: "1168010100" = 대치동)

**Step 4: 지도에서 위치 조정 (선택)**
- 지도에서 정확한 위치 선택
- `lat`, `lng` 자동 저장
- 지도에서 선택하지 않으면 주소 기반 좌표 자동 설정

**Step 5: 지역 코드 저장**
- `tenant_settings.location`에 모든 위치 정보 저장:
  ```json
  {
    "location": {
      "si": "서울특별시",
      "gu": "강남구",
      "dong": "대치동",
      "lat": 37.498,
      "lng": 127.061,
      "sido_code": "11",
      "sigungu_code": "11680",
      "location_code": "1168010100",
      "region_code": null  // 본사에서 나중에 설정 가능
    }
  }
  ```

**Step 6: 기본 설정 완료**
- 테넌트 생성 완료
- Regional Analytics 사용 가능

**기존 테넌트 생성 절차 (위치 정보 필수):**
1. 테넌트 기본 정보 입력
2. 위치 정보 설정 (필수)
3. 초기 사용자 생성
4. 권한 설정

### 12.2 위치 정보 설정

(본 문서 3.6.1 섹션 참조)

### 12.3 알림뱅크 등록 절차

**알림뱅크 등록:**
1. 알림뱅크 계정 생성
2. API 키 발급
3. Webhook URL 설정
4. 테스트 결제 진행

### 12.4 카카오 알림톡 템플릿 승인

(본 문서 3.5.3 섹션 참조)

### 12.5 데이터 재집계(Backfill)

(본 문서 3.6.6 섹션 참조)

### 12.6 Quota 증가 요청

**Quota 관리:**
- Quota 사용량 실시간 모니터링
- Quota 초과 시 관리자 대시보드에 알림
- Quota 증가 요청 프로세스 제공

### 12.7 학부모 앱 초기 설정

**학부모 앱 설정:**
1. 학부모 계정 생성
2. 자녀 정보 연결
3. 알림 설정
4. 결제 수단 등록

## 13. 부록(Appendix)

### 13.1 모든 테이블 스키마 목록

**주요 테이블:**
- students: 학생 정보
- classes: 반 정보
- attendance_logs: 출결 로그 (⚠️ B6: Device Fingerprint/GPS/Auth Method 필드 포함)
- invoices: 청구서 (id, tenant_id, student_id, amount, amount_paid, amount_due, status, period_start, period_end, ...)
- payments: 결제 내역
- event_logs: 이벤트 로그
- ai_feedback_logs: AI 피드백 로그
- automation_undo_logs: 자동화 Undo 로그
- tenants: 테넌트 기본 정보
- tenant_settings: 테넌트별 JSON 설정 (attendance, location, notification, billing 등)

### 13.2 Materialized View SQL

(본 문서 7.5 섹션 참조)

### 13.3 SDUI Schema JSON 샘플

(본 문서 5.3 섹션 참조)

### 13.4 Event Logs 샘플

**Event Log 예시:**
```json
{
  "id": "uuid",
  "idempotency_key": "webhook_alimbank_12345_20240101",
  "event_type": "payment_webhook",
  "tenant_id": "uuid",
  "payload": {
    "invoice_id": "uuid",
    "amount": 300000,
    "status": "paid"
  },
  "status": "completed",
  "created_at": "2024-01-01T00:00:00Z",
  "processed_at": "2024-01-01T00:00:01Z",
  "retry_count": 0
}
```

### 13.5 AI 브리핑 샘플

**AI 브리핑 예시:**
- "원장님, 오늘 3건의 상담이 필요하며 2명의 학생이 이탈 위험 단계입니다."
- "이번 주 수업 중 수학A반 출결률이 지역 평균 대비 12% 낮습니다. 원인을 분석할까요?"
- "이번 달 청구서가 자동 발송되었습니다. 예상 수납률은 92%입니다."

### 13.6 화면 와이어프레임

**주요 화면:**
- 홈 대시보드
- 출결 화면
- 학생 관리 화면
- 수납/청구 화면
- 통계 화면
- AI 인사이트 화면

### 13.7 용어집

**주요 용어:**
- Zero-Management: 관리 필요 없음, 시스템이 자동으로 운영
- SDUI: Schema-Driven UI, 스키마 기반 화면 자동 생성
- RLS: Row Level Security, 행 단위 보안 정책
- Multi-Tenant: 멀티테넌트, 단일 인스턴스에서 여러 고객 격리
- Regional Analytics: 지역 기반 통계, 지역 단위 비교 분석
- Auto-Billing: 자동 청구 생성 및 발송
- Partial Payment: 부분납부, 청구 금액의 일부만 납부
- Early Payment: 조기납부, 기간 내 조기 납부 시 할인
- StudentTaskCard: 학생 업무 카드, AI가 자동 생성하는 업무 목록
- Idempotency: 멱등성, 동일 요청의 반복 실행 시 동일 결과 보장

---

**문서 버전:** v3.3
**최종 업데이트:** 2025-12-10
**작성자:** 디어쌤 개발팀

---

## 📌 중요 통합 구조 명시

### 출결 설정 통합 구조

**⚠️ 출결 설정은 단일 JSON 구조로 통합:**

출결 설정(attendance_settings)은 단일 JSON 구조(`tenant_settings.attendance`)로 통합되어야 하며, QR 인증/보조 인증/토큰 로직/지각 기준/중복 체크/출결 모드도 모두 이 JSON 구조에서 제어된다.

**※ 이 구조의 공식 정의는 3.3.7 섹션을 참조한다.**

**⚠️ 🔥 3번: attendance_settings JSON 중복 제거:**

**단일 소스 원칙:**

출결 설정 JSON은 **3.3.7 출결 설정** 섹션의 `tenant_settings.attendance` 공식 스펙만 유지하고, 다른 섹션에서는 참조 형태로만 언급:

- `class_specific_late_rules`: 3.3.7 참조
- `qr_token_expiry_days`: 3.3.7 참조
- `device_fingerprint_fallback_policy`: 3.3.7 참조

**다른 섹션에서 출결 설정을 언급할 때:**
- "3.3.7 출결 설정의 `tenant_settings.attendance` 공식 스펙 참조" 형태로만 언급
- 중복된 필드 정의 제거

**⚠️ C6: 출결 설정 JSON 구조 중복 제거:**

문서 내 2개 버전 존재 → 아래 확정본 1개만 사용:

**확정본 (3.3.7 섹션의 공식 스펙):**

위의 `tenant_settings.attendance 공식 스펙 (단일 소스)` 섹션(3.3.7 출결 설정, 1732-1776줄)이 유일한 정식 정의입니다.

**다른 섹션에서 출결 설정을 언급할 때는:**
- "3.3.7 출결 설정의 `tenant_settings.attendance` 공식 스펙 참조" 형태로만 언급
- 중복된 JSON 구조 정의 제거

